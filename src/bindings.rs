/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const PG_DIAG_SEVERITY: u8 = 83u8;
pub const PG_DIAG_SEVERITY_NONLOCALIZED: u8 = 86u8;
pub const PG_DIAG_SQLSTATE: u8 = 67u8;
pub const PG_DIAG_MESSAGE_PRIMARY: u8 = 77u8;
pub const PG_DIAG_MESSAGE_DETAIL: u8 = 68u8;
pub const PG_DIAG_MESSAGE_HINT: u8 = 72u8;
pub const PG_DIAG_STATEMENT_POSITION: u8 = 80u8;
pub const PG_DIAG_INTERNAL_POSITION: u8 = 112u8;
pub const PG_DIAG_INTERNAL_QUERY: u8 = 113u8;
pub const PG_DIAG_CONTEXT: u8 = 87u8;
pub const PG_DIAG_SCHEMA_NAME: u8 = 115u8;
pub const PG_DIAG_TABLE_NAME: u8 = 116u8;
pub const PG_DIAG_COLUMN_NAME: u8 = 99u8;
pub const PG_DIAG_DATATYPE_NAME: u8 = 100u8;
pub const PG_DIAG_CONSTRAINT_NAME: u8 = 110u8;
pub const PG_DIAG_SOURCE_FILE: u8 = 70u8;
pub const PG_DIAG_SOURCE_LINE: u8 = 76u8;
pub const PG_DIAG_SOURCE_FUNCTION: u8 = 82u8;
pub const ALIGNOF_DOUBLE: u32 = 8;
pub const ALIGNOF_INT: u32 = 4;
pub const ALIGNOF_LONG: u32 = 8;
pub const ALIGNOF_PG_INT128_TYPE: u32 = 16;
pub const ALIGNOF_SHORT: u32 = 2;
pub const BLCKSZ: u32 = 8192;
pub const DEF_PGPORT: u32 = 5432;
pub const DEF_PGPORT_STR: &'static [u8; 5usize] = b"5432\0";
pub const ENABLE_GSS: u32 = 1;
pub const ENABLE_THREAD_SAFETY: u32 = 1;
pub const HAVE_APPEND_HISTORY: u32 = 1;
pub const HAVE_ATOMICS: u32 = 1;
pub const HAVE_CBRT: u32 = 1;
pub const HAVE_CLOCK_GETTIME: u32 = 1;
pub const HAVE_COMPUTED_GOTO: u32 = 1;
pub const HAVE_CRYPT: u32 = 1;
pub const HAVE_CRYPTO_LOCK: u32 = 1;
pub const HAVE_DECL_FDATASYNC: u32 = 0;
pub const HAVE_DECL_F_FULLFSYNC: u32 = 1;
pub const HAVE_DECL_POSIX_FADVISE: u32 = 0;
pub const HAVE_DECL_SNPRINTF: u32 = 1;
pub const HAVE_DECL_STRLCAT: u32 = 1;
pub const HAVE_DECL_STRLCPY: u32 = 1;
pub const HAVE_DECL_STRNLEN: u32 = 1;
pub const HAVE_DECL_STRTOLL: u32 = 1;
pub const HAVE_DECL_STRTOULL: u32 = 1;
pub const HAVE_DECL_SYS_SIGLIST: u32 = 1;
pub const HAVE_DECL_VSNPRINTF: u32 = 1;
pub const HAVE_DLOPEN: u32 = 1;
pub const HAVE_FDATASYNC: u32 = 1;
pub const HAVE_FLS: u32 = 1;
pub const HAVE_FSEEKO: u32 = 1;
pub const HAVE_FUNCNAME__FUNC: u32 = 1;
pub const HAVE_GCC__ATOMIC_INT32_CAS: u32 = 1;
pub const HAVE_GCC__ATOMIC_INT64_CAS: u32 = 1;
pub const HAVE_GCC__SYNC_CHAR_TAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT32_CAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT32_TAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT64_CAS: u32 = 1;
pub const HAVE_GETADDRINFO: u32 = 1;
pub const HAVE_GETIFADDRS: u32 = 1;
pub const HAVE_GETOPT: u32 = 1;
pub const HAVE_GETOPT_H: u32 = 1;
pub const HAVE_GETOPT_LONG: u32 = 1;
pub const HAVE_GETPEEREID: u32 = 1;
pub const HAVE_GETPWUID_R: u32 = 1;
pub const HAVE_GETRLIMIT: u32 = 1;
pub const HAVE_GETRUSAGE: u32 = 1;
pub const HAVE_GSSAPI_GSSAPI_H: u32 = 1;
pub const HAVE_HISTORY_TRUNCATE_FILE: u32 = 1;
pub const HAVE_IFADDRS_H: u32 = 1;
pub const HAVE_INET_ATON: u32 = 1;
pub const HAVE_INTPTR_T: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_INT_OPTERR: u32 = 1;
pub const HAVE_INT_OPTRESET: u32 = 1;
pub const HAVE_INT_TIMEZONE: u32 = 1;
pub const HAVE_IPV6: u32 = 1;
pub const HAVE_ISINF: u32 = 1;
pub const HAVE_LANGINFO_H: u32 = 1;
pub const HAVE_LDAP_H: u32 = 1;
pub const HAVE_LDAP_INITIALIZE: u32 = 1;
pub const HAVE_LIBCRYPTO: u32 = 1;
pub const HAVE_LIBLDAP: u32 = 1;
pub const HAVE_LIBLDAP_R: u32 = 1;
pub const HAVE_LIBM: u32 = 1;
pub const HAVE_LIBPAM: u32 = 1;
pub const HAVE_LIBREADLINE: u32 = 1;
pub const HAVE_LIBSSL: u32 = 1;
pub const HAVE_LIBXML2: u32 = 1;
pub const HAVE_LIBXSLT: u32 = 1;
pub const HAVE_LIBZ: u32 = 1;
pub const HAVE_LOCALE_T: u32 = 1;
pub const HAVE_LONG_INT_64: u32 = 1;
pub const HAVE_LONG_LONG_INT: u32 = 1;
pub const HAVE_MBSTOWCS_L: u32 = 1;
pub const HAVE_MEMMOVE: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_MKDTEMP: u32 = 1;
pub const HAVE_NETINET_TCP_H: u32 = 1;
pub const HAVE_NET_IF_H: u32 = 1;
pub const HAVE_POLL: u32 = 1;
pub const HAVE_POLL_H: u32 = 1;
pub const HAVE_PTHREAD: u32 = 1;
pub const HAVE_PTHREAD_IS_THREADED_NP: u32 = 1;
pub const HAVE_PTHREAD_PRIO_INHERIT: u32 = 1;
pub const HAVE_RANDOM: u32 = 1;
pub const HAVE_READLINE_HISTORY_H: u32 = 1;
pub const HAVE_READLINE_READLINE_H: u32 = 1;
pub const HAVE_READLINK: u32 = 1;
pub const HAVE_RINT: u32 = 1;
pub const HAVE_RL_COMPLETION_APPEND_CHARACTER: u32 = 1;
pub const HAVE_RL_COMPLETION_MATCHES: u32 = 1;
pub const HAVE_RL_FILENAME_COMPLETION_FUNCTION: u32 = 1;
pub const HAVE_RL_RESET_SCREEN_SIZE: u32 = 1;
pub const HAVE_SECURITY_PAM_APPL_H: u32 = 1;
pub const HAVE_SETSID: u32 = 1;
pub const HAVE_SHM_OPEN: u32 = 1;
pub const HAVE_SNPRINTF: u32 = 1;
pub const HAVE_SPINLOCKS: u32 = 1;
pub const HAVE_SRANDOM: u32 = 1;
pub const HAVE_SSL_GET_CURRENT_COMPRESSION: u32 = 1;
pub const HAVE_STDBOOL_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRERROR: u32 = 1;
pub const HAVE_STRERROR_R: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_STRLCAT: u32 = 1;
pub const HAVE_STRLCPY: u32 = 1;
pub const HAVE_STRNLEN: u32 = 1;
pub const HAVE_STRONG_RANDOM: u32 = 1;
pub const HAVE_STRTOLL: u32 = 1;
pub const HAVE_STRTOULL: u32 = 1;
pub const HAVE_STRUCT_ADDRINFO: u32 = 1;
pub const HAVE_STRUCT_OPTION: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_SA_LEN: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_STORAGE: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN: u32 = 1;
pub const HAVE_STRUCT_TM_TM_ZONE: u32 = 1;
pub const HAVE_SYMLINK: u32 = 1;
pub const HAVE_SYSLOG: u32 = 1;
pub const HAVE_SYS_IPC_H: u32 = 1;
pub const HAVE_SYS_RESOURCE_H: u32 = 1;
pub const HAVE_SYS_SELECT_H: u32 = 1;
pub const HAVE_SYS_SEM_H: u32 = 1;
pub const HAVE_SYS_SHM_H: u32 = 1;
pub const HAVE_SYS_SOCKIO_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_SYS_UCRED_H: u32 = 1;
pub const HAVE_SYS_UN_H: u32 = 1;
pub const HAVE_TERMIOS_H: u32 = 1;
pub const HAVE_TM_ZONE: u32 = 1;
pub const HAVE_TYPEOF: u32 = 1;
pub const HAVE_TZNAME: u32 = 1;
pub const HAVE_UINTPTR_T: u32 = 1;
pub const HAVE_UNION_SEMUN: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const HAVE_UNIX_SOCKETS: u32 = 1;
pub const HAVE_UNSETENV: u32 = 1;
pub const HAVE_UNSIGNED_LONG_LONG_INT: u32 = 1;
pub const HAVE_UTIME: u32 = 1;
pub const HAVE_UTIMES: u32 = 1;
pub const HAVE_UTIME_H: u32 = 1;
pub const HAVE_UUID_E2FS: u32 = 1;
pub const HAVE_UUID_UUID_H: u32 = 1;
pub const HAVE_VSNPRINTF: u32 = 1;
pub const HAVE_WCHAR_H: u32 = 1;
pub const HAVE_WCSTOMBS_L: u32 = 1;
pub const HAVE_WCTYPE_H: u32 = 1;
pub const HAVE_X509_GET_SIGNATURE_NID: u32 = 1;
pub const HAVE__BOOL: u32 = 1;
pub const HAVE__BUILTIN_BSWAP16: u32 = 1;
pub const HAVE__BUILTIN_BSWAP32: u32 = 1;
pub const HAVE__BUILTIN_BSWAP64: u32 = 1;
pub const HAVE__BUILTIN_CONSTANT_P: u32 = 1;
pub const HAVE__BUILTIN_OP_OVERFLOW: u32 = 1;
pub const HAVE__BUILTIN_TYPES_COMPATIBLE_P: u32 = 1;
pub const HAVE__BUILTIN_UNREACHABLE: u32 = 1;
pub const HAVE__GET_CPUID: u32 = 1;
pub const HAVE__STATIC_ASSERT: u32 = 1;
pub const HAVE__VA_ARGS: u32 = 1;
pub const INT64_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const LOCALE_T_IN_XLOCALE: u32 = 1;
pub const MAXIMUM_ALIGNOF: u32 = 8;
pub const MEMSET_LOOP_LIMIT: u32 = 1024;
pub const PACKAGE_BUGREPORT: &'static [u8; 26usize] = b"pgsql-bugs@postgresql.org\0";
pub const PACKAGE_NAME: &'static [u8; 11usize] = b"PostgreSQL\0";
pub const PACKAGE_STRING: &'static [u8; 16usize] = b"PostgreSQL 11.1\0";
pub const PACKAGE_TARNAME: &'static [u8; 11usize] = b"postgresql\0";
pub const PACKAGE_URL: &'static [u8; 1usize] = b"\0";
pub const PACKAGE_VERSION: &'static [u8; 5usize] = b"11.1\0";
pub const PG_KRB_SRVNAM: &'static [u8; 9usize] = b"postgres\0";
pub const PG_MAJORVERSION: &'static [u8; 3usize] = b"11\0";
pub const PG_VERSION: &'static [u8; 5usize] = b"11.1\0";
pub const PG_VERSION_NUM: u32 = 110001;
pub const PG_VERSION_STR : & 'static [ u8 ; 113usize ] = b"PostgreSQL 11.1 on x86_64-apple-darwin18.2.0, compiled by Apple LLVM version 10.0.0 (clang-1000.11.45.5), 64-bit\0" ;
pub const RELSEG_SIZE: u32 = 131072;
pub const SIZEOF_BOOL: u32 = 1;
pub const SIZEOF_LONG: u32 = 8;
pub const SIZEOF_OFF_T: u32 = 8;
pub const SIZEOF_SIZE_T: u32 = 8;
pub const SIZEOF_VOID_P: u32 = 8;
pub const STDC_HEADERS: u32 = 1;
pub const STRERROR_R_INT: u32 = 1;
pub const USE_BONJOUR: u32 = 1;
pub const USE_FLOAT4_BYVAL: u32 = 1;
pub const USE_FLOAT8_BYVAL: u32 = 1;
pub const USE_ICU: u32 = 1;
pub const USE_LDAP: u32 = 1;
pub const USE_LIBXML: u32 = 1;
pub const USE_LIBXSLT: u32 = 1;
pub const USE_OPENSSL: u32 = 1;
pub const USE_OPENSSL_RANDOM: u32 = 1;
pub const USE_PAM: u32 = 1;
pub const USE_SSE42_CRC32C: u32 = 1;
pub const USE_SYSV_SEMAPHORES: u32 = 1;
pub const USE_SYSV_SHARED_MEMORY: u32 = 1;
pub const WCSTOMBS_L_IN_XLOCALE: u32 = 1;
pub const XLOG_BLCKSZ: u32 = 8192;
pub const DEFAULT_XLOG_SEG_SIZE: u32 = 16777216;
pub const NAMEDATALEN: u32 = 64;
pub const FUNC_MAX_ARGS: u32 = 100;
pub const INDEX_MAX_KEYS: u32 = 32;
pub const PARTITION_MAX_KEYS: u32 = 32;
pub const NUM_SPINLOCK_SEMAPHORES: u32 = 128;
pub const NUM_ATOMICS_SEMAPHORES: u32 = 64;
pub const MAXPGPATH: u32 = 1024;
pub const PG_SOMAXCONN: u32 = 10000;
pub const BITS_PER_BYTE: u32 = 8;
pub const ALIGNOF_BUFFER: u32 = 32;
pub const HAVE_WORKING_LINK: u32 = 1;
pub const DEFAULT_BACKEND_FLUSH_AFTER: u32 = 0;
pub const DEFAULT_BGWRITER_FLUSH_AFTER: u32 = 0;
pub const DEFAULT_CHECKPOINT_FLUSH_AFTER: u32 = 0;
pub const WRITEBACK_MAX_PENDING_FLUSHES: u32 = 256;
pub const DEFAULT_PGSOCKET_DIR: &'static [u8; 5usize] = b"/tmp\0";
pub const DEFAULT_EVENT_SOURCE: &'static [u8; 11usize] = b"PostgreSQL\0";
pub const PG_CACHE_LINE_SIZE: u32 = 128;
pub const TRACE_SORT: u32 = 1;
pub const __darwin__: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101304;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const __CTERMID_DEFINED: u32 = 1;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _I386_SIGNAL_H_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const FP_PREC_24B: u32 = 0;
pub const FP_PREC_53B: u32 = 2;
pub const FP_PREC_64B: u32 = 3;
pub const FP_RND_NEAR: u32 = 0;
pub const FP_RND_DOWN: u32 = 1;
pub const FP_RND_UP: u32 = 2;
pub const FP_CHOP: u32 = 3;
pub const FP_STATE_BYTES: u32 = 512;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_CURRENT: u32 = 4;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const LC_ALL: u32 = 0;
pub const LC_COLLATE: u32 = 1;
pub const LC_CTYPE: u32 = 2;
pub const LC_MONETARY: u32 = 3;
pub const LC_NUMERIC: u32 = 4;
pub const LC_TIME: u32 = 5;
pub const LC_MESSAGES: u32 = 6;
pub const _LC_LAST: u32 = 7;
pub const HAVE_PG_ATTRIBUTE_NORETURN: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const USE_STDBOOL: u32 = 1;
pub const INT64_FORMAT: &'static [u8; 4usize] = b"%ld\0";
pub const UINT64_FORMAT: &'static [u8; 4usize] = b"%lu\0";
pub const HAVE_INT128: u32 = 1;
pub const PG_INT8_MIN: i32 = -128;
pub const PG_INT8_MAX: u32 = 127;
pub const PG_UINT8_MAX: u32 = 255;
pub const PG_INT16_MIN: i32 = -32768;
pub const PG_INT16_MAX: u32 = 32767;
pub const PG_UINT16_MAX: u32 = 65535;
pub const PG_INT32_MIN: i32 = -2147483648;
pub const PG_INT32_MAX: u32 = 2147483647;
pub const PG_UINT32_MAX: u32 = 4294967295;
pub const MAXDIM: u32 = 6;
pub const HIGHBIT: u32 = 128;
pub const ESCAPE_STRING_SYNTAX: u8 = 69u8;
pub const STATUS_OK: u32 = 0;
pub const STATUS_ERROR: i32 = -1;
pub const STATUS_EOF: i32 = -2;
pub const STATUS_FOUND: u32 = 1;
pub const STATUS_WAITING: u32 = 2;
pub const PG_BINARY: u32 = 0;
pub const PG_BINARY_A: &'static [u8; 2usize] = b"a\0";
pub const PG_BINARY_R: &'static [u8; 2usize] = b"r\0";
pub const PG_BINARY_W: &'static [u8; 2usize] = b"w\0";
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &'static [u8; 9usize] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_MASTER_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: u32 = 7;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_MAX: u32 = 40;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_MAX: u32 = 40;
pub const NET_MAXID: u32 = 40;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_MAXID: u32 = 10;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_IPV4: u32 = 4;
pub const IPPROTO_IPIP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_ST: u32 = 7;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PIGP: u32 = 9;
pub const IPPROTO_RCCMON: u32 = 10;
pub const IPPROTO_NVPII: u32 = 11;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_ARGUS: u32 = 13;
pub const IPPROTO_EMCON: u32 = 14;
pub const IPPROTO_XNET: u32 = 15;
pub const IPPROTO_CHAOS: u32 = 16;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_MUX: u32 = 18;
pub const IPPROTO_MEAS: u32 = 19;
pub const IPPROTO_HMP: u32 = 20;
pub const IPPROTO_PRM: u32 = 21;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_TRUNK1: u32 = 23;
pub const IPPROTO_TRUNK2: u32 = 24;
pub const IPPROTO_LEAF1: u32 = 25;
pub const IPPROTO_LEAF2: u32 = 26;
pub const IPPROTO_RDP: u32 = 27;
pub const IPPROTO_IRTP: u32 = 28;
pub const IPPROTO_TP: u32 = 29;
pub const IPPROTO_BLT: u32 = 30;
pub const IPPROTO_NSP: u32 = 31;
pub const IPPROTO_INP: u32 = 32;
pub const IPPROTO_SEP: u32 = 33;
pub const IPPROTO_3PC: u32 = 34;
pub const IPPROTO_IDPR: u32 = 35;
pub const IPPROTO_XTP: u32 = 36;
pub const IPPROTO_DDP: u32 = 37;
pub const IPPROTO_CMTP: u32 = 38;
pub const IPPROTO_TPXX: u32 = 39;
pub const IPPROTO_IL: u32 = 40;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_SDRP: u32 = 42;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_IDRP: u32 = 45;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_GRE: u32 = 47;
pub const IPPROTO_MHRP: u32 = 48;
pub const IPPROTO_BHA: u32 = 49;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_INLSP: u32 = 52;
pub const IPPROTO_SWIPE: u32 = 53;
pub const IPPROTO_NHRP: u32 = 54;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_AHIP: u32 = 61;
pub const IPPROTO_CFTP: u32 = 62;
pub const IPPROTO_HELLO: u32 = 63;
pub const IPPROTO_SATEXPAK: u32 = 64;
pub const IPPROTO_KRYPTOLAN: u32 = 65;
pub const IPPROTO_RVD: u32 = 66;
pub const IPPROTO_IPPC: u32 = 67;
pub const IPPROTO_ADFS: u32 = 68;
pub const IPPROTO_SATMON: u32 = 69;
pub const IPPROTO_VISA: u32 = 70;
pub const IPPROTO_IPCV: u32 = 71;
pub const IPPROTO_CPNX: u32 = 72;
pub const IPPROTO_CPHB: u32 = 73;
pub const IPPROTO_WSN: u32 = 74;
pub const IPPROTO_PVP: u32 = 75;
pub const IPPROTO_BRSATMON: u32 = 76;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_WBMON: u32 = 78;
pub const IPPROTO_WBEXPAK: u32 = 79;
pub const IPPROTO_EON: u32 = 80;
pub const IPPROTO_VMTP: u32 = 81;
pub const IPPROTO_SVMTP: u32 = 82;
pub const IPPROTO_VINES: u32 = 83;
pub const IPPROTO_TTP: u32 = 84;
pub const IPPROTO_IGP: u32 = 85;
pub const IPPROTO_DGP: u32 = 86;
pub const IPPROTO_TCF: u32 = 87;
pub const IPPROTO_IGRP: u32 = 88;
pub const IPPROTO_OSPFIGP: u32 = 89;
pub const IPPROTO_SRPC: u32 = 90;
pub const IPPROTO_LARP: u32 = 91;
pub const IPPROTO_MTP: u32 = 92;
pub const IPPROTO_AX25: u32 = 93;
pub const IPPROTO_IPEIP: u32 = 94;
pub const IPPROTO_MICP: u32 = 95;
pub const IPPROTO_SCCSP: u32 = 96;
pub const IPPROTO_ETHERIP: u32 = 97;
pub const IPPROTO_ENCAP: u32 = 98;
pub const IPPROTO_APES: u32 = 99;
pub const IPPROTO_GMTP: u32 = 100;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_IPCOMP: u32 = 108;
pub const IPPROTO_PGM: u32 = 113;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_DIVERT: u32 = 254;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const IPPROTO_DONE: u32 = 257;
pub const __DARWIN_IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_USERRESERVED: u32 = 5000;
pub const IPPORT_HIFIRSTAUTO: u32 = 49152;
pub const IPPORT_HILASTAUTO: u32 = 65535;
pub const IPPORT_RESERVEDSTART: u32 = 600;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const INADDR_NONE: u32 = 4294967295;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_MULTICAST_VIF: u32 = 14;
pub const IP_RSVP_ON: u32 = 15;
pub const IP_RSVP_OFF: u32 = 16;
pub const IP_RSVP_VIF_ON: u32 = 17;
pub const IP_RSVP_VIF_OFF: u32 = 18;
pub const IP_PORTRANGE: u32 = 19;
pub const IP_RECVIF: u32 = 20;
pub const IP_IPSEC_POLICY: u32 = 21;
pub const IP_FAITH: u32 = 22;
pub const IP_STRIPHDR: u32 = 23;
pub const IP_RECVTTL: u32 = 24;
pub const IP_BOUND_IF: u32 = 25;
pub const IP_PKTINFO: u32 = 26;
pub const IP_RECVPKTINFO: u32 = 26;
pub const IP_RECVTOS: u32 = 27;
pub const IP_FW_ADD: u32 = 40;
pub const IP_FW_DEL: u32 = 41;
pub const IP_FW_FLUSH: u32 = 42;
pub const IP_FW_ZERO: u32 = 43;
pub const IP_FW_GET: u32 = 44;
pub const IP_FW_RESETLOG: u32 = 45;
pub const IP_OLD_FW_ADD: u32 = 50;
pub const IP_OLD_FW_DEL: u32 = 51;
pub const IP_OLD_FW_FLUSH: u32 = 52;
pub const IP_OLD_FW_ZERO: u32 = 53;
pub const IP_OLD_FW_GET: u32 = 54;
pub const IP_NAT__XXX: u32 = 55;
pub const IP_OLD_FW_RESETLOG: u32 = 56;
pub const IP_DUMMYNET_CONFIGURE: u32 = 60;
pub const IP_DUMMYNET_DEL: u32 = 61;
pub const IP_DUMMYNET_FLUSH: u32 = 62;
pub const IP_DUMMYNET_GET: u32 = 64;
pub const IP_TRAFFIC_MGT_BACKGROUND: u32 = 65;
pub const IP_MULTICAST_IFINDEX: u32 = 66;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 71;
pub const IP_BLOCK_SOURCE: u32 = 72;
pub const IP_UNBLOCK_SOURCE: u32 = 73;
pub const IP_MSFILTER: u32 = 74;
pub const MCAST_JOIN_GROUP: u32 = 80;
pub const MCAST_LEAVE_GROUP: u32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 83;
pub const MCAST_BLOCK_SOURCE: u32 = 84;
pub const MCAST_UNBLOCK_SOURCE: u32 = 85;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MIN_MEMBERSHIPS: u32 = 31;
pub const IP_MAX_MEMBERSHIPS: u32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: u32 = 128;
pub const MCAST_UNDEFINED: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const MCAST_EXCLUDE: u32 = 2;
pub const IP_PORTRANGE_DEFAULT: u32 = 0;
pub const IP_PORTRANGE_HIGH: u32 = 1;
pub const IP_PORTRANGE_LOW: u32 = 2;
pub const IPPROTO_MAXID: u32 = 52;
pub const IPCTL_FORWARDING: u32 = 1;
pub const IPCTL_SENDREDIRECTS: u32 = 2;
pub const IPCTL_DEFTTL: u32 = 3;
pub const IPCTL_RTEXPIRE: u32 = 5;
pub const IPCTL_RTMINEXPIRE: u32 = 6;
pub const IPCTL_RTMAXCACHE: u32 = 7;
pub const IPCTL_SOURCEROUTE: u32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: u32 = 9;
pub const IPCTL_INTRQMAXLEN: u32 = 10;
pub const IPCTL_INTRQDROPS: u32 = 11;
pub const IPCTL_STATS: u32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: u32 = 13;
pub const IPCTL_FASTFORWARDING: u32 = 14;
pub const IPCTL_KEEPFAITH: u32 = 15;
pub const IPCTL_GIF_TTL: u32 = 16;
pub const IPCTL_MAXID: u32 = 17;
pub const __KAME_VERSION: &'static [u8; 18usize] = b"2009/apple-darwin\0";
pub const IPV6PORT_RESERVED: u32 = 1024;
pub const IPV6PORT_ANONMIN: u32 = 49152;
pub const IPV6PORT_ANONMAX: u32 = 65535;
pub const IPV6PORT_RESERVEDMIN: u32 = 600;
pub const IPV6PORT_RESERVEDMAX: u32 = 1023;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const __IPV6_ADDR_SCOPE_NODELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_INTFACELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_LINKLOCAL: u32 = 2;
pub const __IPV6_ADDR_SCOPE_SITELOCAL: u32 = 5;
pub const __IPV6_ADDR_SCOPE_ORGLOCAL: u32 = 8;
pub const __IPV6_ADDR_SCOPE_GLOBAL: u32 = 14;
pub const IPV6_SOCKOPT_RESERVED1: u32 = 3;
pub const IPV6_UNICAST_HOPS: u32 = 4;
pub const IPV6_MULTICAST_IF: u32 = 9;
pub const IPV6_MULTICAST_HOPS: u32 = 10;
pub const IPV6_MULTICAST_LOOP: u32 = 11;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_PORTRANGE: u32 = 14;
pub const ICMP6_FILTER: u32 = 18;
pub const IPV6_2292PKTINFO: u32 = 19;
pub const IPV6_2292HOPLIMIT: u32 = 20;
pub const IPV6_2292NEXTHOP: u32 = 21;
pub const IPV6_2292HOPOPTS: u32 = 22;
pub const IPV6_2292DSTOPTS: u32 = 23;
pub const IPV6_2292RTHDR: u32 = 24;
pub const IPV6_2292PKTOPTIONS: u32 = 25;
pub const IPV6_CHECKSUM: u32 = 26;
pub const IPV6_V6ONLY: u32 = 27;
pub const IPV6_BINDV6ONLY: u32 = 27;
pub const IPV6_IPSEC_POLICY: u32 = 28;
pub const IPV6_FAITH: u32 = 29;
pub const IPV6_FW_ADD: u32 = 30;
pub const IPV6_FW_DEL: u32 = 31;
pub const IPV6_FW_FLUSH: u32 = 32;
pub const IPV6_FW_ZERO: u32 = 33;
pub const IPV6_FW_GET: u32 = 34;
pub const IPV6_RECVTCLASS: u32 = 35;
pub const IPV6_TCLASS: u32 = 36;
pub const IPV6_BOUND_IF: u32 = 125;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: u32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IPV6_MIN_MEMBERSHIPS: u32 = 31;
pub const IPV6_MAX_MEMBERSHIPS: u32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: u32 = 0;
pub const IPV6_PORTRANGE_HIGH: u32 = 1;
pub const IPV6_PORTRANGE_LOW: u32 = 2;
pub const IPV6PROTO_MAXID: u32 = 104;
pub const IPV6CTL_FORWARDING: u32 = 1;
pub const IPV6CTL_SENDREDIRECTS: u32 = 2;
pub const IPV6CTL_DEFHLIM: u32 = 3;
pub const IPV6CTL_FORWSRCRT: u32 = 5;
pub const IPV6CTL_STATS: u32 = 6;
pub const IPV6CTL_MRTSTATS: u32 = 7;
pub const IPV6CTL_MRTPROTO: u32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: u32 = 9;
pub const IPV6CTL_SOURCECHECK: u32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: u32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: u32 = 12;
pub const IPV6CTL_KEEPFAITH: u32 = 13;
pub const IPV6CTL_LOG_INTERVAL: u32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: u32 = 15;
pub const IPV6CTL_DAD_COUNT: u32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: u32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: u32 = 18;
pub const IPV6CTL_GIF_HLIM: u32 = 19;
pub const IPV6CTL_KAME_VERSION: u32 = 20;
pub const IPV6CTL_USE_DEPRECATED: u32 = 21;
pub const IPV6CTL_RR_PRUNE: u32 = 22;
pub const IPV6CTL_V6ONLY: u32 = 24;
pub const IPV6CTL_RTEXPIRE: u32 = 25;
pub const IPV6CTL_RTMINEXPIRE: u32 = 26;
pub const IPV6CTL_RTMAXCACHE: u32 = 27;
pub const IPV6CTL_USETEMPADDR: u32 = 32;
pub const IPV6CTL_TEMPPLTIME: u32 = 33;
pub const IPV6CTL_TEMPVLTIME: u32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: u32 = 35;
pub const IPV6CTL_RIP6STATS: u32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: u32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: u32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: u32 = 39;
pub const IPV6CTL_MAXFRAGS: u32 = 41;
pub const IPV6CTL_MCAST_PMTU: u32 = 44;
pub const IPV6CTL_NEIGHBORGCTHRESH: u32 = 46;
pub const IPV6CTL_MAXIFPREFIXES: u32 = 47;
pub const IPV6CTL_MAXIFDEFROUTERS: u32 = 48;
pub const IPV6CTL_MAXDYNROUTES: u32 = 49;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: u32 = 50;
pub const IPV6CTL_MAXID: u32 = 51;
pub const _PATH_HEQUIV: &'static [u8; 17usize] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &'static [u8; 11usize] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &'static [u8; 14usize] = b"/etc/networks\0";
pub const _PATH_PROTOCOLS: &'static [u8; 15usize] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &'static [u8; 14usize] = b"/etc/services\0";
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NO_ADDRESS: u32 = 4;
pub const EAI_ADDRFAMILY: u32 = 1;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const EAI_FAIL: u32 = 4;
pub const EAI_FAMILY: u32 = 5;
pub const EAI_MEMORY: u32 = 6;
pub const EAI_NODATA: u32 = 7;
pub const EAI_NONAME: u32 = 8;
pub const EAI_SERVICE: u32 = 9;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_SYSTEM: u32 = 11;
pub const EAI_BADHINTS: u32 = 12;
pub const EAI_PROTOCOL: u32 = 13;
pub const EAI_OVERFLOW: u32 = 14;
pub const EAI_MAX: u32 = 15;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_NUMERICSERV: u32 = 4096;
pub const AI_ALL: u32 = 256;
pub const AI_V4MAPPED_CFG: u32 = 512;
pub const AI_ADDRCONFIG: u32 = 1024;
pub const AI_V4MAPPED: u32 = 2048;
pub const AI_DEFAULT: u32 = 1536;
pub const AI_UNUSABLE: u32 = 268435456;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NOFQDN: u32 = 1;
pub const NI_NUMERICHOST: u32 = 2;
pub const NI_NAMEREQD: u32 = 4;
pub const NI_NUMERICSERV: u32 = 8;
pub const NI_NUMERICSCOPE: u32 = 256;
pub const NI_DGRAM: u32 = 16;
pub const NI_WITHSCOPEID: u32 = 32;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const _PATH_PWD: &'static [u8; 5usize] = b"/etc\0";
pub const _PATH_PASSWD: &'static [u8; 12usize] = b"/etc/passwd\0";
pub const _PASSWD: &'static [u8; 7usize] = b"passwd\0";
pub const _PATH_MASTERPASSWD: &'static [u8; 19usize] = b"/etc/master.passwd\0";
pub const _PATH_MASTERPASSWD_LOCK: &'static [u8; 10usize] = b"/etc/ptmp\0";
pub const _MASTERPASSWD: &'static [u8; 14usize] = b"master.passwd\0";
pub const _PATH_MP_DB: &'static [u8; 12usize] = b"/etc/pwd.db\0";
pub const _MP_DB: &'static [u8; 7usize] = b"pwd.db\0";
pub const _PATH_SMP_DB: &'static [u8; 13usize] = b"/etc/spwd.db\0";
pub const _SMP_DB: &'static [u8; 8usize] = b"spwd.db\0";
pub const _PATH_PWD_MKDB: &'static [u8; 19usize] = b"/usr/sbin/pwd_mkdb\0";
pub const _PW_KEYBYNAME: u8 = 49u8;
pub const _PW_KEYBYNUM: u8 = 50u8;
pub const _PW_KEYBYUID: u8 = 51u8;
pub const _PASSWORD_EFMT1: u8 = 95u8;
pub const _PASSWORD_LEN: u32 = 128;
pub const _PASSWORD_NOUID: u32 = 1;
pub const _PASSWORD_NOGID: u32 = 2;
pub const _PASSWORD_NOCHG: u32 = 4;
pub const _PASSWORD_NOEXP: u32 = 8;
pub const _PASSWORD_WARNDAYS: u32 = 14;
pub const _PASSWORD_CHGNOW: i32 = -1;
pub const PGINVALID_SOCKET: i32 = -1;
pub const PG_BACKEND_VERSIONSTR: &'static [u8; 28usize] = b"postgres (PostgreSQL) 11.1\n\0";
pub const EXE: &'static [u8; 1usize] = b"\0";
pub const DEVNULL: &'static [u8; 10usize] = b"/dev/null\0";
pub const PG_IOLBF: u32 = 1;
pub const FP_NAN: u32 = 1;
pub const FP_INFINITE: u32 = 2;
pub const FP_ZERO: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const FP_SUBNORMAL: u32 = 5;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: u32 = 1;
pub const FP_QNAN: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const _JBLEN: u32 = 37;
pub const DEBUG5: u32 = 10;
pub const DEBUG4: u32 = 11;
pub const DEBUG3: u32 = 12;
pub const DEBUG2: u32 = 13;
pub const DEBUG1: u32 = 14;
pub const LOG: u32 = 15;
pub const LOG_SERVER_ONLY: u32 = 16;
pub const COMMERROR: u32 = 16;
pub const INFO: u32 = 17;
pub const NOTICE: u32 = 18;
pub const WARNING: u32 = 19;
pub const ERROR: u32 = 20;
pub const FATAL: u32 = 21;
pub const PANIC: u32 = 22;
pub const LOG_DESTINATION_STDERR: u32 = 1;
pub const LOG_DESTINATION_SYSLOG: u32 = 2;
pub const LOG_DESTINATION_EVENTLOG: u32 = 4;
pub const LOG_DESTINATION_CSVLOG: u32 = 8;
pub const MCXT_ALLOC_HUGE: u32 = 1;
pub const MCXT_ALLOC_NO_OOM: u32 = 2;
pub const MCXT_ALLOC_ZERO: u32 = 4;
pub const VARATT_SHORT_MAX: u32 = 127;
pub const SIZEOF_DATUM: u32 = 8;
pub const FIELDNO_FUNCTIONCALLINFODATA_ISNULL: u32 = 4;
pub const FIELDNO_FUNCTIONCALLINFODATA_ARG: u32 = 6;
pub const FIELDNO_FUNCTIONCALLINFODATA_ARGNULL: u32 = 7;
pub const PG_MAGIC_FUNCTION_NAME_STRING: &'static [u8; 14usize] = b"Pg_magic_func\0";
pub const AGG_CONTEXT_AGGREGATE: u32 = 1;
pub const AGG_CONTEXT_WINDOW: u32 = 2;
pub const AGGSPLITOP_COMBINE: u32 = 1;
pub const AGGSPLITOP_SKIPFINAL: u32 = 2;
pub const AGGSPLITOP_SERIALIZE: u32 = 4;
pub const AGGSPLITOP_DESERIALIZE: u32 = 8;
pub const NoLock: u32 = 0;
pub const AccessShareLock: u32 = 1;
pub const RowShareLock: u32 = 2;
pub const RowExclusiveLock: u32 = 3;
pub const ShareUpdateExclusiveLock: u32 = 4;
pub const ShareLock: u32 = 5;
pub const ShareRowExclusiveLock: u32 = 6;
pub const ExclusiveLock: u32 = 7;
pub const AccessExclusiveLock: u32 = 8;
pub const LP_UNUSED: u32 = 0;
pub const LP_NORMAL: u32 = 1;
pub const LP_REDIRECT: u32 = 2;
pub const LP_DEAD: u32 = 3;
pub const OffsetNumberMask: u32 = 65535;
pub const SpecTokenOffsetNumber: u32 = 65534;
pub const MovedPartitionsOffsetNumber: u32 = 65533;
pub const FIELDNO_HEAPTUPLEDATA_DATA: u32 = 3;
pub const BITS_PER_BITMAPWORD: u32 = 32;
pub const InvalidAttrNumber: u32 = 0;
pub const MaxAttrNumber: u32 = 32767;
pub const INNER_VAR: u32 = 65000;
pub const OUTER_VAR: u32 = 65001;
pub const INDEX_VAR: u32 = 65002;
pub const PRS2_OLD_VARNO: u32 = 1;
pub const PRS2_NEW_VARNO: u32 = 2;
pub const ACL_INSERT: u32 = 1;
pub const ACL_SELECT: u32 = 2;
pub const ACL_UPDATE: u32 = 4;
pub const ACL_DELETE: u32 = 8;
pub const ACL_TRUNCATE: u32 = 16;
pub const ACL_REFERENCES: u32 = 32;
pub const ACL_TRIGGER: u32 = 64;
pub const ACL_EXECUTE: u32 = 128;
pub const ACL_USAGE: u32 = 256;
pub const ACL_CREATE: u32 = 512;
pub const ACL_CREATE_TEMP: u32 = 1024;
pub const ACL_CONNECT: u32 = 2048;
pub const N_ACL_RIGHTS: u32 = 12;
pub const ACL_NO_RIGHTS: u32 = 0;
pub const ACL_SELECT_FOR_UPDATE: u32 = 4;
pub const FRAMEOPTION_NONDEFAULT: u32 = 1;
pub const FRAMEOPTION_RANGE: u32 = 2;
pub const FRAMEOPTION_ROWS: u32 = 4;
pub const FRAMEOPTION_GROUPS: u32 = 8;
pub const FRAMEOPTION_BETWEEN: u32 = 16;
pub const FRAMEOPTION_START_UNBOUNDED_PRECEDING: u32 = 32;
pub const FRAMEOPTION_END_UNBOUNDED_PRECEDING: u32 = 64;
pub const FRAMEOPTION_START_UNBOUNDED_FOLLOWING: u32 = 128;
pub const FRAMEOPTION_END_UNBOUNDED_FOLLOWING: u32 = 256;
pub const FRAMEOPTION_START_CURRENT_ROW: u32 = 512;
pub const FRAMEOPTION_END_CURRENT_ROW: u32 = 1024;
pub const FRAMEOPTION_START_OFFSET_PRECEDING: u32 = 2048;
pub const FRAMEOPTION_END_OFFSET_PRECEDING: u32 = 4096;
pub const FRAMEOPTION_START_OFFSET_FOLLOWING: u32 = 8192;
pub const FRAMEOPTION_END_OFFSET_FOLLOWING: u32 = 16384;
pub const FRAMEOPTION_EXCLUDE_CURRENT_ROW: u32 = 32768;
pub const FRAMEOPTION_EXCLUDE_GROUP: u32 = 65536;
pub const FRAMEOPTION_EXCLUDE_TIES: u32 = 131072;
pub const FRAMEOPTION_START_OFFSET: u32 = 10240;
pub const FRAMEOPTION_END_OFFSET: u32 = 20480;
pub const FRAMEOPTION_EXCLUSION: u32 = 229376;
pub const FRAMEOPTION_DEFAULTS: u32 = 1058;
pub const PARTITION_STRATEGY_HASH: u8 = 104u8;
pub const PARTITION_STRATEGY_LIST: u8 = 108u8;
pub const PARTITION_STRATEGY_RANGE: u8 = 114u8;
pub const FKCONSTR_ACTION_NOACTION: u8 = 97u8;
pub const FKCONSTR_ACTION_RESTRICT: u8 = 114u8;
pub const FKCONSTR_ACTION_CASCADE: u8 = 99u8;
pub const FKCONSTR_ACTION_SETNULL: u8 = 110u8;
pub const FKCONSTR_ACTION_SETDEFAULT: u8 = 100u8;
pub const FKCONSTR_MATCH_FULL: u8 = 102u8;
pub const FKCONSTR_MATCH_PARTIAL: u8 = 112u8;
pub const FKCONSTR_MATCH_SIMPLE: u8 = 115u8;
pub const OPCLASS_ITEM_OPERATOR: u32 = 1;
pub const OPCLASS_ITEM_FUNCTION: u32 = 2;
pub const OPCLASS_ITEM_STORAGETYPE: u32 = 3;
pub const CURSOR_OPT_BINARY: u32 = 1;
pub const CURSOR_OPT_SCROLL: u32 = 2;
pub const CURSOR_OPT_NO_SCROLL: u32 = 4;
pub const CURSOR_OPT_INSENSITIVE: u32 = 8;
pub const CURSOR_OPT_HOLD: u32 = 16;
pub const CURSOR_OPT_FAST_PLAN: u32 = 32;
pub const CURSOR_OPT_GENERIC_PLAN: u32 = 64;
pub const CURSOR_OPT_CUSTOM_PLAN: u32 = 128;
pub const CURSOR_OPT_PARALLEL_OK: u32 = 256;
pub const REINDEXOPT_VERBOSE: u32 = 1;
pub const AttributeRelationId: u32 = 1249;
pub const AttributeRelation_Rowtype_Id: u32 = 75;
pub const Anum_pg_attribute_attrelid: u32 = 1;
pub const Anum_pg_attribute_attname: u32 = 2;
pub const Anum_pg_attribute_atttypid: u32 = 3;
pub const Anum_pg_attribute_attstattarget: u32 = 4;
pub const Anum_pg_attribute_attlen: u32 = 5;
pub const Anum_pg_attribute_attnum: u32 = 6;
pub const Anum_pg_attribute_attndims: u32 = 7;
pub const Anum_pg_attribute_attcacheoff: u32 = 8;
pub const Anum_pg_attribute_atttypmod: u32 = 9;
pub const Anum_pg_attribute_attbyval: u32 = 10;
pub const Anum_pg_attribute_attstorage: u32 = 11;
pub const Anum_pg_attribute_attalign: u32 = 12;
pub const Anum_pg_attribute_attnotnull: u32 = 13;
pub const Anum_pg_attribute_atthasdef: u32 = 14;
pub const Anum_pg_attribute_atthasmissing: u32 = 15;
pub const Anum_pg_attribute_attidentity: u32 = 16;
pub const Anum_pg_attribute_attisdropped: u32 = 17;
pub const Anum_pg_attribute_attislocal: u32 = 18;
pub const Anum_pg_attribute_attinhcount: u32 = 19;
pub const Anum_pg_attribute_attcollation: u32 = 20;
pub const Anum_pg_attribute_attacl: u32 = 21;
pub const Anum_pg_attribute_attoptions: u32 = 22;
pub const Anum_pg_attribute_attfdwoptions: u32 = 23;
pub const Anum_pg_attribute_attmissingval: u32 = 24;
pub const Natts_pg_attribute: u32 = 24;
pub const ATTRIBUTE_IDENTITY_ALWAYS: u8 = 97u8;
pub const ATTRIBUTE_IDENTITY_BY_DEFAULT: u8 = 100u8;
pub const RELCACHE_INIT_FILENAME: &'static [u8; 17usize] = b"pg_internal.init\0";
pub const EOH_HEADER_MAGIC: i32 = -1;
pub const EA_MAGIC: u32 = 689375833;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_ACCMODE: u32 = 3;
pub const FREAD: u32 = 1;
pub const FWRITE: u32 = 2;
pub const O_NONBLOCK: u32 = 4;
pub const O_APPEND: u32 = 8;
pub const O_SYNC: u32 = 128;
pub const O_SHLOCK: u32 = 16;
pub const O_EXLOCK: u32 = 32;
pub const O_ASYNC: u32 = 64;
pub const O_FSYNC: u32 = 128;
pub const O_NOFOLLOW: u32 = 256;
pub const O_CREAT: u32 = 512;
pub const O_TRUNC: u32 = 1024;
pub const O_EXCL: u32 = 2048;
pub const AT_FDCWD: i32 = -2;
pub const AT_EACCESS: u32 = 16;
pub const AT_SYMLINK_NOFOLLOW: u32 = 32;
pub const AT_SYMLINK_FOLLOW: u32 = 64;
pub const AT_REMOVEDIR: u32 = 128;
pub const O_EVTONLY: u32 = 32768;
pub const O_NOCTTY: u32 = 131072;
pub const O_DIRECTORY: u32 = 1048576;
pub const O_SYMLINK: u32 = 2097152;
pub const O_DSYNC: u32 = 4194304;
pub const O_CLOEXEC: u32 = 16777216;
pub const O_DP_GETRAWENCRYPTED: u32 = 1;
pub const O_DP_GETRAWUNENCRYPTED: u32 = 2;
pub const FAPPEND: u32 = 8;
pub const FASYNC: u32 = 64;
pub const FFSYNC: u32 = 128;
pub const FFDSYNC: u32 = 4194304;
pub const FNONBLOCK: u32 = 4;
pub const FNDELAY: u32 = 4;
pub const O_NDELAY: u32 = 4;
pub const CPF_OVERWRITE: u32 = 1;
pub const CPF_IGNORE_MODE: u32 = 2;
pub const CPF_MASK: u32 = 3;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETOWN: u32 = 5;
pub const F_SETOWN: u32 = 6;
pub const F_GETLK: u32 = 7;
pub const F_SETLK: u32 = 8;
pub const F_SETLKW: u32 = 9;
pub const F_SETLKWTIMEOUT: u32 = 10;
pub const F_FLUSH_DATA: u32 = 40;
pub const F_CHKCLEAN: u32 = 41;
pub const F_PREALLOCATE: u32 = 42;
pub const F_SETSIZE: u32 = 43;
pub const F_RDADVISE: u32 = 44;
pub const F_RDAHEAD: u32 = 45;
pub const F_NOCACHE: u32 = 48;
pub const F_LOG2PHYS: u32 = 49;
pub const F_GETPATH: u32 = 50;
pub const F_FULLFSYNC: u32 = 51;
pub const F_PATHPKG_CHECK: u32 = 52;
pub const F_FREEZE_FS: u32 = 53;
pub const F_THAW_FS: u32 = 54;
pub const F_GLOBAL_NOCACHE: u32 = 55;
pub const F_ADDSIGS: u32 = 59;
pub const F_ADDFILESIGS: u32 = 61;
pub const F_NODIRECT: u32 = 62;
pub const F_GETPROTECTIONCLASS: u32 = 63;
pub const F_SETPROTECTIONCLASS: u32 = 64;
pub const F_LOG2PHYS_EXT: u32 = 65;
pub const F_GETLKPID: u32 = 66;
pub const F_SETBACKINGSTORE: u32 = 70;
pub const F_GETPATH_MTMINFO: u32 = 71;
pub const F_GETCODEDIR: u32 = 72;
pub const F_SETNOSIGPIPE: u32 = 73;
pub const F_GETNOSIGPIPE: u32 = 74;
pub const F_TRANSCODEKEY: u32 = 75;
pub const F_SINGLE_WRITER: u32 = 76;
pub const F_GETPROTECTIONLEVEL: u32 = 77;
pub const F_FINDSIGS: u32 = 78;
pub const F_ADDFILESIGS_FOR_DYLD_SIM: u32 = 83;
pub const F_BARRIERFSYNC: u32 = 85;
pub const F_ADDFILESIGS_RETURN: u32 = 97;
pub const F_CHECK_LV: u32 = 98;
pub const F_PUNCHHOLE: u32 = 99;
pub const F_TRIM_ACTIVE_FILE: u32 = 100;
pub const FCNTL_FS_SPECIFIC_BASE: u32 = 65536;
pub const F_DUPFD_CLOEXEC: u32 = 67;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_WRLCK: u32 = 3;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const S_IFMT: u32 = 61440;
pub const S_IFIFO: u32 = 4096;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFWHT: u32 = 57344;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_ISTXT: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const F_ALLOCATECONTIG: u32 = 2;
pub const F_ALLOCATEALL: u32 = 4;
pub const F_PEOFPOSMODE: u32 = 3;
pub const F_VOLPOSMODE: u32 = 4;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const O_POPUP: u32 = 2147483648;
pub const O_ALERT: u32 = 536870912;
pub const InvalidXLogRecPtr: u32 = 0;
pub const PG_O_DIRECT: u32 = 0;
pub const OPEN_SYNC_FLAG: u32 = 128;
pub const OPEN_DATASYNC_FLAG: u32 = 4194304;
pub const MAX_TIMESTAMP_PRECISION: u32 = 6;
pub const MAX_INTERVAL_PRECISION: u32 = 6;
pub const TS_PREC_INV: f64 = 1000000.0;
pub const DAYS_PER_YEAR: f64 = 365.25;
pub const MONTHS_PER_YEAR: u32 = 12;
pub const DAYS_PER_MONTH: u32 = 30;
pub const HOURS_PER_DAY: u32 = 24;
pub const SECS_PER_YEAR: u32 = 31557600;
pub const SECS_PER_DAY: u32 = 86400;
pub const SECS_PER_HOUR: u32 = 3600;
pub const SECS_PER_MINUTE: u32 = 60;
pub const MINS_PER_HOUR: u32 = 60;
pub const MAX_TZDISP_HOUR: u32 = 15;
pub const TZDISP_LIMIT: u32 = 57600;
pub const JULIAN_MINYEAR: i32 = -4713;
pub const JULIAN_MINMONTH: u32 = 11;
pub const JULIAN_MINDAY: u32 = 24;
pub const JULIAN_MAXYEAR: u32 = 5874898;
pub const JULIAN_MAXMONTH: u32 = 6;
pub const JULIAN_MAXDAY: u32 = 3;
pub const UNIX_EPOCH_JDATE: u32 = 2440588;
pub const POSTGRES_EPOCH_JDATE: u32 = 2451545;
pub const DATETIME_MIN_JULIAN: u32 = 0;
pub const DATE_END_JULIAN: u32 = 2147483494;
pub const TIMESTAMP_END_JULIAN: u32 = 109203528;
pub const InvalidBuffer: u32 = 0;
pub const ACL_ID_PUBLIC: u32 = 0;
pub const ACL_MODECHG_ADD: u32 = 1;
pub const ACL_MODECHG_DEL: u32 = 2;
pub const ACL_MODECHG_EQL: u32 = 3;
pub const ACL_INSERT_CHR: u8 = 97u8;
pub const ACL_SELECT_CHR: u8 = 114u8;
pub const ACL_UPDATE_CHR: u8 = 119u8;
pub const ACL_DELETE_CHR: u8 = 100u8;
pub const ACL_TRUNCATE_CHR: u8 = 68u8;
pub const ACL_REFERENCES_CHR: u8 = 120u8;
pub const ACL_TRIGGER_CHR: u8 = 116u8;
pub const ACL_EXECUTE_CHR: u8 = 88u8;
pub const ACL_USAGE_CHR: u8 = 85u8;
pub const ACL_CREATE_CHR: u8 = 67u8;
pub const ACL_CREATE_TEMP_CHR: u8 = 84u8;
pub const ACL_CONNECT_CHR: u8 = 99u8;
pub const ACL_ALL_RIGHTS_STR: &'static [u8; 13usize] = b"arwdDxtXUCTc\0";
pub const ACL_ALL_RIGHTS_COLUMN: u32 = 39;
pub const ACL_ALL_RIGHTS_RELATION: u32 = 127;
pub const ACL_ALL_RIGHTS_SEQUENCE: u32 = 262;
pub const ACL_ALL_RIGHTS_DATABASE: u32 = 3584;
pub const ACL_ALL_RIGHTS_FDW: u32 = 256;
pub const ACL_ALL_RIGHTS_FOREIGN_SERVER: u32 = 256;
pub const ACL_ALL_RIGHTS_FUNCTION: u32 = 128;
pub const ACL_ALL_RIGHTS_LANGUAGE: u32 = 256;
pub const ACL_ALL_RIGHTS_LARGEOBJECT: u32 = 6;
pub const ACL_ALL_RIGHTS_SCHEMA: u32 = 768;
pub const ACL_ALL_RIGHTS_TABLESPACE: u32 = 512;
pub const ACL_ALL_RIGHTS_TYPE: u32 = 256;
pub const BTLessStrategyNumber: u32 = 1;
pub const BTLessEqualStrategyNumber: u32 = 2;
pub const BTEqualStrategyNumber: u32 = 3;
pub const BTGreaterEqualStrategyNumber: u32 = 4;
pub const BTGreaterStrategyNumber: u32 = 5;
pub const BTMaxStrategyNumber: u32 = 5;
pub const RTLeftStrategyNumber: u32 = 1;
pub const RTOverLeftStrategyNumber: u32 = 2;
pub const RTOverlapStrategyNumber: u32 = 3;
pub const RTOverRightStrategyNumber: u32 = 4;
pub const RTRightStrategyNumber: u32 = 5;
pub const RTSameStrategyNumber: u32 = 6;
pub const RTContainsStrategyNumber: u32 = 7;
pub const RTContainedByStrategyNumber: u32 = 8;
pub const RTOverBelowStrategyNumber: u32 = 9;
pub const RTBelowStrategyNumber: u32 = 10;
pub const RTAboveStrategyNumber: u32 = 11;
pub const RTOverAboveStrategyNumber: u32 = 12;
pub const RTOldContainsStrategyNumber: u32 = 13;
pub const RTOldContainedByStrategyNumber: u32 = 14;
pub const RTKNNSearchStrategyNumber: u32 = 15;
pub const RTContainsElemStrategyNumber: u32 = 16;
pub const RTAdjacentStrategyNumber: u32 = 17;
pub const RTEqualStrategyNumber: u32 = 18;
pub const RTNotEqualStrategyNumber: u32 = 19;
pub const RTLessStrategyNumber: u32 = 20;
pub const RTLessEqualStrategyNumber: u32 = 21;
pub const RTGreaterStrategyNumber: u32 = 22;
pub const RTGreaterEqualStrategyNumber: u32 = 23;
pub const RTSubStrategyNumber: u32 = 24;
pub const RTSubEqualStrategyNumber: u32 = 25;
pub const RTSuperStrategyNumber: u32 = 26;
pub const RTSuperEqualStrategyNumber: u32 = 27;
pub const RTPrefixStrategyNumber: u32 = 28;
pub const RTMaxStrategyNumber: u32 = 28;
pub const SK_ISNULL: u32 = 1;
pub const SK_UNARY: u32 = 2;
pub const SK_ROW_HEADER: u32 = 4;
pub const SK_ROW_MEMBER: u32 = 8;
pub const SK_ROW_END: u32 = 16;
pub const SK_SEARCHARRAY: u32 = 32;
pub const SK_SEARCHNULL: u32 = 64;
pub const SK_SEARCHNOTNULL: u32 = 128;
pub const SK_ORDER_BY: u32 = 256;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 262144;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 8192;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const DSM_IMPL_NONE: u32 = 0;
pub const DSM_IMPL_POSIX: u32 = 1;
pub const DSM_IMPL_SYSV: u32 = 2;
pub const DSM_IMPL_WINDOWS: u32 = 3;
pub const DSM_IMPL_MMAP: u32 = 4;
pub const DEFAULT_DYNAMIC_SHARED_MEMORY_TYPE: u32 = 1;
pub const PG_DYNSHMEM_DIR: &'static [u8; 12usize] = b"pg_dynshmem\0";
pub const PG_DYNSHMEM_MMAP_FILE_PREFIX: &'static [u8; 6usize] = b"mmap.\0";
pub const DSM_CREATE_NULL_IF_MAXSEGMENTS: u32 = 1;
pub const DSM_HANDLE_INVALID: u32 = 0;
pub const SIZEOF_DSA_POINTER: u32 = 8;
pub const DSA_POINTER_FORMAT: &'static [u8; 7usize] = b"%016lx\0";
pub const DSA_ALLOC_HUGE: u32 = 1;
pub const DSA_ALLOC_NO_OOM: u32 = 2;
pub const DSA_ALLOC_ZERO: u32 = 4;
pub const PD_HAS_FREE_LINES: u32 = 1;
pub const PD_PAGE_FULL: u32 = 2;
pub const PD_ALL_VISIBLE: u32 = 4;
pub const PD_VALID_FLAG_BITS: u32 = 7;
pub const PG_PAGE_LAYOUT_VERSION: u32 = 4;
pub const PG_DATA_CHECKSUM_VERSION: u32 = 1;
pub const PAI_OVERWRITE: u32 = 1;
pub const PAI_IS_HEAP: u32 = 2;
pub const HEAP_INSERT_SKIP_WAL: u32 = 1;
pub const HEAP_INSERT_SKIP_FSM: u32 = 2;
pub const HEAP_INSERT_FROZEN: u32 = 4;
pub const HEAP_INSERT_SPECULATIVE: u32 = 8;
pub const HEAP_INSERT_NO_LOGICAL: u32 = 16;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const PARAM_FLAG_CONST: u32 = 1;
pub const HASH_PARTITION: u32 = 1;
pub const HASH_SEGMENT: u32 = 2;
pub const HASH_DIRSIZE: u32 = 4;
pub const HASH_FFACTOR: u32 = 8;
pub const HASH_ELEM: u32 = 16;
pub const HASH_BLOBS: u32 = 32;
pub const HASH_FUNCTION: u32 = 64;
pub const HASH_COMPARE: u32 = 128;
pub const HASH_KEYCOPY: u32 = 256;
pub const HASH_ALLOC: u32 = 512;
pub const HASH_CONTEXT: u32 = 1024;
pub const HASH_SHARED_MEM: u32 = 2048;
pub const HASH_ATTACH: u32 = 4096;
pub const HASH_FIXED_SIZE: u32 = 8192;
pub const NO_MAX_DSIZE: i32 = -1;
pub const __DARWIN_MAXNAMLEN: u32 = 255;
pub const __DARWIN_MAXPATHLEN: u32 = 1024;
pub const MAXNAMLEN: u32 = 255;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_FIFO: u32 = 1;
pub const DT_CHR: u32 = 2;
pub const DT_DIR: u32 = 4;
pub const DT_BLK: u32 = 6;
pub const DT_REG: u32 = 8;
pub const DT_LNK: u32 = 10;
pub const DT_SOCK: u32 = 12;
pub const DT_WHT: u32 = 14;
pub const DIRBLKSIZ: u32 = 1024;
pub const DTF_HIDEW: u32 = 1;
pub const DTF_NODUP: u32 = 2;
pub const DTF_REWIND: u32 = 4;
pub const __DTF_READALL: u32 = 8;
pub const __DTF_SKIPREAD: u32 = 16;
pub const PG_TEMP_FILES_DIR: &'static [u8; 10usize] = b"pgsql_tmp\0";
pub const PG_TEMP_FILE_PREFIX: &'static [u8; 10usize] = b"pgsql_tmp\0";
pub const DEFAULT_SPINS_PER_DELAY: u32 = 100;
pub const SHARED_TUPLESTORE_SINGLE_PASS: u32 = 1;
pub const FIELDNO_TUPLETABLESLOT_SLOW: u32 = 4;
pub const FIELDNO_TUPLETABLESLOT_TUPLE: u32 = 5;
pub const FIELDNO_TUPLETABLESLOT_TUPLEDESCRIPTOR: u32 = 6;
pub const FIELDNO_TUPLETABLESLOT_NVALID: u32 = 9;
pub const FIELDNO_TUPLETABLESLOT_VALUES: u32 = 10;
pub const FIELDNO_TUPLETABLESLOT_ISNULL: u32 = 11;
pub const FIELDNO_TUPLETABLESLOT_OFF: u32 = 14;
pub const INDEX_SIZE_MASK: u32 = 8191;
pub const INDEX_AM_RESERVED_BIT: u32 = 8192;
pub const INDEX_VAR_MASK: u32 = 16384;
pub const INDEX_NULL_MASK: u32 = 32768;
pub const EEO_FLAG_IS_QUAL: u32 = 1;
pub const FIELDNO_EXPRSTATE_RESNULL: u32 = 2;
pub const FIELDNO_EXPRSTATE_RESVALUE: u32 = 3;
pub const FIELDNO_EXPRSTATE_RESULTSLOT: u32 = 4;
pub const FIELDNO_EXPRCONTEXT_SCANTUPLE: u32 = 1;
pub const FIELDNO_EXPRCONTEXT_INNERTUPLE: u32 = 2;
pub const FIELDNO_EXPRCONTEXT_OUTERTUPLE: u32 = 3;
pub const FIELDNO_EXPRCONTEXT_AGGVALUES: u32 = 8;
pub const FIELDNO_EXPRCONTEXT_AGGNULLS: u32 = 9;
pub const FIELDNO_EXPRCONTEXT_CASEDATUM: u32 = 10;
pub const FIELDNO_EXPRCONTEXT_CASENULL: u32 = 11;
pub const FIELDNO_EXPRCONTEXT_DOMAINDATUM: u32 = 12;
pub const FIELDNO_EXPRCONTEXT_DOMAINNULL: u32 = 13;
pub const FIELDNO_AGGSTATE_CURAGGCONTEXT: u32 = 14;
pub const FIELDNO_AGGSTATE_CURPERTRANS: u32 = 16;
pub const FIELDNO_AGGSTATE_CURRENT_SET: u32 = 20;
pub const FIELDNO_AGGSTATE_ALL_PERGROUPS: u32 = 34;
pub const TRIGGER_EVENT_INSERT: u32 = 0;
pub const TRIGGER_EVENT_DELETE: u32 = 1;
pub const TRIGGER_EVENT_UPDATE: u32 = 2;
pub const TRIGGER_EVENT_TRUNCATE: u32 = 3;
pub const TRIGGER_EVENT_OPMASK: u32 = 3;
pub const TRIGGER_EVENT_ROW: u32 = 4;
pub const TRIGGER_EVENT_BEFORE: u32 = 8;
pub const TRIGGER_EVENT_AFTER: u32 = 0;
pub const TRIGGER_EVENT_INSTEAD: u32 = 16;
pub const TRIGGER_EVENT_TIMINGMASK: u32 = 24;
pub const AFTER_TRIGGER_DEFERRABLE: u32 = 32;
pub const AFTER_TRIGGER_INITDEFERRED: u32 = 64;
pub const SESSION_REPLICATION_ROLE_ORIGIN: u32 = 0;
pub const SESSION_REPLICATION_ROLE_REPLICA: u32 = 1;
pub const SESSION_REPLICATION_ROLE_LOCAL: u32 = 2;
pub const TRIGGER_FIRES_ON_ORIGIN: u8 = 79u8;
pub const TRIGGER_FIRES_ALWAYS: u8 = 65u8;
pub const TRIGGER_FIRES_ON_REPLICA: u8 = 82u8;
pub const TRIGGER_DISABLED: u8 = 68u8;
pub const RI_TRIGGER_PK: u32 = 1;
pub const RI_TRIGGER_FK: u32 = 2;
pub const RI_TRIGGER_NONE: u32 = 0;
pub const COMPLETION_TAG_BUFSIZE: u32 = 64;
pub const CACHEDPLANSOURCE_MAGIC: u32 = 195726186;
pub const CACHEDPLAN_MAGIC: u32 = 953717834;
pub const SPI_ERROR_CONNECT: i32 = -1;
pub const SPI_ERROR_COPY: i32 = -2;
pub const SPI_ERROR_OPUNKNOWN: i32 = -3;
pub const SPI_ERROR_UNCONNECTED: i32 = -4;
pub const SPI_ERROR_CURSOR: i32 = -5;
pub const SPI_ERROR_ARGUMENT: i32 = -6;
pub const SPI_ERROR_PARAM: i32 = -7;
pub const SPI_ERROR_TRANSACTION: i32 = -8;
pub const SPI_ERROR_NOATTRIBUTE: i32 = -9;
pub const SPI_ERROR_NOOUTFUNC: i32 = -10;
pub const SPI_ERROR_TYPUNKNOWN: i32 = -11;
pub const SPI_ERROR_REL_DUPLICATE: i32 = -12;
pub const SPI_ERROR_REL_NOT_FOUND: i32 = -13;
pub const SPI_OK_CONNECT: u32 = 1;
pub const SPI_OK_FINISH: u32 = 2;
pub const SPI_OK_FETCH: u32 = 3;
pub const SPI_OK_UTILITY: u32 = 4;
pub const SPI_OK_SELECT: u32 = 5;
pub const SPI_OK_SELINTO: u32 = 6;
pub const SPI_OK_INSERT: u32 = 7;
pub const SPI_OK_DELETE: u32 = 8;
pub const SPI_OK_UPDATE: u32 = 9;
pub const SPI_OK_CURSOR: u32 = 10;
pub const SPI_OK_INSERT_RETURNING: u32 = 11;
pub const SPI_OK_DELETE_RETURNING: u32 = 12;
pub const SPI_OK_UPDATE_RETURNING: u32 = 13;
pub const SPI_OK_REWRITTEN: u32 = 14;
pub const SPI_OK_REL_REGISTER: u32 = 15;
pub const SPI_OK_REL_UNREGISTER: u32 = 16;
pub const SPI_OK_TD_REGISTER: u32 = 17;
pub const SPI_OPT_NONATOMIC: u32 = 1;
pub const FORMAT_TYPE_TYPEMOD_GIVEN: u32 = 1;
pub const FORMAT_TYPE_ALLOW_INVALID: u32 = 2;
pub const FORMAT_TYPE_FORCE_QUALIFY: u32 = 4;
pub type Oid = ::std::os::raw::c_uint;
pub type pg_int64 = ::std::os::raw::c_long;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type va_list = __darwin_va_list;
extern "C" {
    #[link_name = "\u{1}_renameat"]
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_renamex_np"]
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_renameatx_np"]
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "\u{1}___stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}___stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}___stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_clearerr"]
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_fclose"]
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_feof"]
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ferror"]
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fflush"]
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fgetc"]
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fgetpos"]
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fgets"]
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fopen"]
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_fprintf"]
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fputc"]
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fputs"]
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fread"]
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_freopen"]
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_fscanf"]
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fseek"]
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fsetpos"]
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ftell"]
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_fwrite"]
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_getc"]
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getchar"]
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_gets"]
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_perror"]
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_printf"]
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putc"]
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putchar"]
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_puts"]
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_remove"]
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rename"]
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rewind"]
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_scanf"]
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setbuf"]
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_setvbuf"]
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sprintf"]
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sscanf"]
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_tmpfile"]
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_tmpnam"]
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ungetc"]
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vfprintf"]
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vprintf"]
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vsprintf"]
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ctermid"]
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fdopen"]
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_fileno"]
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pclose"]
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_popen"]
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}___srget"]
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___svfscanf"]
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___swbuf"]
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_flockfile"]
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_ftrylockfile"]
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_funlockfile"]
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}_getc_unlocked"]
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getchar_unlocked"]
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putc_unlocked"]
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putchar_unlocked"]
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getw"]
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putw"]
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_tempnam"]
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    #[link_name = "\u{1}_fseeko"]
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ftello"]
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    #[link_name = "\u{1}_snprintf"]
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vfscanf"]
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vscanf"]
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vsnprintf"]
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vsscanf"]
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_dprintf"]
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vdprintf"]
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getdelim"]
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_getline"]
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_fmemopen"]
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_open_memstream"]
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_sys_nerr"]
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_asprintf"]
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ctermid_r"]
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fgetln"]
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fmtcheck"]
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_fpurge"]
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setbuffer"]
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_setlinebuf"]
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vasprintf"]
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_zopen"]
    pub fn zopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_funopen"]
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}___sprintf_chk"]
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___snprintf_chk"]
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___vsprintf_chk"]
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___vsnprintf_chk"]
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_thread_state>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebx as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ecx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ecx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edx as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edi as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esi as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esp as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eflags as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eip as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__cs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ds as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__es as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__fs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__gs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_control {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_control>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_control))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_control>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_control))
    );
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __pc: ::std::os::raw::c_ushort,
        __rc: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let __pc: u16 = unsafe { ::std::mem::transmute(__pc) };
            __pc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let __rc: u16 = unsafe { ::std::mem::transmute(__rc) };
            __rc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_status {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_status>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_status))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_status>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_status))
    );
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __stkflt: ::std::os::raw::c_ushort,
        __errsumm: ::std::os::raw::c_ushort,
        __c0: ::std::os::raw::c_ushort,
        __c1: ::std::os::raw::c_ushort,
        __c2: ::std::os::raw::c_ushort,
        __tos: ::std::os::raw::c_ushort,
        __c3: ::std::os::raw::c_ushort,
        __busy: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let __stkflt: u16 = unsafe { ::std::mem::transmute(__stkflt) };
            __stkflt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __errsumm: u16 = unsafe { ::std::mem::transmute(__errsumm) };
            __errsumm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let __c0: u16 = unsafe { ::std::mem::transmute(__c0) };
            __c0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let __c1: u16 = unsafe { ::std::mem::transmute(__c1) };
            __c1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let __c2: u16 = unsafe { ::std::mem::transmute(__c2) };
            __c2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let __tos: u16 = unsafe { ::std::mem::transmute(__tos) };
            __tos as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let __c3: u16 = unsafe { ::std::mem::transmute(__c3) };
            __c3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let __busy: u16 = unsafe { ::std::mem::transmute(__busy) };
            __busy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mmst_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mmst_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_rsrv as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_rsrv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_xmm_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_xmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_xmm_reg>())).__xmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_xmm_reg),
            "::",
            stringify!(__xmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ymm_reg {
    pub __ymm_reg: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout___darwin_ymm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ymm_reg>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ymm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ymm_reg>())).__ymm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ymm_reg),
            "::",
            stringify!(__ymm_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_zmm_reg {
    pub __zmm_reg: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout___darwin_zmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_zmm_reg>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_zmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_zmm_reg>())).__zmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_zmm_reg),
            "::",
            stringify!(__zmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_opmask_reg {
    pub __opmask_reg: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___darwin_opmask_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_opmask_reg>(),
        8usize,
        concat!("Size of: ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_opmask_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_opmask_reg>())).__opmask_reg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_opmask_reg),
            "::",
            stringify!(__opmask_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_float_state>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_float_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx_state>(),
        716usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsrmask as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved1 as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__avx_reserved1 as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx512_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx512_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx512_state>(),
        1036usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx512_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k0 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k1 as *const _ as usize
        },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k2 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k3 as *const _ as usize
        },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k4 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k5 as *const _ as usize
        },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k6 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k7 as *const _ as usize
        },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh0 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh1 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh2 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh3 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh4 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh5 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh6 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh7 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state32>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr3 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr4 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr5 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr6 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr7 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_state64>(),
        168usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rcx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdi as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsi as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbp as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r8 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r9 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r10 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r11 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r12 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r13 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r14 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r15 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rip as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rflags as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__cs as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__fs as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__gs as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_float_state64>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_float_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx_state64>(),
        844usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh10 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh11 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh12 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh13 as *const _ as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh14 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh15 as *const _ as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx512_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
    pub __fpu_zmmh8: __darwin_ymm_reg,
    pub __fpu_zmmh9: __darwin_ymm_reg,
    pub __fpu_zmmh10: __darwin_ymm_reg,
    pub __fpu_zmmh11: __darwin_ymm_reg,
    pub __fpu_zmmh12: __darwin_ymm_reg,
    pub __fpu_zmmh13: __darwin_ymm_reg,
    pub __fpu_zmmh14: __darwin_ymm_reg,
    pub __fpu_zmmh15: __darwin_ymm_reg,
    pub __fpu_zmm16: __darwin_zmm_reg,
    pub __fpu_zmm17: __darwin_zmm_reg,
    pub __fpu_zmm18: __darwin_zmm_reg,
    pub __fpu_zmm19: __darwin_zmm_reg,
    pub __fpu_zmm20: __darwin_zmm_reg,
    pub __fpu_zmm21: __darwin_zmm_reg,
    pub __fpu_zmm22: __darwin_zmm_reg,
    pub __fpu_zmm23: __darwin_zmm_reg,
    pub __fpu_zmm24: __darwin_zmm_reg,
    pub __fpu_zmm25: __darwin_zmm_reg,
    pub __fpu_zmm26: __darwin_zmm_reg,
    pub __fpu_zmm27: __darwin_zmm_reg,
    pub __fpu_zmm28: __darwin_zmm_reg,
    pub __fpu_zmm29: __darwin_zmm_reg,
    pub __fpu_zmm30: __darwin_zmm_reg,
    pub __fpu_zmm31: __darwin_zmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx512_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx512_state64>(),
        2444usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx512_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh10 as *const _
                as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh11 as *const _
                as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh12 as *const _
                as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh13 as *const _
                as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh14 as *const _
                as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh15 as *const _
                as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k0 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k1 as *const _ as usize
        },
        852usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k2 as *const _ as usize
        },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k3 as *const _ as usize
        },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k4 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k5 as *const _ as usize
        },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k6 as *const _ as usize
        },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k7 as *const _ as usize
        },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh0 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh1 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh2 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh3 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh4 as *const _ as usize
        },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh5 as *const _ as usize
        },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh6 as *const _ as usize
        },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh7 as *const _ as usize
        },
        1132usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh8 as *const _ as usize
        },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh9 as *const _ as usize
        },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh10 as *const _
                as usize
        },
        1228usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh11 as *const _
                as usize
        },
        1260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh12 as *const _
                as usize
        },
        1292usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh13 as *const _
                as usize
        },
        1324usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh14 as *const _
                as usize
        },
        1356usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh15 as *const _
                as usize
        },
        1388usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm16 as *const _ as usize
        },
        1420usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm17 as *const _ as usize
        },
        1484usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm18 as *const _ as usize
        },
        1548usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm19 as *const _ as usize
        },
        1612usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm20 as *const _ as usize
        },
        1676usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm21 as *const _ as usize
        },
        1740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm22 as *const _ as usize
        },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm23 as *const _ as usize
        },
        1868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm24 as *const _ as usize
        },
        1932usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm25 as *const _ as usize
        },
        1996usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm26 as *const _ as usize
        },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm27 as *const _ as usize
        },
        2124usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm28 as *const _ as usize
        },
        2188usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm29 as *const _ as usize
        },
        2252usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm29)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm30 as *const _ as usize
        },
        2316usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm31 as *const _ as usize
        },
        2380usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm31)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state64>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr3 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr4 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr5 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr6 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr7 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_x86_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_cpmu_state64>())).__ctrs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        600usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx32>(),
        792usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx512_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_32>(),
        1112usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        712usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64>(),
        1032usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_64>(),
        2632usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__fs as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__fs)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_onstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_sigmask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_stack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcontext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_band as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).__pad as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_sigaction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_tramp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_signal"]
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_unused: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_logical_writes as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_lifetime_max_phys_footprint as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_instructions as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_cycles as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_energy as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_energy as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_unused as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_unused)
        )
    );
}
pub type rusage_info_current = rusage_info_v4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_rate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_getpriority"]
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getiopolicy_np"]
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getrlimit"]
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getrusage"]
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setpriority"]
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setiopolicy_np"]
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setrlimit"]
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_T as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_S as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    #[link_name = "\u{1}_wait"]
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_waitpid"]
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_waitid"]
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_wait3"]
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_wait4"]
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_alloca"]
    pub fn alloca(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}___mb_cur_max"]
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_abort"]
    pub fn abort();
}
extern "C" {
    #[link_name = "\u{1}_abs"]
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atexit"]
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atof"]
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atoi"]
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atol"]
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_atoll"]
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_bsearch"]
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_calloc"]
    pub fn calloc(__count: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_div"]
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    #[link_name = "\u{1}_exit"]
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_free"]
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_getenv"]
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_labs"]
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_ldiv"]
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    #[link_name = "\u{1}_llabs"]
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_lldiv"]
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    #[link_name = "\u{1}_malloc"]
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_mblen"]
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mbstowcs"]
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_mbtowc"]
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_posix_memalign"]
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_qsort"]
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_rand"]
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realloc"]
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_srand"]
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_strtod"]
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_strtof"]
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_strtol"]
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_strtold"]
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_strtoll"]
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_strtoul"]
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strtoull"]
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}_system"]
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_wcstombs"]
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_wctomb"]
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__Exit"]
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_a64l"]
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_drand48"]
    pub fn drand48() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ecvt"]
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_erand48"]
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fcvt"]
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_gcvt"]
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getsubopt"]
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_grantpt"]
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_initstate"]
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_jrand48"]
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_l64a"]
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_lcong48"]
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    #[link_name = "\u{1}_lrand48"]
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_mktemp"]
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_mkstemp"]
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mrand48"]
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_nrand48"]
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_posix_openpt"]
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ptsname"]
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ptsname_r"]
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_putenv"]
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_random"]
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_rand_r"]
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_seed48"]
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "\u{1}_setenv"]
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setkey"]
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_setstate"]
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_srand48"]
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_srandom"]
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_unlockpt"]
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_unsetenv"]
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    #[link_name = "\u{1}_arc4random"]
    pub fn arc4random() -> u32;
}
extern "C" {
    #[link_name = "\u{1}_arc4random_addrandom"]
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_arc4random_buf"]
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    #[link_name = "\u{1}_arc4random_stir"]
    pub fn arc4random_stir();
}
extern "C" {
    #[link_name = "\u{1}_arc4random_uniform"]
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_atexit_b"]
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bsearch_b"]
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_cgetcap"]
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_cgetclose"]
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetent"]
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetfirst"]
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetmatch"]
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetnext"]
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetnum"]
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetset"]
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetstr"]
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetustr"]
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_daemon$1050"]
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_devname"]
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_devname_r"]
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getbsize"]
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getloadavg"]
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getprogname"]
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_heapsort"]
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_heapsort_b"]
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mergesort"]
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mergesort_b"]
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_psort"]
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_psort_b"]
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_psort_r"]
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_qsort_b"]
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_qsort_r"]
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_radixsort"]
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setprogname"]
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_sradixsort"]
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sranddev"]
    pub fn sranddev();
}
extern "C" {
    #[link_name = "\u{1}_srandomdev"]
    pub fn srandomdev();
}
extern "C" {
    #[link_name = "\u{1}_reallocf"]
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_strtoq"]
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_strtouq"]
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}_suboptarg"]
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_valloc"]
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_memchr"]
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_memcmp"]
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_memcpy"]
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_memmove"]
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_memset"]
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_strcat"]
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strchr"]
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strcmp"]
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strcoll"]
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strcpy"]
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strcspn"]
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strerror"]
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strlen"]
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strncat"]
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strncmp"]
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strncpy"]
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strpbrk"]
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strrchr"]
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strspn"]
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strstr"]
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strtok"]
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strxfrm"]
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strtok_r"]
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strdup"]
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_memccpy"]
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_stpcpy"]
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_stpncpy"]
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strndup"]
    pub fn strndup(__s1: *const ::std::os::raw::c_char, __n: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strnlen"]
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_strsignal"]
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "\u{1}_memset_s"]
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    #[link_name = "\u{1}_memmem"]
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_memset_pattern4"]
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_memset_pattern8"]
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_memset_pattern16"]
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_strcasestr"]
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strnstr"]
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strlcat"]
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: usize,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strlcpy"]
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: usize,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strmode"]
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_strsep"]
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_swab"]
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    #[link_name = "\u{1}_timingsafe_bcmp"]
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bcmp"]
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bcopy"]
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_bzero"]
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    #[link_name = "\u{1}_index"]
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_rindex"]
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ffs"]
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strcasecmp"]
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strncasecmp"]
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ffsl"]
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ffsll"]
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fls"]
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_flsl"]
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_flsll"]
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
pub type max_align_t = f64;
pub type __gnuc_va_list = __builtin_va_list;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
extern "C" {
    #[link_name = "\u{1}___error"]
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    assert_eq!(
        ::std::mem::size_of::<lconv>(),
        96usize,
        concat!("Size of: ", stringify!(lconv))
    );
    assert_eq!(
        ::std::mem::align_of::<lconv>(),
        8usize,
        concat!("Alignment of ", stringify!(lconv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).decimal_point as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).thousands_sep as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).grouping as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(grouping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_curr_symbol as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).currency_symbol as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_decimal_point as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_thousands_sep as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).mon_grouping as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).positive_sign as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).negative_sign as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_frac_digits as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).frac_digits as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_cs_precedes as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_sep_by_space as *const _ as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_cs_precedes as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_sep_by_space as *const _ as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).p_sign_posn as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).n_sign_posn as *const _ as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_cs_precedes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_cs_precedes as *const _ as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_sep_by_space as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_sep_by_space as *const _ as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_p_sign_posn as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lconv>())).int_n_sign_posn as *const _ as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sign_posn)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_localeconv"]
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    #[link_name = "\u{1}_setlocale"]
    pub fn setlocale(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type Pointer = *mut ::std::os::raw::c_char;
pub type int8 = ::std::os::raw::c_schar;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::std::os::raw::c_long;
pub type uint64 = ::std::os::raw::c_ulong;
pub type int128 = [u64; 2];
pub type uint128 = [u64; 2];
pub type Size = usize;
pub type Index = ::std::os::raw::c_uint;
pub type Offset = ::std::os::raw::c_int;
pub type float4 = f32;
pub type float8 = f64;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IntArray {
    pub indx: [::std::os::raw::c_int; 6usize],
}
#[test]
fn bindgen_test_layout_IntArray() {
    assert_eq!(
        ::std::mem::size_of::<IntArray>(),
        24usize,
        concat!("Size of: ", stringify!(IntArray))
    );
    assert_eq!(
        ::std::mem::align_of::<IntArray>(),
        4usize,
        concat!("Alignment of ", stringify!(IntArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntArray>())).indx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IntArray),
            "::",
            stringify!(indx)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct varlena {
    pub vl_len_: [::std::os::raw::c_char; 4usize],
    pub vl_dat: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varlena() {
    assert_eq!(
        ::std::mem::size_of::<varlena>(),
        4usize,
        concat!("Size of: ", stringify!(varlena))
    );
    assert_eq!(
        ::std::mem::align_of::<varlena>(),
        1usize,
        concat!("Alignment of ", stringify!(varlena))
    );
}
pub type bytea = varlena;
pub type text = varlena;
pub type BpChar = varlena;
pub type VarChar = varlena;
#[repr(C)]
#[derive(Debug)]
pub struct int2vector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: __IncompleteArrayField<int16>,
}
#[test]
fn bindgen_test_layout_int2vector() {
    assert_eq!(
        ::std::mem::size_of::<int2vector>(),
        24usize,
        concat!("Size of: ", stringify!(int2vector))
    );
    assert_eq!(
        ::std::mem::align_of::<int2vector>(),
        4usize,
        concat!("Alignment of ", stringify!(int2vector))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct oidvector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: __IncompleteArrayField<Oid>,
}
#[test]
fn bindgen_test_layout_oidvector() {
    assert_eq!(
        ::std::mem::size_of::<oidvector>(),
        24usize,
        concat!("Size of: ", stringify!(oidvector))
    );
    assert_eq!(
        ::std::mem::align_of::<oidvector>(),
        4usize,
        concat!("Alignment of ", stringify!(oidvector))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nameData {
    pub data: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_nameData() {
    assert_eq!(
        ::std::mem::size_of::<nameData>(),
        64usize,
        concat!("Size of: ", stringify!(nameData))
    );
    assert_eq!(
        ::std::mem::align_of::<nameData>(),
        1usize,
        concat!("Alignment of ", stringify!(nameData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nameData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nameData),
            "::",
            stringify!(data)
        )
    );
}
pub type NameData = nameData;
pub type Name = *mut NameData;
extern "C" {
    #[link_name = "\u{1}_ExceptionalCondition"]
    pub fn ExceptionalCondition(
        conditionName: *const ::std::os::raw::c_char,
        errorType: *const ::std::os::raw::c_char,
        fileName: *const ::std::os::raw::c_char,
        lineNumber: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PGAlignedBlock {
    pub data: [::std::os::raw::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
    _bindgen_union_align: [u64; 1024usize],
}
#[test]
fn bindgen_test_layout_PGAlignedBlock() {
    assert_eq!(
        ::std::mem::size_of::<PGAlignedBlock>(),
        8192usize,
        concat!("Size of: ", stringify!(PGAlignedBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<PGAlignedBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(PGAlignedBlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PGAlignedBlock>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedBlock),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PGAlignedBlock>())).force_align_d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedBlock),
            "::",
            stringify!(force_align_d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PGAlignedBlock>())).force_align_i64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedBlock),
            "::",
            stringify!(force_align_i64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PGAlignedXLogBlock {
    pub data: [::std::os::raw::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
    _bindgen_union_align: [u64; 1024usize],
}
#[test]
fn bindgen_test_layout_PGAlignedXLogBlock() {
    assert_eq!(
        ::std::mem::size_of::<PGAlignedXLogBlock>(),
        8192usize,
        concat!("Size of: ", stringify!(PGAlignedXLogBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<PGAlignedXLogBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(PGAlignedXLogBlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PGAlignedXLogBlock>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedXLogBlock),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PGAlignedXLogBlock>())).force_align_d as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedXLogBlock),
            "::",
            stringify!(force_align_d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PGAlignedXLogBlock>())).force_align_i64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedXLogBlock),
            "::",
            stringify!(force_align_i64)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_fdatasync"]
    pub fn fdatasync(fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneEntry() {
    assert_eq!(
        ::std::mem::size_of::<_RuneEntry>(),
        24usize,
        concat!("Size of: ", stringify!(_RuneEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneEntry>())).__types as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__types)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
#[test]
fn bindgen_test_layout__RuneRange() {
    assert_eq!(
        ::std::mem::size_of::<_RuneRange>(),
        16usize,
        concat!("Size of: ", stringify!(_RuneRange))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneRange>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneRange>())).__nranges as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__nranges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneRange>())).__ranges as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__ranges)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneCharClass() {
    assert_eq!(
        ::std::mem::size_of::<_RuneCharClass>(),
        20usize,
        concat!("Size of: ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneCharClass>(),
        4usize,
        concat!("Alignment of ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneCharClass>())).__name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneCharClass>())).__mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: __darwin_size_t,
            arg3: *mut *const ::std::os::raw::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: __darwin_size_t,
            arg4: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
#[test]
fn bindgen_test_layout__RuneLocale() {
    assert_eq!(
        ::std::mem::size_of::<_RuneLocale>(),
        3208usize,
        concat!("Size of: ", stringify!(_RuneLocale))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneLocale>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneLocale))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__encoding as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__sgetrune as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sgetrune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__sputrune as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sputrune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__invalid_rune as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__invalid_rune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__runetype as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__maplower as *const _ as usize },
        1084usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__mapupper as *const _ as usize },
        2108usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__runetype_ext as *const _ as usize },
        3136usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__maplower_ext as *const _ as usize },
        3152usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__mapupper_ext as *const _ as usize },
        3168usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__variable as *const _ as usize },
        3184usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__variable_len as *const _ as usize },
        3192usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__ncharclasses as *const _ as usize },
        3196usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__ncharclasses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RuneLocale>())).__charclasses as *const _ as usize },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__charclasses)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__DefaultRuneLocale"]
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
extern "C" {
    #[link_name = "\u{1}__CurrentRuneLocale"]
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
extern "C" {
    #[link_name = "\u{1}____runetype"]
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}____tolower"]
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    #[link_name = "\u{1}____toupper"]
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    #[link_name = "\u{1}___maskrune"]
    pub fn __maskrune(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___toupper"]
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    #[link_name = "\u{1}___tolower"]
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
pub type socklen_t = __darwin_socklen_t;
pub type sa_family_t = __uint8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
#[test]
fn bindgen_test_layout_sa_endpoints() {
    assert_eq!(
        ::std::mem::size_of::<sa_endpoints>(),
        40usize,
        concat!("Size of: ", stringify!(sa_endpoints))
    );
    assert_eq!(
        ::std::mem::align_of::<sa_endpoints>(),
        8usize,
        concat!("Alignment of ", stringify!(sa_endpoints))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcif as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcif)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcaddrlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_dstaddr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_dstaddrlen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddrlen)
        )
    );
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[test]
fn bindgen_test_layout_so_np_extensions() {
    assert_eq!(
        ::std::mem::size_of::<so_np_extensions>(),
        8usize,
        concat!("Size of: ", stringify!(so_np_extensions))
    );
    assert_eq!(
        ::std::mem::align_of::<so_np_extensions>(),
        4usize,
        concat!("Alignment of ", stringify!(so_np_extensions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<so_np_extensions>())).npx_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<so_np_extensions>())).npx_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[test]
fn bindgen_test_layout_sockproto() {
    assert_eq!(
        ::std::mem::size_of::<sockproto>(),
        4usize,
        concat!("Size of: ", stringify!(sockproto))
    );
    assert_eq!(
        ::std::mem::align_of::<sockproto>(),
        2usize,
        concat!("Alignment of ", stringify!(sockproto))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockproto>())).sp_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockproto>())).sp_protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_protocol)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_pad1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_pad2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        48usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        12usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    assert_eq!(
        ::std::mem::size_of::<sf_hdtr>(),
        32usize,
        concat!("Size of: ", stringify!(sf_hdtr))
    );
    assert_eq!(
        ::std::mem::align_of::<sf_hdtr>(),
        8usize,
        concat!("Alignment of ", stringify!(sf_hdtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).headers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).hdr_cnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(hdr_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).trailers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trailers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).trl_cnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trl_cnt)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_accept"]
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bind"]
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_connect"]
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getpeername"]
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getsockname"]
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getsockopt"]
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_listen"]
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_recv"]
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_recvfrom"]
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_recvmsg"]
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_send"]
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_sendmsg"]
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *const msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_sendto"]
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_setsockopt"]
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_shutdown"]
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sockatmark"]
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_socket"]
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_socketpair"]
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sendfile"]
    pub fn sendfile(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: *mut off_t,
        arg5: *mut sf_hdtr,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pfctlinput"]
    pub fn pfctlinput(arg1: ::std::os::raw::c_int, arg2: *mut sockaddr);
}
extern "C" {
    #[link_name = "\u{1}_connectx"]
    pub fn connectx(
        arg1: ::std::os::raw::c_int,
        arg2: *const sa_endpoints_t,
        arg3: sae_associd_t,
        arg4: ::std::os::raw::c_uint,
        arg5: *const iovec,
        arg6: ::std::os::raw::c_uint,
        arg7: *mut usize,
        arg8: *mut sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_disconnectx"]
    pub fn disconnectx(
        arg1: ::std::os::raw::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_opts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_sourceaddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_interface as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
pub struct group_req {
    pub _bindgen_opaque_blob: [u32; 33usize],
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        132usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_req))
    );
}
#[repr(C)]
pub struct group_source_req {
    pub _bindgen_opaque_blob: [u32; 65usize],
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        260usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
}
#[repr(C)]
pub struct __msfilterreq {
    pub _bindgen_opaque_blob: [u32; 38usize],
}
#[test]
fn bindgen_test_layout___msfilterreq() {
    assert_eq!(
        ::std::mem::size_of::<__msfilterreq>(),
        152usize,
        concat!("Size of: ", stringify!(__msfilterreq))
    );
    assert_eq!(
        ::std::mem::align_of::<__msfilterreq>(),
        4usize,
        concat!("Alignment of ", stringify!(__msfilterreq))
    );
}
extern "C" {
    #[link_name = "\u{1}_setipv4sourcefilter"]
    pub fn setipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getipv4sourcefilter"]
    pub fn getipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: *mut u32,
        arg5: *mut u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setsourcefilter"]
    pub fn setsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: u32,
        arg6: u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getsourcefilter"]
    pub fn getsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: *mut u32,
        arg6: *mut u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_spec_dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__u6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__u6_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_in6addr_any"]
    pub static in6addr_any: in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_in6addr_loopback"]
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_in6addr_nodelocal_allnodes"]
    pub static in6addr_nodelocal_allnodes: in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_in6addr_linklocal_allnodes"]
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_in6addr_linklocal_allrouters"]
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_in6addr_linklocal_allv2routers"]
    pub static in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_pktinfo>())).ipi6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_pktinfo>())).ipi6_ifindex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_mtuinfo>())).ip6m_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_mtuinfo>())).ip6m_mtu as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_space"]
    pub fn inet6_option_space(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_init"]
    pub fn inet6_option_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut cmsghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_append"]
    pub fn inet6_option_append(
        arg1: *mut cmsghdr,
        arg2: *const __uint8_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_alloc"]
    pub fn inet6_option_alloc(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut __uint8_t;
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_next"]
    pub fn inet6_option_next(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_find"]
    pub fn inet6_option_find(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_space"]
    pub fn inet6_rthdr_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_init"]
    pub fn inet6_rthdr_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut cmsghdr;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_add"]
    pub fn inet6_rthdr_add(
        arg1: *mut cmsghdr,
        arg2: *const in6_addr,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_lasthop"]
    pub fn inet6_rthdr_lasthop(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_segments"]
    pub fn inet6_rthdr_segments(arg1: *const cmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_getaddr"]
    pub fn inet6_rthdr_getaddr(arg1: *mut cmsghdr, arg2: ::std::os::raw::c_int) -> *mut in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_getflags"]
    pub fn inet6_rthdr_getflags(
        arg1: *const cmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_init"]
    pub fn inet6_opt_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_append"]
    pub fn inet6_opt_append(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: socklen_t,
        arg6: __uint8_t,
        arg7: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_finish"]
    pub fn inet6_opt_finish(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_set_val"]
    pub fn inet6_opt_set_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_next"]
    pub fn inet6_opt_next(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_find"]
    pub fn inet6_opt_find(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_get_val"]
    pub fn inet6_opt_get_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_space"]
    pub fn inet6_rth_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> socklen_t;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_init"]
    pub fn inet6_rth_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_add"]
    pub fn inet6_rth_add(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_reverse"]
    pub fn inet6_rth_reverse(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_segments"]
    pub fn inet6_rth_segments(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_getaddr"]
    pub fn inet6_rth_getaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_addrsel_policy_init"]
    pub fn addrsel_policy_init();
}
extern "C" {
    #[link_name = "\u{1}_bindresvport"]
    pub fn bindresvport(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bindresvport_sa"]
    pub fn bindresvport_sa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_h_errno"]
    pub static mut h_errno: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    assert_eq!(
        ::std::mem::size_of::<hostent>(),
        32usize,
        concat!("Size of: ", stringify!(hostent))
    );
    assert_eq!(
        ::std::mem::align_of::<hostent>(),
        8usize,
        concat!("Alignment of ", stringify!(hostent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_addrtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hostent>())).h_addr_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addr_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    assert_eq!(
        ::std::mem::size_of::<netent>(),
        24usize,
        concat!("Size of: ", stringify!(netent))
    );
    assert_eq!(
        ::std::mem::align_of::<netent>(),
        8usize,
        concat!("Alignment of ", stringify!(netent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_addrtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_addrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<netent>())).n_net as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_net)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    assert_eq!(
        ::std::mem::size_of::<servent>(),
        32usize,
        concat!("Size of: ", stringify!(servent))
    );
    assert_eq!(
        ::std::mem::align_of::<servent>(),
        8usize,
        concat!("Alignment of ", stringify!(servent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_port as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<servent>())).s_proto as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    assert_eq!(
        ::std::mem::size_of::<protoent>(),
        24usize,
        concat!("Size of: ", stringify!(protoent))
    );
    assert_eq!(
        ::std::mem::align_of::<protoent>(),
        8usize,
        concat!("Alignment of ", stringify!(protoent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<protoent>())).p_proto as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_socktype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_protocol as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addrlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_canonname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<addrinfo>())).ai_next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rpcent() {
    assert_eq!(
        ::std::mem::size_of::<rpcent>(),
        24usize,
        concat!("Size of: ", stringify!(rpcent))
    );
    assert_eq!(
        ::std::mem::align_of::<rpcent>(),
        8usize,
        concat!("Alignment of ", stringify!(rpcent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rpcent>())).r_number as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_number)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_endhostent"]
    pub fn endhostent();
}
extern "C" {
    #[link_name = "\u{1}_endnetent"]
    pub fn endnetent();
}
extern "C" {
    #[link_name = "\u{1}_endprotoent"]
    pub fn endprotoent();
}
extern "C" {
    #[link_name = "\u{1}_endservent"]
    pub fn endservent();
}
extern "C" {
    #[link_name = "\u{1}_freeaddrinfo"]
    pub fn freeaddrinfo(arg1: *mut addrinfo);
}
extern "C" {
    #[link_name = "\u{1}_gai_strerror"]
    pub fn gai_strerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getaddrinfo"]
    pub fn getaddrinfo(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const addrinfo,
        arg4: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_gethostbyaddr"]
    pub fn gethostbyaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    #[link_name = "\u{1}_gethostbyname"]
    pub fn gethostbyname(arg1: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    #[link_name = "\u{1}_gethostent"]
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    #[link_name = "\u{1}_getnameinfo"]
    pub fn getnameinfo(
        arg1: *const sockaddr,
        arg2: socklen_t,
        arg3: *mut ::std::os::raw::c_char,
        arg4: socklen_t,
        arg5: *mut ::std::os::raw::c_char,
        arg6: socklen_t,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getnetbyaddr"]
    pub fn getnetbyaddr(arg1: u32, arg2: ::std::os::raw::c_int) -> *mut netent;
}
extern "C" {
    #[link_name = "\u{1}_getnetbyname"]
    pub fn getnetbyname(arg1: *const ::std::os::raw::c_char) -> *mut netent;
}
extern "C" {
    #[link_name = "\u{1}_getnetent"]
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    #[link_name = "\u{1}_getprotobyname"]
    pub fn getprotobyname(arg1: *const ::std::os::raw::c_char) -> *mut protoent;
}
extern "C" {
    #[link_name = "\u{1}_getprotobynumber"]
    pub fn getprotobynumber(arg1: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    #[link_name = "\u{1}_getprotoent"]
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    #[link_name = "\u{1}_getservbyname"]
    pub fn getservbyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    #[link_name = "\u{1}_getservbyport"]
    pub fn getservbyport(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    #[link_name = "\u{1}_getservent"]
    pub fn getservent() -> *mut servent;
}
extern "C" {
    #[link_name = "\u{1}_sethostent"]
    pub fn sethostent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_setnetent"]
    pub fn setnetent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_setprotoent"]
    pub fn setprotoent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_setservent"]
    pub fn setservent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_freehostent"]
    pub fn freehostent(arg1: *mut hostent);
}
extern "C" {
    #[link_name = "\u{1}_gethostbyname2"]
    pub fn gethostbyname2(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    #[link_name = "\u{1}_getipnodebyaddr"]
    pub fn getipnodebyaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    #[link_name = "\u{1}_getipnodebyname"]
    pub fn getipnodebyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    #[link_name = "\u{1}_getrpcbyname"]
    pub fn getrpcbyname(name: *const ::std::os::raw::c_char) -> *mut rpcent;
}
extern "C" {
    #[link_name = "\u{1}_getrpcbynumber"]
    pub fn getrpcbynumber(number: ::std::os::raw::c_int) -> *mut rpcent;
}
extern "C" {
    #[link_name = "\u{1}_getrpcent"]
    pub fn getrpcent() -> *mut rpcent;
}
extern "C" {
    #[link_name = "\u{1}_setrpcent"]
    pub fn setrpcent(stayopen: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_endrpcent"]
    pub fn endrpcent();
}
extern "C" {
    #[link_name = "\u{1}_herror"]
    pub fn herror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_hstrerror"]
    pub fn hstrerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_innetgr"]
    pub fn innetgr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getnetgrent"]
    pub fn getnetgrent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_endnetgrent"]
    pub fn endnetgrent();
}
extern "C" {
    #[link_name = "\u{1}_setnetgrent"]
    pub fn setnetgrent(arg1: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct passwd {
    pub pw_name: *mut ::std::os::raw::c_char,
    pub pw_passwd: *mut ::std::os::raw::c_char,
    pub pw_uid: uid_t,
    pub pw_gid: gid_t,
    pub pw_change: __darwin_time_t,
    pub pw_class: *mut ::std::os::raw::c_char,
    pub pw_gecos: *mut ::std::os::raw::c_char,
    pub pw_dir: *mut ::std::os::raw::c_char,
    pub pw_shell: *mut ::std::os::raw::c_char,
    pub pw_expire: __darwin_time_t,
}
#[test]
fn bindgen_test_layout_passwd() {
    assert_eq!(
        ::std::mem::size_of::<passwd>(),
        72usize,
        concat!("Size of: ", stringify!(passwd))
    );
    assert_eq!(
        ::std::mem::align_of::<passwd>(),
        8usize,
        concat!("Alignment of ", stringify!(passwd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_passwd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_passwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_gid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_change as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_change)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_class as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_gecos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_gecos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_dir as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_shell as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_shell)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<passwd>())).pw_expire as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_expire)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_getpwuid"]
    pub fn getpwuid(arg1: uid_t) -> *mut passwd;
}
extern "C" {
    #[link_name = "\u{1}_getpwnam"]
    pub fn getpwnam(arg1: *const ::std::os::raw::c_char) -> *mut passwd;
}
extern "C" {
    #[link_name = "\u{1}_getpwuid_r"]
    pub fn getpwuid_r(
        arg1: uid_t,
        arg2: *mut passwd,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
        arg5: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getpwnam_r"]
    pub fn getpwnam_r(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut passwd,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
        arg5: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getpwent"]
    pub fn getpwent() -> *mut passwd;
}
extern "C" {
    #[link_name = "\u{1}_setpwent"]
    pub fn setpwent();
}
extern "C" {
    #[link_name = "\u{1}_endpwent"]
    pub fn endpwent();
}
pub type uuid_t = __darwin_uuid_t;
pub type uuid_string_t = __darwin_uuid_string_t;
extern "C" {
    #[link_name = "\u{1}_UUID_NULL"]
    pub static UUID_NULL: uuid_t;
}
extern "C" {
    #[link_name = "\u{1}_uuid_clear"]
    pub fn uuid_clear(uu: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_uuid_compare"]
    pub fn uuid_compare(
        uu1: *mut ::std::os::raw::c_uchar,
        uu2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uuid_copy"]
    pub fn uuid_copy(dst: *mut ::std::os::raw::c_uchar, src: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_uuid_generate"]
    pub fn uuid_generate(out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_uuid_generate_random"]
    pub fn uuid_generate_random(out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_uuid_generate_time"]
    pub fn uuid_generate_time(out: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_uuid_is_null"]
    pub fn uuid_is_null(uu: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uuid_parse"]
    pub fn uuid_parse(
        in_: *mut ::std::os::raw::c_char,
        uu: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_uuid_unparse"]
    pub fn uuid_unparse(uu: *mut ::std::os::raw::c_uchar, out: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_uuid_unparse_lower"]
    pub fn uuid_unparse_lower(uu: *mut ::std::os::raw::c_uchar, out: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_uuid_unparse_upper"]
    pub fn uuid_unparse_upper(uu: *mut ::std::os::raw::c_uchar, out: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_setpassent"]
    pub fn setpassent(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_user_from_uid"]
    pub fn user_from_uid(arg1: uid_t, arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getpwuuid"]
    pub fn getpwuuid(arg1: *mut ::std::os::raw::c_uchar) -> *mut passwd;
}
extern "C" {
    #[link_name = "\u{1}_getpwuuid_r"]
    pub fn getpwuuid_r(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: *mut passwd,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
        arg5: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
pub type pgsocket = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "\u{1}_pg_set_noblock"]
    pub fn pg_set_noblock(sock: pgsocket) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_set_block"]
    pub fn pg_set_block(sock: pgsocket) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_has_drive_prefix"]
    pub fn has_drive_prefix(filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_first_dir_separator"]
    pub fn first_dir_separator(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_last_dir_separator"]
    pub fn last_dir_separator(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_first_path_var_separator"]
    pub fn first_path_var_separator(
        pathlist: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_join_path_components"]
    pub fn join_path_components(
        ret_path: *mut ::std::os::raw::c_char,
        head: *const ::std::os::raw::c_char,
        tail: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_canonicalize_path"]
    pub fn canonicalize_path(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_make_native_path"]
    pub fn make_native_path(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_cleanup_path"]
    pub fn cleanup_path(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_path_contains_parent_reference"]
    pub fn path_contains_parent_reference(path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_path_is_relative_and_below_cwd"]
    pub fn path_is_relative_and_below_cwd(path: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_path_is_prefix_of_path"]
    pub fn path_is_prefix_of_path(
        path1: *const ::std::os::raw::c_char,
        path2: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_make_absolute_path"]
    pub fn make_absolute_path(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_get_progname"]
    pub fn get_progname(argv0: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_get_share_path"]
    pub fn get_share_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_etc_path"]
    pub fn get_etc_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_include_path"]
    pub fn get_include_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_pkginclude_path"]
    pub fn get_pkginclude_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_includeserver_path"]
    pub fn get_includeserver_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_lib_path"]
    pub fn get_lib_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_pkglib_path"]
    pub fn get_pkglib_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_locale_path"]
    pub fn get_locale_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_doc_path"]
    pub fn get_doc_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_html_path"]
    pub fn get_html_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_man_path"]
    pub fn get_man_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_home_path"]
    pub fn get_home_path(ret_path: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_get_parent_directory"]
    pub fn get_parent_directory(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_pgfnames"]
    pub fn pgfnames(path: *const ::std::os::raw::c_char) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_pgfnames_cleanup"]
    pub fn pgfnames_cleanup(filenames: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_set_pglocale_pgservice"]
    pub fn set_pglocale_pgservice(
        argv0: *const ::std::os::raw::c_char,
        app: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_find_my_exec"]
    pub fn find_my_exec(
        argv0: *const ::std::os::raw::c_char,
        retpath: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_find_other_exec"]
    pub fn find_other_exec(
        argv0: *const ::std::os::raw::c_char,
        target: *const ::std::os::raw::c_char,
        versionstr: *const ::std::os::raw::c_char,
        retpath: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pg_usleep"]
    pub fn pg_usleep(microsec: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_pg_strcasecmp"]
    pub fn pg_strcasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pg_strncasecmp"]
    pub fn pg_strncasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pg_toupper"]
    pub fn pg_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_pg_tolower"]
    pub fn pg_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_pg_ascii_toupper"]
    pub fn pg_ascii_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_pg_ascii_tolower"]
    pub fn pg_ascii_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_simple_prompt"]
    pub fn simple_prompt(
        prompt: *const ::std::os::raw::c_char,
        destination: *mut ::std::os::raw::c_char,
        destlen: usize,
        echo: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_pclose_check"]
    pub fn pclose_check(stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rmtree"]
    pub fn rmtree(path: *const ::std::os::raw::c_char, rmtopdir: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_erand48"]
    pub fn pg_erand48(xseed: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_pg_lrand48"]
    pub fn pg_lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_pg_jrand48"]
    pub fn pg_jrand48(xseed: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_pg_srand48"]
    pub fn pg_srand48(seed: ::std::os::raw::c_long);
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    #[link_name = "\u{1}___math_errhandling"]
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___fpclassifyf"]
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___fpclassifyd"]
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___fpclassifyl"]
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_acosf"]
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_acos"]
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_acosl"]
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_asinf"]
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_asin"]
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_asinl"]
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atanf"]
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_atan"]
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atanl"]
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atan2f"]
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_atan2"]
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atan2l"]
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_cosf"]
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_cos"]
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_cosl"]
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sinf"]
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sin"]
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sinl"]
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tanf"]
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_tan"]
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tanl"]
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_acoshf"]
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_acosh"]
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_acoshl"]
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_asinhf"]
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_asinh"]
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_asinhl"]
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atanhf"]
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_atanh"]
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atanhl"]
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_coshf"]
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_cosh"]
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_coshl"]
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sinhf"]
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sinh"]
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sinhl"]
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tanhf"]
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_tanh"]
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tanhl"]
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_expf"]
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_exp"]
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_expl"]
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_exp2f"]
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_exp2"]
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_exp2l"]
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_expm1f"]
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_expm1"]
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_expm1l"]
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_logf"]
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log"]
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_logl"]
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log10f"]
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log10"]
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log10l"]
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log2f"]
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log2"]
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log2l"]
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log1pf"]
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log1p"]
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log1pl"]
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_logbf"]
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_logb"]
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_logbl"]
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_modff"]
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_modf"]
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_modfl"]
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ldexpf"]
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ldexp"]
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ldexpl"]
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_frexpf"]
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_frexp"]
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_frexpl"]
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ilogbf"]
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ilogb"]
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ilogbl"]
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_scalbnf"]
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_scalbn"]
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_scalbnl"]
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_scalblnf"]
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_scalbln"]
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_scalblnl"]
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fabsf"]
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fabs"]
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fabsl"]
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_cbrtf"]
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_cbrt"]
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_cbrtl"]
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_hypotf"]
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_hypot"]
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_hypotl"]
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_powf"]
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_pow"]
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_powl"]
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sqrtf"]
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sqrt"]
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sqrtl"]
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_erff"]
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_erf"]
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_erfl"]
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_erfcf"]
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_erfc"]
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_erfcl"]
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_lgammaf"]
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_lgamma"]
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_lgammal"]
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tgammaf"]
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_tgamma"]
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tgammal"]
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ceilf"]
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ceil"]
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ceill"]
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_floorf"]
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_floor"]
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_floorl"]
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nearbyintf"]
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nearbyint"]
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nearbyintl"]
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_rintf"]
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_rint"]
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_rintl"]
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_lrintf"]
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lrint"]
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lrintl"]
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_roundf"]
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_round"]
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_roundl"]
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_lroundf"]
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lround"]
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lroundl"]
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_llrintf"]
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llrint"]
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llrintl"]
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llroundf"]
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llround"]
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llroundl"]
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_truncf"]
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_trunc"]
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_truncl"]
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmodf"]
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fmod"]
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmodl"]
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_remainderf"]
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_remainder"]
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_remainderl"]
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_remquof"]
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_remquo"]
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_remquol"]
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_copysignf"]
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_copysign"]
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_copysignl"]
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nanf"]
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nan"]
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nanl"]
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nextafterf"]
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nextafter"]
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nextafterl"]
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nexttoward"]
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nexttowardf"]
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nexttowardl"]
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fdimf"]
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fdim"]
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fdiml"]
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmaxf"]
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fmax"]
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmaxl"]
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fminf"]
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fmin"]
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fminl"]
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmaf"]
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fma"]
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmal"]
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}___inff"]
    pub fn __inff() -> f32;
}
extern "C" {
    #[link_name = "\u{1}___inf"]
    pub fn __inf() -> f64;
}
extern "C" {
    #[link_name = "\u{1}___infl"]
    pub fn __infl() -> f64;
}
extern "C" {
    #[link_name = "\u{1}___nan"]
    pub fn __nan() -> f32;
}
extern "C" {
    #[link_name = "\u{1}___exp10f"]
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___exp10"]
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}___cospif"]
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___cospi"]
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}___sinpif"]
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___sinpi"]
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}___tanpif"]
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___tanpi"]
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    assert_eq!(
        ::std::mem::size_of::<__float2>(),
        8usize,
        concat!("Size of: ", stringify!(__float2))
    );
    assert_eq!(
        ::std::mem::align_of::<__float2>(),
        4usize,
        concat!("Alignment of ", stringify!(__float2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__float2>())).__sinval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__float2>())).__cosval as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__cosval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    assert_eq!(
        ::std::mem::size_of::<__double2>(),
        16usize,
        concat!("Size of: ", stringify!(__double2))
    );
    assert_eq!(
        ::std::mem::align_of::<__double2>(),
        8usize,
        concat!("Alignment of ", stringify!(__double2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__double2>())).__sinval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__double2>())).__cosval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__cosval)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}___sincosf_stret"]
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    #[link_name = "\u{1}___sincos_stret"]
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    #[link_name = "\u{1}___sincospif_stret"]
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    #[link_name = "\u{1}___sincospi_stret"]
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    #[link_name = "\u{1}_j0"]
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_j1"]
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_jn"]
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_y0"]
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_y1"]
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_yn"]
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_scalb"]
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_signgam"]
    pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rinttol"]
    pub fn rinttol(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_roundtol"]
    pub fn roundtol(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_drem"]
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_finite"]
    pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_gamma"]
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_significand"]
    pub fn significand(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(
        ::std::mem::size_of::<exception>(),
        40usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).retval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_matherr"]
    pub fn matherr(arg1: *mut exception) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pqStrerror"]
    pub fn pqStrerror(
        errnum: ::std::os::raw::c_int,
        strerrbuf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_pqGetpwuid"]
    pub fn pqGetpwuid(
        uid: uid_t,
        resultbuf: *mut passwd,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
        result: *mut *mut passwd,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pqGethostbyname"]
    pub fn pqGethostbyname(
        name: *const ::std::os::raw::c_char,
        resultbuf: *mut hostent,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
        result: *mut *mut hostent,
        herrno: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pg_qsort"]
    pub fn pg_qsort(
        base: *mut ::std::os::raw::c_void,
        nel: usize,
        elsize: usize,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_pg_qsort_strcmp"]
    pub fn pg_qsort_strcmp(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type qsort_arg_comparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[link_name = "\u{1}_qsort_arg"]
    pub fn qsort_arg(
        base: *mut ::std::os::raw::c_void,
        nel: usize,
        elsize: usize,
        cmp: qsort_arg_comparator,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_pg_get_encoding_from_locale"]
    pub fn pg_get_encoding_from_locale(
        ctype: *const ::std::os::raw::c_char,
        write_message: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet_net_ntop"]
    pub fn inet_net_ntop(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        bits: ::std::os::raw::c_int,
        dst: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_pg_strong_random"]
    pub fn pg_strong_random(buf: *mut ::std::os::raw::c_void, len: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_check_dir"]
    pub fn pg_check_dir(dir: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pg_mkdir_p"]
    pub fn pg_mkdir_p(
        path: *mut ::std::os::raw::c_char,
        omode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type pqsigfunc = ::std::option::Option<unsafe extern "C" fn(signo: ::std::os::raw::c_int)>;
extern "C" {
    #[link_name = "\u{1}_pqsignal"]
    pub fn pqsignal(signo: ::std::os::raw::c_int, func: pqsigfunc) -> pqsigfunc;
}
extern "C" {
    #[link_name = "\u{1}_pqsignal_no_restart"]
    pub fn pqsignal_no_restart(signo: ::std::os::raw::c_int, func: pqsigfunc) -> pqsigfunc;
}
extern "C" {
    #[link_name = "\u{1}_escape_single_quotes_ascii"]
    pub fn escape_single_quotes_ascii(
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_wait_result_to_str"]
    pub fn wait_result_to_str(exit_status: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type jmp_buf = [::std::os::raw::c_int; 37usize];
pub type sigjmp_buf = [::std::os::raw::c_int; 38usize];
extern "C" {
    #[link_name = "\u{1}_setjmp"]
    pub fn setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_longjmp"]
    pub fn longjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}__setjmp"]
    pub fn _setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__longjmp"]
    pub fn _longjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_sigsetjmp"]
    pub fn sigsetjmp(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_siglongjmp"]
    pub fn siglongjmp(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_longjmperror"]
    pub fn longjmperror();
}
extern "C" {
    #[link_name = "\u{1}_errstart"]
    pub fn errstart(
        elevel: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
        funcname: *const ::std::os::raw::c_char,
        domain: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_errfinish"]
    pub fn errfinish(dummy: ::std::os::raw::c_int, ...);
}
extern "C" {
    #[link_name = "\u{1}_errcode"]
    pub fn errcode(sqlerrcode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errcode_for_file_access"]
    pub fn errcode_for_file_access() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errcode_for_socket_access"]
    pub fn errcode_for_socket_access() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errmsg"]
    pub fn errmsg(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errmsg_internal"]
    pub fn errmsg_internal(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errmsg_plural"]
    pub fn errmsg_plural(
        fmt_singular: *const ::std::os::raw::c_char,
        fmt_plural: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errdetail"]
    pub fn errdetail(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errdetail_internal"]
    pub fn errdetail_internal(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errdetail_log"]
    pub fn errdetail_log(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errdetail_log_plural"]
    pub fn errdetail_log_plural(
        fmt_singular: *const ::std::os::raw::c_char,
        fmt_plural: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errdetail_plural"]
    pub fn errdetail_plural(
        fmt_singular: *const ::std::os::raw::c_char,
        fmt_plural: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errhint"]
    pub fn errhint(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_set_errcontext_domain"]
    pub fn set_errcontext_domain(domain: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errcontext_msg"]
    pub fn errcontext_msg(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errhidestmt"]
    pub fn errhidestmt(hide_stmt: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errhidecontext"]
    pub fn errhidecontext(hide_ctx: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errfunction"]
    pub fn errfunction(funcname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errposition"]
    pub fn errposition(cursorpos: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_internalerrposition"]
    pub fn internalerrposition(cursorpos: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_internalerrquery"]
    pub fn internalerrquery(query: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_err_generic_string"]
    pub fn err_generic_string(
        field: ::std::os::raw::c_int,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_geterrcode"]
    pub fn geterrcode() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_geterrposition"]
    pub fn geterrposition() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getinternalerrposition"]
    pub fn getinternalerrposition() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_elog_start"]
    pub fn elog_start(
        filename: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
        funcname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_elog_finish"]
    pub fn elog_finish(elevel: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_pre_format_elog_string"]
    pub fn pre_format_elog_string(
        errnumber: ::std::os::raw::c_int,
        domain: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_format_elog_string"]
    pub fn format_elog_string(
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorContextCallback {
    pub previous: *mut ErrorContextCallback,
    pub callback: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ErrorContextCallback() {
    assert_eq!(
        ::std::mem::size_of::<ErrorContextCallback>(),
        24usize,
        concat!("Size of: ", stringify!(ErrorContextCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<ErrorContextCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(ErrorContextCallback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorContextCallback>())).previous as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorContextCallback),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorContextCallback>())).callback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorContextCallback),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorContextCallback>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorContextCallback),
            "::",
            stringify!(arg)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_error_context_stack"]
    pub static mut error_context_stack: *mut ErrorContextCallback;
}
extern "C" {
    #[link_name = "\u{1}_PG_exception_stack"]
    pub static mut PG_exception_stack: *mut sigjmp_buf;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorData {
    pub elevel: ::std::os::raw::c_int,
    pub output_to_server: bool,
    pub output_to_client: bool,
    pub show_funcname: bool,
    pub hide_stmt: bool,
    pub hide_ctx: bool,
    pub filename: *const ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub funcname: *const ::std::os::raw::c_char,
    pub domain: *const ::std::os::raw::c_char,
    pub context_domain: *const ::std::os::raw::c_char,
    pub sqlerrcode: ::std::os::raw::c_int,
    pub message: *mut ::std::os::raw::c_char,
    pub detail: *mut ::std::os::raw::c_char,
    pub detail_log: *mut ::std::os::raw::c_char,
    pub hint: *mut ::std::os::raw::c_char,
    pub context: *mut ::std::os::raw::c_char,
    pub message_id: *const ::std::os::raw::c_char,
    pub schema_name: *mut ::std::os::raw::c_char,
    pub table_name: *mut ::std::os::raw::c_char,
    pub column_name: *mut ::std::os::raw::c_char,
    pub datatype_name: *mut ::std::os::raw::c_char,
    pub constraint_name: *mut ::std::os::raw::c_char,
    pub cursorpos: ::std::os::raw::c_int,
    pub internalpos: ::std::os::raw::c_int,
    pub internalquery: *mut ::std::os::raw::c_char,
    pub saved_errno: ::std::os::raw::c_int,
    pub assoc_context: *mut MemoryContextData,
}
#[test]
fn bindgen_test_layout_ErrorData() {
    assert_eq!(
        ::std::mem::size_of::<ErrorData>(),
        184usize,
        concat!("Size of: ", stringify!(ErrorData))
    );
    assert_eq!(
        ::std::mem::align_of::<ErrorData>(),
        8usize,
        concat!("Alignment of ", stringify!(ErrorData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).elevel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(elevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).output_to_server as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(output_to_server)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).output_to_client as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(output_to_client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).show_funcname as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(show_funcname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).hide_stmt as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(hide_stmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).hide_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(hide_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).filename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).lineno as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(lineno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).funcname as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(funcname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).domain as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).context_domain as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(context_domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).sqlerrcode as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(sqlerrcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).message as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).detail as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).detail_log as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(detail_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).hint as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).context as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).message_id as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(message_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).schema_name as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(schema_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).table_name as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(table_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).column_name as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(column_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).datatype_name as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(datatype_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).constraint_name as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(constraint_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).cursorpos as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(cursorpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).internalpos as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(internalpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).internalquery as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(internalquery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).saved_errno as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(saved_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorData>())).assoc_context as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorData),
            "::",
            stringify!(assoc_context)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_EmitErrorReport"]
    pub fn EmitErrorReport();
}
extern "C" {
    #[link_name = "\u{1}_CopyErrorData"]
    pub fn CopyErrorData() -> *mut ErrorData;
}
extern "C" {
    #[link_name = "\u{1}_FreeErrorData"]
    pub fn FreeErrorData(edata: *mut ErrorData);
}
extern "C" {
    #[link_name = "\u{1}_FlushErrorState"]
    pub fn FlushErrorState();
}
extern "C" {
    #[link_name = "\u{1}_ReThrowError"]
    pub fn ReThrowError(edata: *mut ErrorData);
}
extern "C" {
    #[link_name = "\u{1}_ThrowErrorData"]
    pub fn ThrowErrorData(edata: *mut ErrorData);
}
extern "C" {
    #[link_name = "\u{1}_pg_re_throw"]
    pub fn pg_re_throw();
}
extern "C" {
    #[link_name = "\u{1}_GetErrorContextStack"]
    pub fn GetErrorContextStack() -> *mut ::std::os::raw::c_char;
}
pub type emit_log_hook_type = ::std::option::Option<unsafe extern "C" fn(edata: *mut ErrorData)>;
extern "C" {
    #[link_name = "\u{1}_emit_log_hook"]
    pub static mut emit_log_hook: emit_log_hook_type;
}
pub const PGErrorVerbosity_PGERROR_TERSE: PGErrorVerbosity = 0;
pub const PGErrorVerbosity_PGERROR_DEFAULT: PGErrorVerbosity = 1;
pub const PGErrorVerbosity_PGERROR_VERBOSE: PGErrorVerbosity = 2;
pub type PGErrorVerbosity = u32;
extern "C" {
    #[link_name = "\u{1}_Log_error_verbosity"]
    pub static mut Log_error_verbosity: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Log_line_prefix"]
    pub static mut Log_line_prefix: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_Log_destination"]
    pub static mut Log_destination: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Log_destination_string"]
    pub static mut Log_destination_string: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_syslog_sequence_numbers"]
    pub static mut syslog_sequence_numbers: bool;
}
extern "C" {
    #[link_name = "\u{1}_syslog_split_messages"]
    pub static mut syslog_split_messages: bool;
}
extern "C" {
    #[link_name = "\u{1}_DebugFileOpen"]
    pub fn DebugFileOpen();
}
extern "C" {
    #[link_name = "\u{1}_unpack_sql_state"]
    pub fn unpack_sql_state(sql_state: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_in_error_recursion_trouble"]
    pub fn in_error_recursion_trouble() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_set_syslog_parameters"]
    pub fn set_syslog_parameters(
        ident: *const ::std::os::raw::c_char,
        facility: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_write_stderr"]
    pub fn write_stderr(fmt: *const ::std::os::raw::c_char, ...);
}
pub type MemoryContext = *mut MemoryContextData;
pub type MemoryContextCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryContextCallback {
    pub func: MemoryContextCallbackFunction,
    pub arg: *mut ::std::os::raw::c_void,
    pub next: *mut MemoryContextCallback,
}
#[test]
fn bindgen_test_layout_MemoryContextCallback() {
    assert_eq!(
        ::std::mem::size_of::<MemoryContextCallback>(),
        24usize,
        concat!("Size of: ", stringify!(MemoryContextCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<MemoryContextCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryContextCallback))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MemoryContextCallback>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryContextCallback),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MemoryContextCallback>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryContextCallback),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MemoryContextCallback>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryContextCallback),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_CurrentMemoryContext"]
    pub static mut CurrentMemoryContext: MemoryContext;
}
extern "C" {
    #[link_name = "\u{1}_MemoryContextAlloc"]
    pub fn MemoryContextAlloc(context: MemoryContext, size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_MemoryContextAllocZero"]
    pub fn MemoryContextAllocZero(
        context: MemoryContext,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_MemoryContextAllocZeroAligned"]
    pub fn MemoryContextAllocZeroAligned(
        context: MemoryContext,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_MemoryContextAllocExtended"]
    pub fn MemoryContextAllocExtended(
        context: MemoryContext,
        size: Size,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_palloc"]
    pub fn palloc(size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_palloc0"]
    pub fn palloc0(size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_palloc_extended"]
    pub fn palloc_extended(size: Size, flags: ::std::os::raw::c_int)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_repalloc"]
    pub fn repalloc(
        pointer: *mut ::std::os::raw::c_void,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_pfree"]
    pub fn pfree(pointer: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_MemoryContextAllocHuge"]
    pub fn MemoryContextAllocHuge(
        context: MemoryContext,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_repalloc_huge"]
    pub fn repalloc_huge(
        pointer: *mut ::std::os::raw::c_void,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_MemoryContextRegisterResetCallback"]
    pub fn MemoryContextRegisterResetCallback(
        context: MemoryContext,
        cb: *mut MemoryContextCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_MemoryContextStrdup"]
    pub fn MemoryContextStrdup(
        context: MemoryContext,
        string: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_pstrdup"]
    pub fn pstrdup(in_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_pnstrdup"]
    pub fn pnstrdup(in_: *const ::std::os::raw::c_char, len: Size) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_pchomp"]
    pub fn pchomp(in_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_psprintf"]
    pub fn psprintf(fmt: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_pvsnprintf"]
    pub fn pvsnprintf(
        buf: *mut ::std::os::raw::c_char,
        len: usize,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_external {
    pub va_rawsize: int32,
    pub va_extsize: int32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
#[test]
fn bindgen_test_layout_varatt_external() {
    assert_eq!(
        ::std::mem::size_of::<varatt_external>(),
        16usize,
        concat!("Size of: ", stringify!(varatt_external))
    );
    assert_eq!(
        ::std::mem::align_of::<varatt_external>(),
        4usize,
        concat!("Alignment of ", stringify!(varatt_external))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<varatt_external>())).va_rawsize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_external),
            "::",
            stringify!(va_rawsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<varatt_external>())).va_extsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_external),
            "::",
            stringify!(va_extsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<varatt_external>())).va_valueid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_external),
            "::",
            stringify!(va_valueid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<varatt_external>())).va_toastrelid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_external),
            "::",
            stringify!(va_toastrelid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_indirect {
    pub pointer: *mut varlena,
}
#[test]
fn bindgen_test_layout_varatt_indirect() {
    assert_eq!(
        ::std::mem::size_of::<varatt_indirect>(),
        8usize,
        concat!("Size of: ", stringify!(varatt_indirect))
    );
    assert_eq!(
        ::std::mem::align_of::<varatt_indirect>(),
        8usize,
        concat!("Alignment of ", stringify!(varatt_indirect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<varatt_indirect>())).pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_indirect),
            "::",
            stringify!(pointer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_expanded {
    pub eohptr: *mut ExpandedObjectHeader,
}
#[test]
fn bindgen_test_layout_varatt_expanded() {
    assert_eq!(
        ::std::mem::size_of::<varatt_expanded>(),
        8usize,
        concat!("Size of: ", stringify!(varatt_expanded))
    );
    assert_eq!(
        ::std::mem::align_of::<varatt_expanded>(),
        8usize,
        concat!("Alignment of ", stringify!(varatt_expanded))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<varatt_expanded>())).eohptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_expanded),
            "::",
            stringify!(eohptr)
        )
    );
}
pub const vartag_external_VARTAG_INDIRECT: vartag_external = 1;
pub const vartag_external_VARTAG_EXPANDED_RO: vartag_external = 2;
pub const vartag_external_VARTAG_EXPANDED_RW: vartag_external = 3;
pub const vartag_external_VARTAG_ONDISK: vartag_external = 18;
pub type vartag_external = u32;
#[repr(C)]
pub struct varattrib_4b {
    pub va_4byte: __BindgenUnionField<varattrib_4b__bindgen_ty_1>,
    pub va_compressed: __BindgenUnionField<varattrib_4b__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct varattrib_4b__bindgen_ty_1 {
    pub va_header: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_4b__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<varattrib_4b__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(varattrib_4b__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<varattrib_4b__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(varattrib_4b__bindgen_ty_1))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct varattrib_4b__bindgen_ty_2 {
    pub va_header: uint32,
    pub va_rawsize: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_4b__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<varattrib_4b__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(varattrib_4b__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<varattrib_4b__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(varattrib_4b__bindgen_ty_2))
    );
}
#[test]
fn bindgen_test_layout_varattrib_4b() {
    assert_eq!(
        ::std::mem::size_of::<varattrib_4b>(),
        8usize,
        concat!("Size of: ", stringify!(varattrib_4b))
    );
    assert_eq!(
        ::std::mem::align_of::<varattrib_4b>(),
        4usize,
        concat!("Alignment of ", stringify!(varattrib_4b))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct varattrib_1b {
    pub va_header: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_1b() {
    assert_eq!(
        ::std::mem::size_of::<varattrib_1b>(),
        1usize,
        concat!("Size of: ", stringify!(varattrib_1b))
    );
    assert_eq!(
        ::std::mem::align_of::<varattrib_1b>(),
        1usize,
        concat!("Alignment of ", stringify!(varattrib_1b))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct varattrib_1b_e {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_1b_e() {
    assert_eq!(
        ::std::mem::size_of::<varattrib_1b_e>(),
        2usize,
        concat!("Size of: ", stringify!(varattrib_1b_e))
    );
    assert_eq!(
        ::std::mem::align_of::<varattrib_1b_e>(),
        1usize,
        concat!("Alignment of ", stringify!(varattrib_1b_e))
    );
}
pub type Datum = usize;
pub type fmNodePtr = *mut Node;
pub type fmAggrefPtr = *mut Aggref;
pub type fmExprContextCallbackFunction = ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
pub type fmStringInfo = *mut StringInfoData;
pub type FunctionCallInfo = *mut FunctionCallInfoData;
pub type PGFunction =
    ::std::option::Option<unsafe extern "C" fn(fcinfo: FunctionCallInfo) -> Datum>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::std::os::raw::c_short,
    pub fn_strict: bool,
    pub fn_retset: bool,
    pub fn_stats: ::std::os::raw::c_uchar,
    pub fn_extra: *mut ::std::os::raw::c_void,
    pub fn_mcxt: MemoryContext,
    pub fn_expr: fmNodePtr,
}
#[test]
fn bindgen_test_layout_FmgrInfo() {
    assert_eq!(
        ::std::mem::size_of::<FmgrInfo>(),
        48usize,
        concat!("Size of: ", stringify!(FmgrInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<FmgrInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(FmgrInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FmgrInfo>())).fn_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FmgrInfo),
            "::",
            stringify!(fn_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FmgrInfo>())).fn_oid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FmgrInfo),
            "::",
            stringify!(fn_oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FmgrInfo>())).fn_nargs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FmgrInfo),
            "::",
            stringify!(fn_nargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FmgrInfo>())).fn_strict as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(FmgrInfo),
            "::",
            stringify!(fn_strict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FmgrInfo>())).fn_retset as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(FmgrInfo),
            "::",
            stringify!(fn_retset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FmgrInfo>())).fn_stats as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FmgrInfo),
            "::",
            stringify!(fn_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FmgrInfo>())).fn_extra as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FmgrInfo),
            "::",
            stringify!(fn_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FmgrInfo>())).fn_mcxt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FmgrInfo),
            "::",
            stringify!(fn_mcxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FmgrInfo>())).fn_expr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FmgrInfo),
            "::",
            stringify!(fn_expr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FunctionCallInfoData {
    pub flinfo: *mut FmgrInfo,
    pub context: fmNodePtr,
    pub resultinfo: fmNodePtr,
    pub fncollation: Oid,
    pub isnull: bool,
    pub nargs: ::std::os::raw::c_short,
    pub arg: [Datum; 100usize],
    pub argnull: [bool; 100usize],
}
#[test]
fn bindgen_test_layout_FunctionCallInfoData() {
    assert_eq!(
        ::std::mem::size_of::<FunctionCallInfoData>(),
        936usize,
        concat!("Size of: ", stringify!(FunctionCallInfoData))
    );
    assert_eq!(
        ::std::mem::align_of::<FunctionCallInfoData>(),
        8usize,
        concat!("Alignment of ", stringify!(FunctionCallInfoData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionCallInfoData>())).flinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionCallInfoData),
            "::",
            stringify!(flinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionCallInfoData>())).context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionCallInfoData),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionCallInfoData>())).resultinfo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionCallInfoData),
            "::",
            stringify!(resultinfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FunctionCallInfoData>())).fncollation as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionCallInfoData),
            "::",
            stringify!(fncollation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionCallInfoData>())).isnull as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionCallInfoData),
            "::",
            stringify!(isnull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionCallInfoData>())).nargs as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionCallInfoData),
            "::",
            stringify!(nargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionCallInfoData>())).arg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionCallInfoData),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionCallInfoData>())).argnull as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionCallInfoData),
            "::",
            stringify!(argnull)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_fmgr_info"]
    pub fn fmgr_info(functionId: Oid, finfo: *mut FmgrInfo);
}
extern "C" {
    #[link_name = "\u{1}_fmgr_info_cxt"]
    pub fn fmgr_info_cxt(functionId: Oid, finfo: *mut FmgrInfo, mcxt: MemoryContext);
}
extern "C" {
    #[link_name = "\u{1}_fmgr_info_copy"]
    pub fn fmgr_info_copy(dstinfo: *mut FmgrInfo, srcinfo: *mut FmgrInfo, destcxt: MemoryContext);
}
extern "C" {
    #[link_name = "\u{1}_fmgr_symbol"]
    pub fn fmgr_symbol(
        functionId: Oid,
        mod_: *mut *mut ::std::os::raw::c_char,
        fn_: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_pg_detoast_datum"]
    pub fn pg_detoast_datum(datum: *mut varlena) -> *mut varlena;
}
extern "C" {
    #[link_name = "\u{1}_pg_detoast_datum_copy"]
    pub fn pg_detoast_datum_copy(datum: *mut varlena) -> *mut varlena;
}
extern "C" {
    #[link_name = "\u{1}_pg_detoast_datum_slice"]
    pub fn pg_detoast_datum_slice(datum: *mut varlena, first: int32, count: int32) -> *mut varlena;
}
extern "C" {
    #[link_name = "\u{1}_pg_detoast_datum_packed"]
    pub fn pg_detoast_datum_packed(datum: *mut varlena) -> *mut varlena;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pg_finfo_record {
    pub api_version: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Pg_finfo_record() {
    assert_eq!(
        ::std::mem::size_of::<Pg_finfo_record>(),
        4usize,
        concat!("Size of: ", stringify!(Pg_finfo_record))
    );
    assert_eq!(
        ::std::mem::align_of::<Pg_finfo_record>(),
        4usize,
        concat!("Alignment of ", stringify!(Pg_finfo_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pg_finfo_record>())).api_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Pg_finfo_record),
            "::",
            stringify!(api_version)
        )
    );
}
pub type PGFInfoFunction = ::std::option::Option<unsafe extern "C" fn() -> *const Pg_finfo_record>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pg_magic_struct {
    pub len: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_int,
    pub funcmaxargs: ::std::os::raw::c_int,
    pub indexmaxkeys: ::std::os::raw::c_int,
    pub namedatalen: ::std::os::raw::c_int,
    pub float4byval: ::std::os::raw::c_int,
    pub float8byval: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Pg_magic_struct() {
    assert_eq!(
        ::std::mem::size_of::<Pg_magic_struct>(),
        28usize,
        concat!("Size of: ", stringify!(Pg_magic_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<Pg_magic_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(Pg_magic_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pg_magic_struct>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Pg_magic_struct),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pg_magic_struct>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pg_magic_struct),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pg_magic_struct>())).funcmaxargs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pg_magic_struct),
            "::",
            stringify!(funcmaxargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pg_magic_struct>())).indexmaxkeys as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Pg_magic_struct),
            "::",
            stringify!(indexmaxkeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pg_magic_struct>())).namedatalen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Pg_magic_struct),
            "::",
            stringify!(namedatalen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pg_magic_struct>())).float4byval as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Pg_magic_struct),
            "::",
            stringify!(float4byval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pg_magic_struct>())).float8byval as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Pg_magic_struct),
            "::",
            stringify!(float8byval)
        )
    );
}
pub type PGModuleMagicFunction =
    ::std::option::Option<unsafe extern "C" fn() -> *const Pg_magic_struct>;
extern "C" {
    #[link_name = "\u{1}_DirectFunctionCall1Coll"]
    pub fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid, arg1: Datum) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_DirectFunctionCall2Coll"]
    pub fn DirectFunctionCall2Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_DirectFunctionCall3Coll"]
    pub fn DirectFunctionCall3Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_DirectFunctionCall4Coll"]
    pub fn DirectFunctionCall4Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_DirectFunctionCall5Coll"]
    pub fn DirectFunctionCall5Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_DirectFunctionCall6Coll"]
    pub fn DirectFunctionCall6Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_DirectFunctionCall7Coll"]
    pub fn DirectFunctionCall7Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_DirectFunctionCall8Coll"]
    pub fn DirectFunctionCall8Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_DirectFunctionCall9Coll"]
    pub fn DirectFunctionCall9Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_CallerFInfoFunctionCall1"]
    pub fn CallerFInfoFunctionCall1(
        func: PGFunction,
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_CallerFInfoFunctionCall2"]
    pub fn CallerFInfoFunctionCall2(
        func: PGFunction,
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_FunctionCall1Coll"]
    pub fn FunctionCall1Coll(flinfo: *mut FmgrInfo, collation: Oid, arg1: Datum) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_FunctionCall2Coll"]
    pub fn FunctionCall2Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_FunctionCall3Coll"]
    pub fn FunctionCall3Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_FunctionCall4Coll"]
    pub fn FunctionCall4Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_FunctionCall5Coll"]
    pub fn FunctionCall5Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_FunctionCall6Coll"]
    pub fn FunctionCall6Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_FunctionCall7Coll"]
    pub fn FunctionCall7Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_FunctionCall8Coll"]
    pub fn FunctionCall8Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_FunctionCall9Coll"]
    pub fn FunctionCall9Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidFunctionCall0Coll"]
    pub fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidFunctionCall1Coll"]
    pub fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidFunctionCall2Coll"]
    pub fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum)
        -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidFunctionCall3Coll"]
    pub fn OidFunctionCall3Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidFunctionCall4Coll"]
    pub fn OidFunctionCall4Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidFunctionCall5Coll"]
    pub fn OidFunctionCall5Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidFunctionCall6Coll"]
    pub fn OidFunctionCall6Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidFunctionCall7Coll"]
    pub fn OidFunctionCall7Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidFunctionCall8Coll"]
    pub fn OidFunctionCall8Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidFunctionCall9Coll"]
    pub fn OidFunctionCall9Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_InputFunctionCall"]
    pub fn InputFunctionCall(
        flinfo: *mut FmgrInfo,
        str: *mut ::std::os::raw::c_char,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidInputFunctionCall"]
    pub fn OidInputFunctionCall(
        functionId: Oid,
        str: *mut ::std::os::raw::c_char,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OutputFunctionCall"]
    pub fn OutputFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_OidOutputFunctionCall"]
    pub fn OidOutputFunctionCall(functionId: Oid, val: Datum) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ReceiveFunctionCall"]
    pub fn ReceiveFunctionCall(
        flinfo: *mut FmgrInfo,
        buf: fmStringInfo,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_OidReceiveFunctionCall"]
    pub fn OidReceiveFunctionCall(
        functionId: Oid,
        buf: fmStringInfo,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_SendFunctionCall"]
    pub fn SendFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut bytea;
}
extern "C" {
    #[link_name = "\u{1}_OidSendFunctionCall"]
    pub fn OidSendFunctionCall(functionId: Oid, val: Datum) -> *mut bytea;
}
extern "C" {
    #[link_name = "\u{1}_fetch_finfo_record"]
    pub fn fetch_finfo_record(
        filehandle: *mut ::std::os::raw::c_void,
        funcname: *const ::std::os::raw::c_char,
    ) -> *const Pg_finfo_record;
}
extern "C" {
    #[link_name = "\u{1}_clear_external_function_hash"]
    pub fn clear_external_function_hash(filehandle: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_fmgr_internal_function"]
    pub fn fmgr_internal_function(proname: *const ::std::os::raw::c_char) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_get_fn_expr_rettype"]
    pub fn get_fn_expr_rettype(flinfo: *mut FmgrInfo) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_get_fn_expr_argtype"]
    pub fn get_fn_expr_argtype(flinfo: *mut FmgrInfo, argnum: ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_get_call_expr_argtype"]
    pub fn get_call_expr_argtype(expr: fmNodePtr, argnum: ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_get_fn_expr_arg_stable"]
    pub fn get_fn_expr_arg_stable(flinfo: *mut FmgrInfo, argnum: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_get_call_expr_arg_stable"]
    pub fn get_call_expr_arg_stable(expr: fmNodePtr, argnum: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_get_fn_expr_variadic"]
    pub fn get_fn_expr_variadic(flinfo: *mut FmgrInfo) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_CheckFunctionValidatorAccess"]
    pub fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Dynamic_library_path"]
    pub static mut Dynamic_library_path: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_load_external_function"]
    pub fn load_external_function(
        filename: *const ::std::os::raw::c_char,
        funcname: *const ::std::os::raw::c_char,
        signalNotFound: bool,
        filehandle: *mut *mut ::std::os::raw::c_void,
    ) -> PGFunction;
}
extern "C" {
    #[link_name = "\u{1}_lookup_external_function"]
    pub fn lookup_external_function(
        filehandle: *mut ::std::os::raw::c_void,
        funcname: *const ::std::os::raw::c_char,
    ) -> PGFunction;
}
extern "C" {
    #[link_name = "\u{1}_load_file"]
    pub fn load_file(filename: *const ::std::os::raw::c_char, restricted: bool);
}
extern "C" {
    #[link_name = "\u{1}_find_rendezvous_variable"]
    pub fn find_rendezvous_variable(
        varName: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_EstimateLibraryStateSpace"]
    pub fn EstimateLibraryStateSpace() -> Size;
}
extern "C" {
    #[link_name = "\u{1}_SerializeLibraryState"]
    pub fn SerializeLibraryState(maxsize: Size, start_address: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_RestoreLibraryState"]
    pub fn RestoreLibraryState(start_address: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_AggCheckCallContext"]
    pub fn AggCheckCallContext(
        fcinfo: FunctionCallInfo,
        aggcontext: *mut MemoryContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_AggGetAggref"]
    pub fn AggGetAggref(fcinfo: FunctionCallInfo) -> fmAggrefPtr;
}
extern "C" {
    #[link_name = "\u{1}_AggGetTempMemoryContext"]
    pub fn AggGetTempMemoryContext(fcinfo: FunctionCallInfo) -> MemoryContext;
}
extern "C" {
    #[link_name = "\u{1}_AggStateIsShared"]
    pub fn AggStateIsShared(fcinfo: FunctionCallInfo) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_AggRegisterCallback"]
    pub fn AggRegisterCallback(
        fcinfo: FunctionCallInfo,
        func: fmExprContextCallbackFunction,
        arg: Datum,
    );
}
pub const FmgrHookEventType_FHET_START: FmgrHookEventType = 0;
pub const FmgrHookEventType_FHET_END: FmgrHookEventType = 1;
pub const FmgrHookEventType_FHET_ABORT: FmgrHookEventType = 2;
pub type FmgrHookEventType = u32;
pub type needs_fmgr_hook_type = ::std::option::Option<unsafe extern "C" fn(fn_oid: Oid) -> bool>;
pub type fmgr_hook_type = ::std::option::Option<
    unsafe extern "C" fn(event: FmgrHookEventType, flinfo: *mut FmgrInfo, arg: *mut Datum),
>;
extern "C" {
    #[link_name = "\u{1}_needs_fmgr_hook"]
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
}
extern "C" {
    #[link_name = "\u{1}_fmgr_hook"]
    pub static mut fmgr_hook: fmgr_hook_type;
}
pub const NodeTag_T_Invalid: NodeTag = 0;
pub const NodeTag_T_IndexInfo: NodeTag = 1;
pub const NodeTag_T_ExprContext: NodeTag = 2;
pub const NodeTag_T_ProjectionInfo: NodeTag = 3;
pub const NodeTag_T_JunkFilter: NodeTag = 4;
pub const NodeTag_T_OnConflictSetState: NodeTag = 5;
pub const NodeTag_T_ResultRelInfo: NodeTag = 6;
pub const NodeTag_T_EState: NodeTag = 7;
pub const NodeTag_T_TupleTableSlot: NodeTag = 8;
pub const NodeTag_T_Plan: NodeTag = 9;
pub const NodeTag_T_Result: NodeTag = 10;
pub const NodeTag_T_ProjectSet: NodeTag = 11;
pub const NodeTag_T_ModifyTable: NodeTag = 12;
pub const NodeTag_T_Append: NodeTag = 13;
pub const NodeTag_T_MergeAppend: NodeTag = 14;
pub const NodeTag_T_RecursiveUnion: NodeTag = 15;
pub const NodeTag_T_BitmapAnd: NodeTag = 16;
pub const NodeTag_T_BitmapOr: NodeTag = 17;
pub const NodeTag_T_Scan: NodeTag = 18;
pub const NodeTag_T_SeqScan: NodeTag = 19;
pub const NodeTag_T_SampleScan: NodeTag = 20;
pub const NodeTag_T_IndexScan: NodeTag = 21;
pub const NodeTag_T_IndexOnlyScan: NodeTag = 22;
pub const NodeTag_T_BitmapIndexScan: NodeTag = 23;
pub const NodeTag_T_BitmapHeapScan: NodeTag = 24;
pub const NodeTag_T_TidScan: NodeTag = 25;
pub const NodeTag_T_SubqueryScan: NodeTag = 26;
pub const NodeTag_T_FunctionScan: NodeTag = 27;
pub const NodeTag_T_ValuesScan: NodeTag = 28;
pub const NodeTag_T_TableFuncScan: NodeTag = 29;
pub const NodeTag_T_CteScan: NodeTag = 30;
pub const NodeTag_T_NamedTuplestoreScan: NodeTag = 31;
pub const NodeTag_T_WorkTableScan: NodeTag = 32;
pub const NodeTag_T_ForeignScan: NodeTag = 33;
pub const NodeTag_T_CustomScan: NodeTag = 34;
pub const NodeTag_T_Join: NodeTag = 35;
pub const NodeTag_T_NestLoop: NodeTag = 36;
pub const NodeTag_T_MergeJoin: NodeTag = 37;
pub const NodeTag_T_HashJoin: NodeTag = 38;
pub const NodeTag_T_Material: NodeTag = 39;
pub const NodeTag_T_Sort: NodeTag = 40;
pub const NodeTag_T_Group: NodeTag = 41;
pub const NodeTag_T_Agg: NodeTag = 42;
pub const NodeTag_T_WindowAgg: NodeTag = 43;
pub const NodeTag_T_Unique: NodeTag = 44;
pub const NodeTag_T_Gather: NodeTag = 45;
pub const NodeTag_T_GatherMerge: NodeTag = 46;
pub const NodeTag_T_Hash: NodeTag = 47;
pub const NodeTag_T_SetOp: NodeTag = 48;
pub const NodeTag_T_LockRows: NodeTag = 49;
pub const NodeTag_T_Limit: NodeTag = 50;
pub const NodeTag_T_NestLoopParam: NodeTag = 51;
pub const NodeTag_T_PlanRowMark: NodeTag = 52;
pub const NodeTag_T_PartitionPruneInfo: NodeTag = 53;
pub const NodeTag_T_PartitionedRelPruneInfo: NodeTag = 54;
pub const NodeTag_T_PartitionPruneStepOp: NodeTag = 55;
pub const NodeTag_T_PartitionPruneStepCombine: NodeTag = 56;
pub const NodeTag_T_PlanInvalItem: NodeTag = 57;
pub const NodeTag_T_PlanState: NodeTag = 58;
pub const NodeTag_T_ResultState: NodeTag = 59;
pub const NodeTag_T_ProjectSetState: NodeTag = 60;
pub const NodeTag_T_ModifyTableState: NodeTag = 61;
pub const NodeTag_T_AppendState: NodeTag = 62;
pub const NodeTag_T_MergeAppendState: NodeTag = 63;
pub const NodeTag_T_RecursiveUnionState: NodeTag = 64;
pub const NodeTag_T_BitmapAndState: NodeTag = 65;
pub const NodeTag_T_BitmapOrState: NodeTag = 66;
pub const NodeTag_T_ScanState: NodeTag = 67;
pub const NodeTag_T_SeqScanState: NodeTag = 68;
pub const NodeTag_T_SampleScanState: NodeTag = 69;
pub const NodeTag_T_IndexScanState: NodeTag = 70;
pub const NodeTag_T_IndexOnlyScanState: NodeTag = 71;
pub const NodeTag_T_BitmapIndexScanState: NodeTag = 72;
pub const NodeTag_T_BitmapHeapScanState: NodeTag = 73;
pub const NodeTag_T_TidScanState: NodeTag = 74;
pub const NodeTag_T_SubqueryScanState: NodeTag = 75;
pub const NodeTag_T_FunctionScanState: NodeTag = 76;
pub const NodeTag_T_TableFuncScanState: NodeTag = 77;
pub const NodeTag_T_ValuesScanState: NodeTag = 78;
pub const NodeTag_T_CteScanState: NodeTag = 79;
pub const NodeTag_T_NamedTuplestoreScanState: NodeTag = 80;
pub const NodeTag_T_WorkTableScanState: NodeTag = 81;
pub const NodeTag_T_ForeignScanState: NodeTag = 82;
pub const NodeTag_T_CustomScanState: NodeTag = 83;
pub const NodeTag_T_JoinState: NodeTag = 84;
pub const NodeTag_T_NestLoopState: NodeTag = 85;
pub const NodeTag_T_MergeJoinState: NodeTag = 86;
pub const NodeTag_T_HashJoinState: NodeTag = 87;
pub const NodeTag_T_MaterialState: NodeTag = 88;
pub const NodeTag_T_SortState: NodeTag = 89;
pub const NodeTag_T_GroupState: NodeTag = 90;
pub const NodeTag_T_AggState: NodeTag = 91;
pub const NodeTag_T_WindowAggState: NodeTag = 92;
pub const NodeTag_T_UniqueState: NodeTag = 93;
pub const NodeTag_T_GatherState: NodeTag = 94;
pub const NodeTag_T_GatherMergeState: NodeTag = 95;
pub const NodeTag_T_HashState: NodeTag = 96;
pub const NodeTag_T_SetOpState: NodeTag = 97;
pub const NodeTag_T_LockRowsState: NodeTag = 98;
pub const NodeTag_T_LimitState: NodeTag = 99;
pub const NodeTag_T_Alias: NodeTag = 100;
pub const NodeTag_T_RangeVar: NodeTag = 101;
pub const NodeTag_T_TableFunc: NodeTag = 102;
pub const NodeTag_T_Expr: NodeTag = 103;
pub const NodeTag_T_Var: NodeTag = 104;
pub const NodeTag_T_Const: NodeTag = 105;
pub const NodeTag_T_Param: NodeTag = 106;
pub const NodeTag_T_Aggref: NodeTag = 107;
pub const NodeTag_T_GroupingFunc: NodeTag = 108;
pub const NodeTag_T_WindowFunc: NodeTag = 109;
pub const NodeTag_T_ArrayRef: NodeTag = 110;
pub const NodeTag_T_FuncExpr: NodeTag = 111;
pub const NodeTag_T_NamedArgExpr: NodeTag = 112;
pub const NodeTag_T_OpExpr: NodeTag = 113;
pub const NodeTag_T_DistinctExpr: NodeTag = 114;
pub const NodeTag_T_NullIfExpr: NodeTag = 115;
pub const NodeTag_T_ScalarArrayOpExpr: NodeTag = 116;
pub const NodeTag_T_BoolExpr: NodeTag = 117;
pub const NodeTag_T_SubLink: NodeTag = 118;
pub const NodeTag_T_SubPlan: NodeTag = 119;
pub const NodeTag_T_AlternativeSubPlan: NodeTag = 120;
pub const NodeTag_T_FieldSelect: NodeTag = 121;
pub const NodeTag_T_FieldStore: NodeTag = 122;
pub const NodeTag_T_RelabelType: NodeTag = 123;
pub const NodeTag_T_CoerceViaIO: NodeTag = 124;
pub const NodeTag_T_ArrayCoerceExpr: NodeTag = 125;
pub const NodeTag_T_ConvertRowtypeExpr: NodeTag = 126;
pub const NodeTag_T_CollateExpr: NodeTag = 127;
pub const NodeTag_T_CaseExpr: NodeTag = 128;
pub const NodeTag_T_CaseWhen: NodeTag = 129;
pub const NodeTag_T_CaseTestExpr: NodeTag = 130;
pub const NodeTag_T_ArrayExpr: NodeTag = 131;
pub const NodeTag_T_RowExpr: NodeTag = 132;
pub const NodeTag_T_RowCompareExpr: NodeTag = 133;
pub const NodeTag_T_CoalesceExpr: NodeTag = 134;
pub const NodeTag_T_MinMaxExpr: NodeTag = 135;
pub const NodeTag_T_SQLValueFunction: NodeTag = 136;
pub const NodeTag_T_XmlExpr: NodeTag = 137;
pub const NodeTag_T_NullTest: NodeTag = 138;
pub const NodeTag_T_BooleanTest: NodeTag = 139;
pub const NodeTag_T_CoerceToDomain: NodeTag = 140;
pub const NodeTag_T_CoerceToDomainValue: NodeTag = 141;
pub const NodeTag_T_SetToDefault: NodeTag = 142;
pub const NodeTag_T_CurrentOfExpr: NodeTag = 143;
pub const NodeTag_T_NextValueExpr: NodeTag = 144;
pub const NodeTag_T_InferenceElem: NodeTag = 145;
pub const NodeTag_T_TargetEntry: NodeTag = 146;
pub const NodeTag_T_RangeTblRef: NodeTag = 147;
pub const NodeTag_T_JoinExpr: NodeTag = 148;
pub const NodeTag_T_FromExpr: NodeTag = 149;
pub const NodeTag_T_OnConflictExpr: NodeTag = 150;
pub const NodeTag_T_IntoClause: NodeTag = 151;
pub const NodeTag_T_ExprState: NodeTag = 152;
pub const NodeTag_T_AggrefExprState: NodeTag = 153;
pub const NodeTag_T_WindowFuncExprState: NodeTag = 154;
pub const NodeTag_T_SetExprState: NodeTag = 155;
pub const NodeTag_T_SubPlanState: NodeTag = 156;
pub const NodeTag_T_AlternativeSubPlanState: NodeTag = 157;
pub const NodeTag_T_DomainConstraintState: NodeTag = 158;
pub const NodeTag_T_PlannerInfo: NodeTag = 159;
pub const NodeTag_T_PlannerGlobal: NodeTag = 160;
pub const NodeTag_T_RelOptInfo: NodeTag = 161;
pub const NodeTag_T_IndexOptInfo: NodeTag = 162;
pub const NodeTag_T_ForeignKeyOptInfo: NodeTag = 163;
pub const NodeTag_T_ParamPathInfo: NodeTag = 164;
pub const NodeTag_T_Path: NodeTag = 165;
pub const NodeTag_T_IndexPath: NodeTag = 166;
pub const NodeTag_T_BitmapHeapPath: NodeTag = 167;
pub const NodeTag_T_BitmapAndPath: NodeTag = 168;
pub const NodeTag_T_BitmapOrPath: NodeTag = 169;
pub const NodeTag_T_TidPath: NodeTag = 170;
pub const NodeTag_T_SubqueryScanPath: NodeTag = 171;
pub const NodeTag_T_ForeignPath: NodeTag = 172;
pub const NodeTag_T_CustomPath: NodeTag = 173;
pub const NodeTag_T_NestPath: NodeTag = 174;
pub const NodeTag_T_MergePath: NodeTag = 175;
pub const NodeTag_T_HashPath: NodeTag = 176;
pub const NodeTag_T_AppendPath: NodeTag = 177;
pub const NodeTag_T_MergeAppendPath: NodeTag = 178;
pub const NodeTag_T_ResultPath: NodeTag = 179;
pub const NodeTag_T_MaterialPath: NodeTag = 180;
pub const NodeTag_T_UniquePath: NodeTag = 181;
pub const NodeTag_T_GatherPath: NodeTag = 182;
pub const NodeTag_T_GatherMergePath: NodeTag = 183;
pub const NodeTag_T_ProjectionPath: NodeTag = 184;
pub const NodeTag_T_ProjectSetPath: NodeTag = 185;
pub const NodeTag_T_SortPath: NodeTag = 186;
pub const NodeTag_T_GroupPath: NodeTag = 187;
pub const NodeTag_T_UpperUniquePath: NodeTag = 188;
pub const NodeTag_T_AggPath: NodeTag = 189;
pub const NodeTag_T_GroupingSetsPath: NodeTag = 190;
pub const NodeTag_T_MinMaxAggPath: NodeTag = 191;
pub const NodeTag_T_WindowAggPath: NodeTag = 192;
pub const NodeTag_T_SetOpPath: NodeTag = 193;
pub const NodeTag_T_RecursiveUnionPath: NodeTag = 194;
pub const NodeTag_T_LockRowsPath: NodeTag = 195;
pub const NodeTag_T_ModifyTablePath: NodeTag = 196;
pub const NodeTag_T_LimitPath: NodeTag = 197;
pub const NodeTag_T_EquivalenceClass: NodeTag = 198;
pub const NodeTag_T_EquivalenceMember: NodeTag = 199;
pub const NodeTag_T_PathKey: NodeTag = 200;
pub const NodeTag_T_PathTarget: NodeTag = 201;
pub const NodeTag_T_RestrictInfo: NodeTag = 202;
pub const NodeTag_T_PlaceHolderVar: NodeTag = 203;
pub const NodeTag_T_SpecialJoinInfo: NodeTag = 204;
pub const NodeTag_T_AppendRelInfo: NodeTag = 205;
pub const NodeTag_T_PlaceHolderInfo: NodeTag = 206;
pub const NodeTag_T_MinMaxAggInfo: NodeTag = 207;
pub const NodeTag_T_PlannerParamItem: NodeTag = 208;
pub const NodeTag_T_RollupData: NodeTag = 209;
pub const NodeTag_T_GroupingSetData: NodeTag = 210;
pub const NodeTag_T_StatisticExtInfo: NodeTag = 211;
pub const NodeTag_T_MemoryContext: NodeTag = 212;
pub const NodeTag_T_AllocSetContext: NodeTag = 213;
pub const NodeTag_T_SlabContext: NodeTag = 214;
pub const NodeTag_T_GenerationContext: NodeTag = 215;
pub const NodeTag_T_Value: NodeTag = 216;
pub const NodeTag_T_Integer: NodeTag = 217;
pub const NodeTag_T_Float: NodeTag = 218;
pub const NodeTag_T_String: NodeTag = 219;
pub const NodeTag_T_BitString: NodeTag = 220;
pub const NodeTag_T_Null: NodeTag = 221;
pub const NodeTag_T_List: NodeTag = 222;
pub const NodeTag_T_IntList: NodeTag = 223;
pub const NodeTag_T_OidList: NodeTag = 224;
pub const NodeTag_T_ExtensibleNode: NodeTag = 225;
pub const NodeTag_T_RawStmt: NodeTag = 226;
pub const NodeTag_T_Query: NodeTag = 227;
pub const NodeTag_T_PlannedStmt: NodeTag = 228;
pub const NodeTag_T_InsertStmt: NodeTag = 229;
pub const NodeTag_T_DeleteStmt: NodeTag = 230;
pub const NodeTag_T_UpdateStmt: NodeTag = 231;
pub const NodeTag_T_SelectStmt: NodeTag = 232;
pub const NodeTag_T_AlterTableStmt: NodeTag = 233;
pub const NodeTag_T_AlterTableCmd: NodeTag = 234;
pub const NodeTag_T_AlterDomainStmt: NodeTag = 235;
pub const NodeTag_T_SetOperationStmt: NodeTag = 236;
pub const NodeTag_T_GrantStmt: NodeTag = 237;
pub const NodeTag_T_GrantRoleStmt: NodeTag = 238;
pub const NodeTag_T_AlterDefaultPrivilegesStmt: NodeTag = 239;
pub const NodeTag_T_ClosePortalStmt: NodeTag = 240;
pub const NodeTag_T_ClusterStmt: NodeTag = 241;
pub const NodeTag_T_CopyStmt: NodeTag = 242;
pub const NodeTag_T_CreateStmt: NodeTag = 243;
pub const NodeTag_T_DefineStmt: NodeTag = 244;
pub const NodeTag_T_DropStmt: NodeTag = 245;
pub const NodeTag_T_TruncateStmt: NodeTag = 246;
pub const NodeTag_T_CommentStmt: NodeTag = 247;
pub const NodeTag_T_FetchStmt: NodeTag = 248;
pub const NodeTag_T_IndexStmt: NodeTag = 249;
pub const NodeTag_T_CreateFunctionStmt: NodeTag = 250;
pub const NodeTag_T_AlterFunctionStmt: NodeTag = 251;
pub const NodeTag_T_DoStmt: NodeTag = 252;
pub const NodeTag_T_RenameStmt: NodeTag = 253;
pub const NodeTag_T_RuleStmt: NodeTag = 254;
pub const NodeTag_T_NotifyStmt: NodeTag = 255;
pub const NodeTag_T_ListenStmt: NodeTag = 256;
pub const NodeTag_T_UnlistenStmt: NodeTag = 257;
pub const NodeTag_T_TransactionStmt: NodeTag = 258;
pub const NodeTag_T_ViewStmt: NodeTag = 259;
pub const NodeTag_T_LoadStmt: NodeTag = 260;
pub const NodeTag_T_CreateDomainStmt: NodeTag = 261;
pub const NodeTag_T_CreatedbStmt: NodeTag = 262;
pub const NodeTag_T_DropdbStmt: NodeTag = 263;
pub const NodeTag_T_VacuumStmt: NodeTag = 264;
pub const NodeTag_T_ExplainStmt: NodeTag = 265;
pub const NodeTag_T_CreateTableAsStmt: NodeTag = 266;
pub const NodeTag_T_CreateSeqStmt: NodeTag = 267;
pub const NodeTag_T_AlterSeqStmt: NodeTag = 268;
pub const NodeTag_T_VariableSetStmt: NodeTag = 269;
pub const NodeTag_T_VariableShowStmt: NodeTag = 270;
pub const NodeTag_T_DiscardStmt: NodeTag = 271;
pub const NodeTag_T_CreateTrigStmt: NodeTag = 272;
pub const NodeTag_T_CreatePLangStmt: NodeTag = 273;
pub const NodeTag_T_CreateRoleStmt: NodeTag = 274;
pub const NodeTag_T_AlterRoleStmt: NodeTag = 275;
pub const NodeTag_T_DropRoleStmt: NodeTag = 276;
pub const NodeTag_T_LockStmt: NodeTag = 277;
pub const NodeTag_T_ConstraintsSetStmt: NodeTag = 278;
pub const NodeTag_T_ReindexStmt: NodeTag = 279;
pub const NodeTag_T_CheckPointStmt: NodeTag = 280;
pub const NodeTag_T_CreateSchemaStmt: NodeTag = 281;
pub const NodeTag_T_AlterDatabaseStmt: NodeTag = 282;
pub const NodeTag_T_AlterDatabaseSetStmt: NodeTag = 283;
pub const NodeTag_T_AlterRoleSetStmt: NodeTag = 284;
pub const NodeTag_T_CreateConversionStmt: NodeTag = 285;
pub const NodeTag_T_CreateCastStmt: NodeTag = 286;
pub const NodeTag_T_CreateOpClassStmt: NodeTag = 287;
pub const NodeTag_T_CreateOpFamilyStmt: NodeTag = 288;
pub const NodeTag_T_AlterOpFamilyStmt: NodeTag = 289;
pub const NodeTag_T_PrepareStmt: NodeTag = 290;
pub const NodeTag_T_ExecuteStmt: NodeTag = 291;
pub const NodeTag_T_DeallocateStmt: NodeTag = 292;
pub const NodeTag_T_DeclareCursorStmt: NodeTag = 293;
pub const NodeTag_T_CreateTableSpaceStmt: NodeTag = 294;
pub const NodeTag_T_DropTableSpaceStmt: NodeTag = 295;
pub const NodeTag_T_AlterObjectDependsStmt: NodeTag = 296;
pub const NodeTag_T_AlterObjectSchemaStmt: NodeTag = 297;
pub const NodeTag_T_AlterOwnerStmt: NodeTag = 298;
pub const NodeTag_T_AlterOperatorStmt: NodeTag = 299;
pub const NodeTag_T_DropOwnedStmt: NodeTag = 300;
pub const NodeTag_T_ReassignOwnedStmt: NodeTag = 301;
pub const NodeTag_T_CompositeTypeStmt: NodeTag = 302;
pub const NodeTag_T_CreateEnumStmt: NodeTag = 303;
pub const NodeTag_T_CreateRangeStmt: NodeTag = 304;
pub const NodeTag_T_AlterEnumStmt: NodeTag = 305;
pub const NodeTag_T_AlterTSDictionaryStmt: NodeTag = 306;
pub const NodeTag_T_AlterTSConfigurationStmt: NodeTag = 307;
pub const NodeTag_T_CreateFdwStmt: NodeTag = 308;
pub const NodeTag_T_AlterFdwStmt: NodeTag = 309;
pub const NodeTag_T_CreateForeignServerStmt: NodeTag = 310;
pub const NodeTag_T_AlterForeignServerStmt: NodeTag = 311;
pub const NodeTag_T_CreateUserMappingStmt: NodeTag = 312;
pub const NodeTag_T_AlterUserMappingStmt: NodeTag = 313;
pub const NodeTag_T_DropUserMappingStmt: NodeTag = 314;
pub const NodeTag_T_AlterTableSpaceOptionsStmt: NodeTag = 315;
pub const NodeTag_T_AlterTableMoveAllStmt: NodeTag = 316;
pub const NodeTag_T_SecLabelStmt: NodeTag = 317;
pub const NodeTag_T_CreateForeignTableStmt: NodeTag = 318;
pub const NodeTag_T_ImportForeignSchemaStmt: NodeTag = 319;
pub const NodeTag_T_CreateExtensionStmt: NodeTag = 320;
pub const NodeTag_T_AlterExtensionStmt: NodeTag = 321;
pub const NodeTag_T_AlterExtensionContentsStmt: NodeTag = 322;
pub const NodeTag_T_CreateEventTrigStmt: NodeTag = 323;
pub const NodeTag_T_AlterEventTrigStmt: NodeTag = 324;
pub const NodeTag_T_RefreshMatViewStmt: NodeTag = 325;
pub const NodeTag_T_ReplicaIdentityStmt: NodeTag = 326;
pub const NodeTag_T_AlterSystemStmt: NodeTag = 327;
pub const NodeTag_T_CreatePolicyStmt: NodeTag = 328;
pub const NodeTag_T_AlterPolicyStmt: NodeTag = 329;
pub const NodeTag_T_CreateTransformStmt: NodeTag = 330;
pub const NodeTag_T_CreateAmStmt: NodeTag = 331;
pub const NodeTag_T_CreatePublicationStmt: NodeTag = 332;
pub const NodeTag_T_AlterPublicationStmt: NodeTag = 333;
pub const NodeTag_T_CreateSubscriptionStmt: NodeTag = 334;
pub const NodeTag_T_AlterSubscriptionStmt: NodeTag = 335;
pub const NodeTag_T_DropSubscriptionStmt: NodeTag = 336;
pub const NodeTag_T_CreateStatsStmt: NodeTag = 337;
pub const NodeTag_T_AlterCollationStmt: NodeTag = 338;
pub const NodeTag_T_CallStmt: NodeTag = 339;
pub const NodeTag_T_A_Expr: NodeTag = 340;
pub const NodeTag_T_ColumnRef: NodeTag = 341;
pub const NodeTag_T_ParamRef: NodeTag = 342;
pub const NodeTag_T_A_Const: NodeTag = 343;
pub const NodeTag_T_FuncCall: NodeTag = 344;
pub const NodeTag_T_A_Star: NodeTag = 345;
pub const NodeTag_T_A_Indices: NodeTag = 346;
pub const NodeTag_T_A_Indirection: NodeTag = 347;
pub const NodeTag_T_A_ArrayExpr: NodeTag = 348;
pub const NodeTag_T_ResTarget: NodeTag = 349;
pub const NodeTag_T_MultiAssignRef: NodeTag = 350;
pub const NodeTag_T_TypeCast: NodeTag = 351;
pub const NodeTag_T_CollateClause: NodeTag = 352;
pub const NodeTag_T_SortBy: NodeTag = 353;
pub const NodeTag_T_WindowDef: NodeTag = 354;
pub const NodeTag_T_RangeSubselect: NodeTag = 355;
pub const NodeTag_T_RangeFunction: NodeTag = 356;
pub const NodeTag_T_RangeTableSample: NodeTag = 357;
pub const NodeTag_T_RangeTableFunc: NodeTag = 358;
pub const NodeTag_T_RangeTableFuncCol: NodeTag = 359;
pub const NodeTag_T_TypeName: NodeTag = 360;
pub const NodeTag_T_ColumnDef: NodeTag = 361;
pub const NodeTag_T_IndexElem: NodeTag = 362;
pub const NodeTag_T_Constraint: NodeTag = 363;
pub const NodeTag_T_DefElem: NodeTag = 364;
pub const NodeTag_T_RangeTblEntry: NodeTag = 365;
pub const NodeTag_T_RangeTblFunction: NodeTag = 366;
pub const NodeTag_T_TableSampleClause: NodeTag = 367;
pub const NodeTag_T_WithCheckOption: NodeTag = 368;
pub const NodeTag_T_SortGroupClause: NodeTag = 369;
pub const NodeTag_T_GroupingSet: NodeTag = 370;
pub const NodeTag_T_WindowClause: NodeTag = 371;
pub const NodeTag_T_ObjectWithArgs: NodeTag = 372;
pub const NodeTag_T_AccessPriv: NodeTag = 373;
pub const NodeTag_T_CreateOpClassItem: NodeTag = 374;
pub const NodeTag_T_TableLikeClause: NodeTag = 375;
pub const NodeTag_T_FunctionParameter: NodeTag = 376;
pub const NodeTag_T_LockingClause: NodeTag = 377;
pub const NodeTag_T_RowMarkClause: NodeTag = 378;
pub const NodeTag_T_XmlSerialize: NodeTag = 379;
pub const NodeTag_T_WithClause: NodeTag = 380;
pub const NodeTag_T_InferClause: NodeTag = 381;
pub const NodeTag_T_OnConflictClause: NodeTag = 382;
pub const NodeTag_T_CommonTableExpr: NodeTag = 383;
pub const NodeTag_T_RoleSpec: NodeTag = 384;
pub const NodeTag_T_TriggerTransition: NodeTag = 385;
pub const NodeTag_T_PartitionElem: NodeTag = 386;
pub const NodeTag_T_PartitionSpec: NodeTag = 387;
pub const NodeTag_T_PartitionBoundSpec: NodeTag = 388;
pub const NodeTag_T_PartitionRangeDatum: NodeTag = 389;
pub const NodeTag_T_PartitionCmd: NodeTag = 390;
pub const NodeTag_T_VacuumRelation: NodeTag = 391;
pub const NodeTag_T_IdentifySystemCmd: NodeTag = 392;
pub const NodeTag_T_BaseBackupCmd: NodeTag = 393;
pub const NodeTag_T_CreateReplicationSlotCmd: NodeTag = 394;
pub const NodeTag_T_DropReplicationSlotCmd: NodeTag = 395;
pub const NodeTag_T_StartReplicationCmd: NodeTag = 396;
pub const NodeTag_T_TimeLineHistoryCmd: NodeTag = 397;
pub const NodeTag_T_SQLCmd: NodeTag = 398;
pub const NodeTag_T_TriggerData: NodeTag = 399;
pub const NodeTag_T_EventTriggerData: NodeTag = 400;
pub const NodeTag_T_ReturnSetInfo: NodeTag = 401;
pub const NodeTag_T_WindowObjectData: NodeTag = 402;
pub const NodeTag_T_TIDBitmap: NodeTag = 403;
pub const NodeTag_T_InlineCodeBlock: NodeTag = 404;
pub const NodeTag_T_FdwRoutine: NodeTag = 405;
pub const NodeTag_T_IndexAmRoutine: NodeTag = 406;
pub const NodeTag_T_TsmRoutine: NodeTag = 407;
pub const NodeTag_T_ForeignKeyCacheInfo: NodeTag = 408;
pub const NodeTag_T_CallContext: NodeTag = 409;
pub type NodeTag = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Node {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_Node() {
    assert_eq!(
        ::std::mem::size_of::<Node>(),
        4usize,
        concat!("Size of: ", stringify!(Node))
    );
    assert_eq!(
        ::std::mem::align_of::<Node>(),
        4usize,
        concat!("Alignment of ", stringify!(Node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Node>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Node),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_outNode"]
    pub fn outNode(str: *mut StringInfoData, obj: *const ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_outToken"]
    pub fn outToken(str: *mut StringInfoData, s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_outBitmapset"]
    pub fn outBitmapset(str: *mut StringInfoData, bms: *const Bitmapset);
}
extern "C" {
    #[link_name = "\u{1}_outDatum"]
    pub fn outDatum(
        str: *mut StringInfoData,
        value: usize,
        typlen: ::std::os::raw::c_int,
        typbyval: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_nodeToString"]
    pub fn nodeToString(obj: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_bmsToString"]
    pub fn bmsToString(bms: *const Bitmapset) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_stringToNode"]
    pub fn stringToNode(str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_readBitmapset"]
    pub fn readBitmapset() -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_readDatum"]
    pub fn readDatum(typbyval: bool) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_readBoolCols"]
    pub fn readBoolCols(numCols: ::std::os::raw::c_int) -> *mut bool;
}
extern "C" {
    #[link_name = "\u{1}_readIntCols"]
    pub fn readIntCols(numCols: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_readOidCols"]
    pub fn readOidCols(numCols: ::std::os::raw::c_int) -> *mut Oid;
}
extern "C" {
    #[link_name = "\u{1}_readAttrNumberCols"]
    pub fn readAttrNumberCols(numCols: ::std::os::raw::c_int) -> *mut int16;
}
extern "C" {
    #[link_name = "\u{1}_copyObjectImpl"]
    pub fn copyObjectImpl(obj: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_equal"]
    pub fn equal(a: *const ::std::os::raw::c_void, b: *const ::std::os::raw::c_void) -> bool;
}
pub type Selectivity = f64;
pub type Cost = f64;
pub const CmdType_CMD_UNKNOWN: CmdType = 0;
pub const CmdType_CMD_SELECT: CmdType = 1;
pub const CmdType_CMD_UPDATE: CmdType = 2;
pub const CmdType_CMD_INSERT: CmdType = 3;
pub const CmdType_CMD_DELETE: CmdType = 4;
pub const CmdType_CMD_UTILITY: CmdType = 5;
pub const CmdType_CMD_NOTHING: CmdType = 6;
pub type CmdType = u32;
pub const JoinType_JOIN_INNER: JoinType = 0;
pub const JoinType_JOIN_LEFT: JoinType = 1;
pub const JoinType_JOIN_FULL: JoinType = 2;
pub const JoinType_JOIN_RIGHT: JoinType = 3;
pub const JoinType_JOIN_SEMI: JoinType = 4;
pub const JoinType_JOIN_ANTI: JoinType = 5;
pub const JoinType_JOIN_UNIQUE_OUTER: JoinType = 6;
pub const JoinType_JOIN_UNIQUE_INNER: JoinType = 7;
pub type JoinType = u32;
pub const AggStrategy_AGG_PLAIN: AggStrategy = 0;
pub const AggStrategy_AGG_SORTED: AggStrategy = 1;
pub const AggStrategy_AGG_HASHED: AggStrategy = 2;
pub const AggStrategy_AGG_MIXED: AggStrategy = 3;
pub type AggStrategy = u32;
pub const AggSplit_AGGSPLIT_SIMPLE: AggSplit = 0;
pub const AggSplit_AGGSPLIT_INITIAL_SERIAL: AggSplit = 6;
pub const AggSplit_AGGSPLIT_FINAL_DESERIAL: AggSplit = 9;
pub type AggSplit = u32;
pub const SetOpCmd_SETOPCMD_INTERSECT: SetOpCmd = 0;
pub const SetOpCmd_SETOPCMD_INTERSECT_ALL: SetOpCmd = 1;
pub const SetOpCmd_SETOPCMD_EXCEPT: SetOpCmd = 2;
pub const SetOpCmd_SETOPCMD_EXCEPT_ALL: SetOpCmd = 3;
pub type SetOpCmd = u32;
pub const SetOpStrategy_SETOP_SORTED: SetOpStrategy = 0;
pub const SetOpStrategy_SETOP_HASHED: SetOpStrategy = 1;
pub type SetOpStrategy = u32;
pub const OnConflictAction_ONCONFLICT_NONE: OnConflictAction = 0;
pub const OnConflictAction_ONCONFLICT_NOTHING: OnConflictAction = 1;
pub const OnConflictAction_ONCONFLICT_UPDATE: OnConflictAction = 2;
pub type OnConflictAction = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct List {
    pub type_: NodeTag,
    pub length: ::std::os::raw::c_int,
    pub head: *mut ListCell,
    pub tail: *mut ListCell,
}
#[test]
fn bindgen_test_layout_List() {
    assert_eq!(
        ::std::mem::size_of::<List>(),
        24usize,
        concat!("Size of: ", stringify!(List))
    );
    assert_eq!(
        ::std::mem::align_of::<List>(),
        8usize,
        concat!("Alignment of ", stringify!(List))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<List>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(List),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<List>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(List),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<List>())).head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(List),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<List>())).tail as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(List),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ListCell {
    pub data: ListCell__bindgen_ty_1,
    pub next: *mut ListCell,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ListCell__bindgen_ty_1 {
    pub ptr_value: *mut ::std::os::raw::c_void,
    pub int_value: ::std::os::raw::c_int,
    pub oid_value: Oid,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ListCell__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ListCell__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ListCell__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ListCell__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ListCell__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ListCell__bindgen_ty_1>())).ptr_value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ListCell__bindgen_ty_1),
            "::",
            stringify!(ptr_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ListCell__bindgen_ty_1>())).int_value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ListCell__bindgen_ty_1),
            "::",
            stringify!(int_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ListCell__bindgen_ty_1>())).oid_value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ListCell__bindgen_ty_1),
            "::",
            stringify!(oid_value)
        )
    );
}
#[test]
fn bindgen_test_layout_ListCell() {
    assert_eq!(
        ::std::mem::size_of::<ListCell>(),
        16usize,
        concat!("Size of: ", stringify!(ListCell))
    );
    assert_eq!(
        ::std::mem::align_of::<ListCell>(),
        8usize,
        concat!("Alignment of ", stringify!(ListCell))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ListCell>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ListCell),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ListCell>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ListCell),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_lappend"]
    pub fn lappend(list: *mut List, datum: *mut ::std::os::raw::c_void) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_lappend_int"]
    pub fn lappend_int(list: *mut List, datum: ::std::os::raw::c_int) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_lappend_oid"]
    pub fn lappend_oid(list: *mut List, datum: Oid) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_lappend_cell"]
    pub fn lappend_cell(
        list: *mut List,
        prev: *mut ListCell,
        datum: *mut ::std::os::raw::c_void,
    ) -> *mut ListCell;
}
extern "C" {
    #[link_name = "\u{1}_lappend_cell_int"]
    pub fn lappend_cell_int(
        list: *mut List,
        prev: *mut ListCell,
        datum: ::std::os::raw::c_int,
    ) -> *mut ListCell;
}
extern "C" {
    #[link_name = "\u{1}_lappend_cell_oid"]
    pub fn lappend_cell_oid(list: *mut List, prev: *mut ListCell, datum: Oid) -> *mut ListCell;
}
extern "C" {
    #[link_name = "\u{1}_lcons"]
    pub fn lcons(datum: *mut ::std::os::raw::c_void, list: *mut List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_lcons_int"]
    pub fn lcons_int(datum: ::std::os::raw::c_int, list: *mut List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_lcons_oid"]
    pub fn lcons_oid(datum: Oid, list: *mut List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_concat"]
    pub fn list_concat(list1: *mut List, list2: *mut List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_truncate"]
    pub fn list_truncate(list: *mut List, new_size: ::std::os::raw::c_int) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_nth_cell"]
    pub fn list_nth_cell(list: *const List, n: ::std::os::raw::c_int) -> *mut ListCell;
}
extern "C" {
    #[link_name = "\u{1}_list_nth"]
    pub fn list_nth(list: *const List, n: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_list_nth_int"]
    pub fn list_nth_int(list: *const List, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_list_nth_oid"]
    pub fn list_nth_oid(list: *const List, n: ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_list_member"]
    pub fn list_member(list: *const List, datum: *const ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_list_member_ptr"]
    pub fn list_member_ptr(list: *const List, datum: *const ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_list_member_int"]
    pub fn list_member_int(list: *const List, datum: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_list_member_oid"]
    pub fn list_member_oid(list: *const List, datum: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_list_delete"]
    pub fn list_delete(list: *mut List, datum: *mut ::std::os::raw::c_void) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_delete_ptr"]
    pub fn list_delete_ptr(list: *mut List, datum: *mut ::std::os::raw::c_void) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_delete_int"]
    pub fn list_delete_int(list: *mut List, datum: ::std::os::raw::c_int) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_delete_oid"]
    pub fn list_delete_oid(list: *mut List, datum: Oid) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_delete_first"]
    pub fn list_delete_first(list: *mut List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_delete_cell"]
    pub fn list_delete_cell(list: *mut List, cell: *mut ListCell, prev: *mut ListCell)
        -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_union"]
    pub fn list_union(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_union_ptr"]
    pub fn list_union_ptr(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_union_int"]
    pub fn list_union_int(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_union_oid"]
    pub fn list_union_oid(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_intersection"]
    pub fn list_intersection(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_intersection_int"]
    pub fn list_intersection_int(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_difference"]
    pub fn list_difference(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_difference_ptr"]
    pub fn list_difference_ptr(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_difference_int"]
    pub fn list_difference_int(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_difference_oid"]
    pub fn list_difference_oid(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_append_unique"]
    pub fn list_append_unique(list: *mut List, datum: *mut ::std::os::raw::c_void) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_append_unique_ptr"]
    pub fn list_append_unique_ptr(list: *mut List, datum: *mut ::std::os::raw::c_void)
        -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_append_unique_int"]
    pub fn list_append_unique_int(list: *mut List, datum: ::std::os::raw::c_int) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_append_unique_oid"]
    pub fn list_append_unique_oid(list: *mut List, datum: Oid) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_concat_unique"]
    pub fn list_concat_unique(list1: *mut List, list2: *mut List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_concat_unique_ptr"]
    pub fn list_concat_unique_ptr(list1: *mut List, list2: *mut List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_concat_unique_int"]
    pub fn list_concat_unique_int(list1: *mut List, list2: *mut List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_concat_unique_oid"]
    pub fn list_concat_unique_oid(list1: *mut List, list2: *mut List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_free"]
    pub fn list_free(list: *mut List);
}
extern "C" {
    #[link_name = "\u{1}_list_free_deep"]
    pub fn list_free_deep(list: *mut List);
}
extern "C" {
    #[link_name = "\u{1}_list_copy"]
    pub fn list_copy(list: *const List) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_list_copy_tail"]
    pub fn list_copy_tail(list: *const List, nskip: ::std::os::raw::c_int) -> *mut List;
}
pub type list_qsort_comparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[link_name = "\u{1}_list_qsort"]
    pub fn list_qsort(list: *const List, cmp: list_qsort_comparator) -> *mut List;
}
pub type LOCKMASK = ::std::os::raw::c_int;
pub type LOCKMODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_standby_lock {
    pub xid: TransactionId,
    pub dbOid: Oid,
    pub relOid: Oid,
}
#[test]
fn bindgen_test_layout_xl_standby_lock() {
    assert_eq!(
        ::std::mem::size_of::<xl_standby_lock>(),
        12usize,
        concat!("Size of: ", stringify!(xl_standby_lock))
    );
    assert_eq!(
        ::std::mem::align_of::<xl_standby_lock>(),
        4usize,
        concat!("Alignment of ", stringify!(xl_standby_lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xl_standby_lock>())).xid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xl_standby_lock),
            "::",
            stringify!(xid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xl_standby_lock>())).dbOid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xl_standby_lock),
            "::",
            stringify!(dbOid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xl_standby_lock>())).relOid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xl_standby_lock),
            "::",
            stringify!(relOid)
        )
    );
}
pub type BlockNumber = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
#[test]
fn bindgen_test_layout_BlockIdData() {
    assert_eq!(
        ::std::mem::size_of::<BlockIdData>(),
        4usize,
        concat!("Size of: ", stringify!(BlockIdData))
    );
    assert_eq!(
        ::std::mem::align_of::<BlockIdData>(),
        2usize,
        concat!("Alignment of ", stringify!(BlockIdData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlockIdData>())).bi_hi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BlockIdData),
            "::",
            stringify!(bi_hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BlockIdData>())).bi_lo as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BlockIdData),
            "::",
            stringify!(bi_lo)
        )
    );
}
pub type BlockId = *mut BlockIdData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ItemIdData {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_ItemIdData() {
    assert_eq!(
        ::std::mem::size_of::<ItemIdData>(),
        4usize,
        concat!("Size of: ", stringify!(ItemIdData))
    );
    assert_eq!(
        ::std::mem::align_of::<ItemIdData>(),
        4usize,
        concat!("Alignment of ", stringify!(ItemIdData))
    );
}
impl ItemIdData {
    #[inline]
    pub fn lp_off(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_lp_off(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_lp_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_len(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_lp_len(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lp_off: ::std::os::raw::c_uint,
        lp_flags: ::std::os::raw::c_uint,
        lp_len: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let lp_off: u32 = unsafe { ::std::mem::transmute(lp_off) };
            lp_off as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let lp_flags: u32 = unsafe { ::std::mem::transmute(lp_flags) };
            lp_flags as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let lp_len: u32 = unsafe { ::std::mem::transmute(lp_len) };
            lp_len as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ItemId = *mut ItemIdData;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ItemPointerData {
    pub _bindgen_opaque_blob: [u16; 3usize],
}
#[test]
fn bindgen_test_layout_ItemPointerData() {
    assert_eq!(
        ::std::mem::size_of::<ItemPointerData>(),
        6usize,
        concat!("Size of: ", stringify!(ItemPointerData))
    );
    assert_eq!(
        ::std::mem::align_of::<ItemPointerData>(),
        2usize,
        concat!("Alignment of ", stringify!(ItemPointerData))
    );
}
pub type ItemPointer = *mut ItemPointerData;
extern "C" {
    #[link_name = "\u{1}_ItemPointerEquals"]
    pub fn ItemPointerEquals(pointer1: ItemPointer, pointer2: ItemPointer) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ItemPointerCompare"]
    pub fn ItemPointerCompare(arg1: ItemPointer, arg2: ItemPointer) -> int32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapTupleHeaderData {
    _unused: [u8; 0],
}
pub type HeapTupleHeader = *mut HeapTupleHeaderData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinimalTupleData {
    _unused: [u8; 0],
}
pub type MinimalTuple = *mut MinimalTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: HeapTupleHeader,
}
#[test]
fn bindgen_test_layout_HeapTupleData() {
    assert_eq!(
        ::std::mem::size_of::<HeapTupleData>(),
        24usize,
        concat!("Size of: ", stringify!(HeapTupleData))
    );
    assert_eq!(
        ::std::mem::align_of::<HeapTupleData>(),
        8usize,
        concat!("Alignment of ", stringify!(HeapTupleData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapTupleData>())).t_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapTupleData),
            "::",
            stringify!(t_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapTupleData>())).t_self as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapTupleData),
            "::",
            stringify!(t_self)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapTupleData>())).t_tableOid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapTupleData),
            "::",
            stringify!(t_tableOid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapTupleData>())).t_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapTupleData),
            "::",
            stringify!(t_data)
        )
    );
}
pub type HeapTuple = *mut HeapTupleData;
extern "C" {
    #[link_name = "\u{1}_HeapTupleHeaderGetCmin"]
    pub fn HeapTupleHeaderGetCmin(tup: HeapTupleHeader) -> CommandId;
}
extern "C" {
    #[link_name = "\u{1}_HeapTupleHeaderGetCmax"]
    pub fn HeapTupleHeaderGetCmax(tup: HeapTupleHeader) -> CommandId;
}
extern "C" {
    #[link_name = "\u{1}_HeapTupleHeaderAdjustCmax"]
    pub fn HeapTupleHeaderAdjustCmax(
        tup: HeapTupleHeader,
        cmax: *mut CommandId,
        iscombo: *mut bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_HeapTupleGetUpdateXid"]
    pub fn HeapTupleGetUpdateXid(tuple: HeapTupleHeader) -> TransactionId;
}
pub type bitmapword = uint32;
pub type signedbitmapword = int32;
#[repr(C)]
#[derive(Debug)]
pub struct Bitmapset {
    pub nwords: ::std::os::raw::c_int,
    pub words: __IncompleteArrayField<bitmapword>,
}
#[test]
fn bindgen_test_layout_Bitmapset() {
    assert_eq!(
        ::std::mem::size_of::<Bitmapset>(),
        4usize,
        concat!("Size of: ", stringify!(Bitmapset))
    );
    assert_eq!(
        ::std::mem::align_of::<Bitmapset>(),
        4usize,
        concat!("Alignment of ", stringify!(Bitmapset))
    );
}
pub const BMS_Comparison_BMS_EQUAL: BMS_Comparison = 0;
pub const BMS_Comparison_BMS_SUBSET1: BMS_Comparison = 1;
pub const BMS_Comparison_BMS_SUBSET2: BMS_Comparison = 2;
pub const BMS_Comparison_BMS_DIFFERENT: BMS_Comparison = 3;
pub type BMS_Comparison = u32;
pub const BMS_Membership_BMS_EMPTY_SET: BMS_Membership = 0;
pub const BMS_Membership_BMS_SINGLETON: BMS_Membership = 1;
pub const BMS_Membership_BMS_MULTIPLE: BMS_Membership = 2;
pub type BMS_Membership = u32;
extern "C" {
    #[link_name = "\u{1}_bms_copy"]
    pub fn bms_copy(a: *const Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_equal"]
    pub fn bms_equal(a: *const Bitmapset, b: *const Bitmapset) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_bms_compare"]
    pub fn bms_compare(a: *const Bitmapset, b: *const Bitmapset) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bms_make_singleton"]
    pub fn bms_make_singleton(x: ::std::os::raw::c_int) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_free"]
    pub fn bms_free(a: *mut Bitmapset);
}
extern "C" {
    #[link_name = "\u{1}_bms_union"]
    pub fn bms_union(a: *const Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_intersect"]
    pub fn bms_intersect(a: *const Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_difference"]
    pub fn bms_difference(a: *const Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_is_subset"]
    pub fn bms_is_subset(a: *const Bitmapset, b: *const Bitmapset) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_bms_subset_compare"]
    pub fn bms_subset_compare(a: *const Bitmapset, b: *const Bitmapset) -> BMS_Comparison;
}
extern "C" {
    #[link_name = "\u{1}_bms_is_member"]
    pub fn bms_is_member(x: ::std::os::raw::c_int, a: *const Bitmapset) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_bms_overlap"]
    pub fn bms_overlap(a: *const Bitmapset, b: *const Bitmapset) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_bms_overlap_list"]
    pub fn bms_overlap_list(a: *const Bitmapset, b: *const List) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_bms_nonempty_difference"]
    pub fn bms_nonempty_difference(a: *const Bitmapset, b: *const Bitmapset) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_bms_singleton_member"]
    pub fn bms_singleton_member(a: *const Bitmapset) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bms_get_singleton_member"]
    pub fn bms_get_singleton_member(
        a: *const Bitmapset,
        member: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_bms_num_members"]
    pub fn bms_num_members(a: *const Bitmapset) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bms_membership"]
    pub fn bms_membership(a: *const Bitmapset) -> BMS_Membership;
}
extern "C" {
    #[link_name = "\u{1}_bms_is_empty"]
    pub fn bms_is_empty(a: *const Bitmapset) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_bms_add_member"]
    pub fn bms_add_member(a: *mut Bitmapset, x: ::std::os::raw::c_int) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_del_member"]
    pub fn bms_del_member(a: *mut Bitmapset, x: ::std::os::raw::c_int) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_add_members"]
    pub fn bms_add_members(a: *mut Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_add_range"]
    pub fn bms_add_range(
        a: *mut Bitmapset,
        lower: ::std::os::raw::c_int,
        upper: ::std::os::raw::c_int,
    ) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_int_members"]
    pub fn bms_int_members(a: *mut Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_del_members"]
    pub fn bms_del_members(a: *mut Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_join"]
    pub fn bms_join(a: *mut Bitmapset, b: *mut Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_bms_first_member"]
    pub fn bms_first_member(a: *mut Bitmapset) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bms_next_member"]
    pub fn bms_next_member(
        a: *const Bitmapset,
        prevbit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bms_prev_member"]
    pub fn bms_prev_member(
        a: *const Bitmapset,
        prevbit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bms_hash_value"]
    pub fn bms_hash_value(a: *const Bitmapset) -> uint32;
}
pub const LockClauseStrength_LCS_NONE: LockClauseStrength = 0;
pub const LockClauseStrength_LCS_FORKEYSHARE: LockClauseStrength = 1;
pub const LockClauseStrength_LCS_FORSHARE: LockClauseStrength = 2;
pub const LockClauseStrength_LCS_FORNOKEYUPDATE: LockClauseStrength = 3;
pub const LockClauseStrength_LCS_FORUPDATE: LockClauseStrength = 4;
pub type LockClauseStrength = u32;
pub const LockWaitPolicy_LockWaitBlock: LockWaitPolicy = 0;
pub const LockWaitPolicy_LockWaitSkip: LockWaitPolicy = 1;
pub const LockWaitPolicy_LockWaitError: LockWaitPolicy = 2;
pub type LockWaitPolicy = u32;
pub type AttrNumber = int16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Alias {
    pub type_: NodeTag,
    pub aliasname: *mut ::std::os::raw::c_char,
    pub colnames: *mut List,
}
#[test]
fn bindgen_test_layout_Alias() {
    assert_eq!(
        ::std::mem::size_of::<Alias>(),
        24usize,
        concat!("Size of: ", stringify!(Alias))
    );
    assert_eq!(
        ::std::mem::align_of::<Alias>(),
        8usize,
        concat!("Alignment of ", stringify!(Alias))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Alias>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Alias),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Alias>())).aliasname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Alias),
            "::",
            stringify!(aliasname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Alias>())).colnames as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Alias),
            "::",
            stringify!(colnames)
        )
    );
}
pub const OnCommitAction_ONCOMMIT_NOOP: OnCommitAction = 0;
pub const OnCommitAction_ONCOMMIT_PRESERVE_ROWS: OnCommitAction = 1;
pub const OnCommitAction_ONCOMMIT_DELETE_ROWS: OnCommitAction = 2;
pub const OnCommitAction_ONCOMMIT_DROP: OnCommitAction = 3;
pub type OnCommitAction = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeVar {
    pub type_: NodeTag,
    pub catalogname: *mut ::std::os::raw::c_char,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub relname: *mut ::std::os::raw::c_char,
    pub inh: bool,
    pub relpersistence: ::std::os::raw::c_char,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeVar() {
    assert_eq!(
        ::std::mem::size_of::<RangeVar>(),
        56usize,
        concat!("Size of: ", stringify!(RangeVar))
    );
    assert_eq!(
        ::std::mem::align_of::<RangeVar>(),
        8usize,
        concat!("Alignment of ", stringify!(RangeVar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeVar>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeVar),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeVar>())).catalogname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeVar),
            "::",
            stringify!(catalogname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeVar>())).schemaname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeVar),
            "::",
            stringify!(schemaname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeVar>())).relname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeVar),
            "::",
            stringify!(relname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeVar>())).inh as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeVar),
            "::",
            stringify!(inh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeVar>())).relpersistence as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeVar),
            "::",
            stringify!(relpersistence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeVar>())).alias as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeVar),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeVar>())).location as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeVar),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFunc {
    pub type_: NodeTag,
    pub ns_uris: *mut List,
    pub ns_names: *mut List,
    pub docexpr: *mut Node,
    pub rowexpr: *mut Node,
    pub colnames: *mut List,
    pub coltypes: *mut List,
    pub coltypmods: *mut List,
    pub colcollations: *mut List,
    pub colexprs: *mut List,
    pub coldefexprs: *mut List,
    pub notnulls: *mut Bitmapset,
    pub ordinalitycol: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TableFunc() {
    assert_eq!(
        ::std::mem::size_of::<TableFunc>(),
        104usize,
        concat!("Size of: ", stringify!(TableFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<TableFunc>(),
        8usize,
        concat!("Alignment of ", stringify!(TableFunc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).ns_uris as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(ns_uris)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).ns_names as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(ns_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).docexpr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(docexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).rowexpr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(rowexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).colnames as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(colnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).coltypes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(coltypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).coltypmods as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(coltypmods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).colcollations as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(colcollations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).colexprs as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(colexprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).coldefexprs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(coldefexprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).notnulls as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(notnulls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).ordinalitycol as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(ordinalitycol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFunc>())).location as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFunc),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IntoClause {
    pub type_: NodeTag,
    pub rel: *mut RangeVar,
    pub colNames: *mut List,
    pub options: *mut List,
    pub onCommit: OnCommitAction,
    pub tableSpaceName: *mut ::std::os::raw::c_char,
    pub viewQuery: *mut Node,
    pub skipData: bool,
}
#[test]
fn bindgen_test_layout_IntoClause() {
    assert_eq!(
        ::std::mem::size_of::<IntoClause>(),
        64usize,
        concat!("Size of: ", stringify!(IntoClause))
    );
    assert_eq!(
        ::std::mem::align_of::<IntoClause>(),
        8usize,
        concat!("Alignment of ", stringify!(IntoClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntoClause>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IntoClause),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntoClause>())).rel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IntoClause),
            "::",
            stringify!(rel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntoClause>())).colNames as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IntoClause),
            "::",
            stringify!(colNames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntoClause>())).options as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IntoClause),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntoClause>())).onCommit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IntoClause),
            "::",
            stringify!(onCommit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntoClause>())).tableSpaceName as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IntoClause),
            "::",
            stringify!(tableSpaceName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntoClause>())).viewQuery as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IntoClause),
            "::",
            stringify!(viewQuery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntoClause>())).skipData as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IntoClause),
            "::",
            stringify!(skipData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Expr {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_Expr() {
    assert_eq!(
        ::std::mem::size_of::<Expr>(),
        4usize,
        concat!("Size of: ", stringify!(Expr))
    );
    assert_eq!(
        ::std::mem::align_of::<Expr>(),
        4usize,
        concat!("Alignment of ", stringify!(Expr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Expr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Expr),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Var {
    pub xpr: Expr,
    pub varno: Index,
    pub varattno: AttrNumber,
    pub vartype: Oid,
    pub vartypmod: int32,
    pub varcollid: Oid,
    pub varlevelsup: Index,
    pub varnoold: Index,
    pub varoattno: AttrNumber,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Var() {
    assert_eq!(
        ::std::mem::size_of::<Var>(),
        40usize,
        concat!("Size of: ", stringify!(Var))
    );
    assert_eq!(
        ::std::mem::align_of::<Var>(),
        4usize,
        concat!("Alignment of ", stringify!(Var))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Var>())).xpr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Var), "::", stringify!(xpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Var>())).varno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Var),
            "::",
            stringify!(varno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Var>())).varattno as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Var),
            "::",
            stringify!(varattno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Var>())).vartype as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Var),
            "::",
            stringify!(vartype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Var>())).vartypmod as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Var),
            "::",
            stringify!(vartypmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Var>())).varcollid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Var),
            "::",
            stringify!(varcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Var>())).varlevelsup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Var),
            "::",
            stringify!(varlevelsup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Var>())).varnoold as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Var),
            "::",
            stringify!(varnoold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Var>())).varoattno as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Var),
            "::",
            stringify!(varoattno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Var>())).location as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Var),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Const {
    pub xpr: Expr,
    pub consttype: Oid,
    pub consttypmod: int32,
    pub constcollid: Oid,
    pub constlen: ::std::os::raw::c_int,
    pub constvalue: Datum,
    pub constisnull: bool,
    pub constbyval: bool,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Const() {
    assert_eq!(
        ::std::mem::size_of::<Const>(),
        40usize,
        concat!("Size of: ", stringify!(Const))
    );
    assert_eq!(
        ::std::mem::align_of::<Const>(),
        8usize,
        concat!("Alignment of ", stringify!(Const))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Const>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Const),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Const>())).consttype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Const),
            "::",
            stringify!(consttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Const>())).consttypmod as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Const),
            "::",
            stringify!(consttypmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Const>())).constcollid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Const),
            "::",
            stringify!(constcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Const>())).constlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Const),
            "::",
            stringify!(constlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Const>())).constvalue as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Const),
            "::",
            stringify!(constvalue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Const>())).constisnull as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Const),
            "::",
            stringify!(constisnull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Const>())).constbyval as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(Const),
            "::",
            stringify!(constbyval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Const>())).location as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Const),
            "::",
            stringify!(location)
        )
    );
}
pub const ParamKind_PARAM_EXTERN: ParamKind = 0;
pub const ParamKind_PARAM_EXEC: ParamKind = 1;
pub const ParamKind_PARAM_SUBLINK: ParamKind = 2;
pub const ParamKind_PARAM_MULTIEXPR: ParamKind = 3;
pub type ParamKind = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Param {
    pub xpr: Expr,
    pub paramkind: ParamKind,
    pub paramid: ::std::os::raw::c_int,
    pub paramtype: Oid,
    pub paramtypmod: int32,
    pub paramcollid: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Param() {
    assert_eq!(
        ::std::mem::size_of::<Param>(),
        28usize,
        concat!("Size of: ", stringify!(Param))
    );
    assert_eq!(
        ::std::mem::align_of::<Param>(),
        4usize,
        concat!("Alignment of ", stringify!(Param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Param>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Param),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Param>())).paramkind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Param),
            "::",
            stringify!(paramkind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Param>())).paramid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Param),
            "::",
            stringify!(paramid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Param>())).paramtype as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Param),
            "::",
            stringify!(paramtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Param>())).paramtypmod as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Param),
            "::",
            stringify!(paramtypmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Param>())).paramcollid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Param),
            "::",
            stringify!(paramcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Param>())).location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Param),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Aggref {
    pub xpr: Expr,
    pub aggfnoid: Oid,
    pub aggtype: Oid,
    pub aggcollid: Oid,
    pub inputcollid: Oid,
    pub aggtranstype: Oid,
    pub aggargtypes: *mut List,
    pub aggdirectargs: *mut List,
    pub args: *mut List,
    pub aggorder: *mut List,
    pub aggdistinct: *mut List,
    pub aggfilter: *mut Expr,
    pub aggstar: bool,
    pub aggvariadic: bool,
    pub aggkind: ::std::os::raw::c_char,
    pub agglevelsup: Index,
    pub aggsplit: AggSplit,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Aggref() {
    assert_eq!(
        ::std::mem::size_of::<Aggref>(),
        88usize,
        concat!("Size of: ", stringify!(Aggref))
    );
    assert_eq!(
        ::std::mem::align_of::<Aggref>(),
        8usize,
        concat!("Alignment of ", stringify!(Aggref))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggfnoid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggfnoid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggtype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggcollid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).inputcollid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(inputcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggtranstype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggtranstype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggargtypes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggargtypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggdirectargs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggdirectargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).args as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggorder as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggorder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggdistinct as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggdistinct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggfilter as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggfilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggstar as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggstar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggvariadic as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggvariadic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggkind as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggkind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).agglevelsup as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(agglevelsup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).aggsplit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(aggsplit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Aggref>())).location as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(Aggref),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingFunc {
    pub xpr: Expr,
    pub args: *mut List,
    pub refs: *mut List,
    pub cols: *mut List,
    pub agglevelsup: Index,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GroupingFunc() {
    assert_eq!(
        ::std::mem::size_of::<GroupingFunc>(),
        40usize,
        concat!("Size of: ", stringify!(GroupingFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<GroupingFunc>(),
        8usize,
        concat!("Alignment of ", stringify!(GroupingFunc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupingFunc>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupingFunc),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupingFunc>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupingFunc),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupingFunc>())).refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupingFunc),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupingFunc>())).cols as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupingFunc),
            "::",
            stringify!(cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupingFunc>())).agglevelsup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupingFunc),
            "::",
            stringify!(agglevelsup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupingFunc>())).location as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupingFunc),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFunc {
    pub xpr: Expr,
    pub winfnoid: Oid,
    pub wintype: Oid,
    pub wincollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub aggfilter: *mut Expr,
    pub winref: Index,
    pub winstar: bool,
    pub winagg: bool,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WindowFunc() {
    assert_eq!(
        ::std::mem::size_of::<WindowFunc>(),
        56usize,
        concat!("Size of: ", stringify!(WindowFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<WindowFunc>(),
        8usize,
        concat!("Alignment of ", stringify!(WindowFunc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFunc>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFunc),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFunc>())).winfnoid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFunc),
            "::",
            stringify!(winfnoid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFunc>())).wintype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFunc),
            "::",
            stringify!(wintype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFunc>())).wincollid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFunc),
            "::",
            stringify!(wincollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFunc>())).inputcollid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFunc),
            "::",
            stringify!(inputcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFunc>())).args as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFunc),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFunc>())).aggfilter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFunc),
            "::",
            stringify!(aggfilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFunc>())).winref as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFunc),
            "::",
            stringify!(winref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFunc>())).winstar as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFunc),
            "::",
            stringify!(winstar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFunc>())).winagg as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFunc),
            "::",
            stringify!(winagg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFunc>())).location as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFunc),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayRef {
    pub xpr: Expr,
    pub refarraytype: Oid,
    pub refelemtype: Oid,
    pub reftypmod: int32,
    pub refcollid: Oid,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut Expr,
    pub refassgnexpr: *mut Expr,
}
#[test]
fn bindgen_test_layout_ArrayRef() {
    assert_eq!(
        ::std::mem::size_of::<ArrayRef>(),
        56usize,
        concat!("Size of: ", stringify!(ArrayRef))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrayRef>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrayRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayRef>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayRef),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayRef>())).refarraytype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayRef),
            "::",
            stringify!(refarraytype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayRef>())).refelemtype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayRef),
            "::",
            stringify!(refelemtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayRef>())).reftypmod as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayRef),
            "::",
            stringify!(reftypmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayRef>())).refcollid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayRef),
            "::",
            stringify!(refcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayRef>())).refupperindexpr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayRef),
            "::",
            stringify!(refupperindexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayRef>())).reflowerindexpr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayRef),
            "::",
            stringify!(reflowerindexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayRef>())).refexpr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayRef),
            "::",
            stringify!(refexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayRef>())).refassgnexpr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayRef),
            "::",
            stringify!(refassgnexpr)
        )
    );
}
pub const CoercionContext_COERCION_IMPLICIT: CoercionContext = 0;
pub const CoercionContext_COERCION_ASSIGNMENT: CoercionContext = 1;
pub const CoercionContext_COERCION_EXPLICIT: CoercionContext = 2;
pub type CoercionContext = u32;
pub const CoercionForm_COERCE_EXPLICIT_CALL: CoercionForm = 0;
pub const CoercionForm_COERCE_EXPLICIT_CAST: CoercionForm = 1;
pub const CoercionForm_COERCE_IMPLICIT_CAST: CoercionForm = 2;
pub type CoercionForm = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuncExpr {
    pub xpr: Expr,
    pub funcid: Oid,
    pub funcresulttype: Oid,
    pub funcretset: bool,
    pub funcvariadic: bool,
    pub funcformat: CoercionForm,
    pub funccollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FuncExpr() {
    assert_eq!(
        ::std::mem::size_of::<FuncExpr>(),
        48usize,
        concat!("Size of: ", stringify!(FuncExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<FuncExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(FuncExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncExpr>())).funcid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncExpr),
            "::",
            stringify!(funcid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncExpr>())).funcresulttype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncExpr),
            "::",
            stringify!(funcresulttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncExpr>())).funcretset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncExpr),
            "::",
            stringify!(funcretset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncExpr>())).funcvariadic as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncExpr),
            "::",
            stringify!(funcvariadic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncExpr>())).funcformat as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncExpr),
            "::",
            stringify!(funcformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncExpr>())).funccollid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncExpr),
            "::",
            stringify!(funccollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncExpr>())).inputcollid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncExpr),
            "::",
            stringify!(inputcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncExpr>())).args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncExpr),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncExpr>())).location as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncExpr),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedArgExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub name: *mut ::std::os::raw::c_char,
    pub argnumber: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NamedArgExpr() {
    assert_eq!(
        ::std::mem::size_of::<NamedArgExpr>(),
        32usize,
        concat!("Size of: ", stringify!(NamedArgExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<NamedArgExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedArgExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NamedArgExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedArgExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NamedArgExpr>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedArgExpr),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NamedArgExpr>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedArgExpr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NamedArgExpr>())).argnumber as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedArgExpr),
            "::",
            stringify!(argnumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NamedArgExpr>())).location as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedArgExpr),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub opresulttype: Oid,
    pub opretset: bool,
    pub opcollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OpExpr() {
    assert_eq!(
        ::std::mem::size_of::<OpExpr>(),
        48usize,
        concat!("Size of: ", stringify!(OpExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<OpExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(OpExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OpExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpExpr>())).opno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OpExpr),
            "::",
            stringify!(opno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpExpr>())).opfuncid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OpExpr),
            "::",
            stringify!(opfuncid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpExpr>())).opresulttype as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(OpExpr),
            "::",
            stringify!(opresulttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpExpr>())).opretset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OpExpr),
            "::",
            stringify!(opretset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpExpr>())).opcollid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OpExpr),
            "::",
            stringify!(opcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpExpr>())).inputcollid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OpExpr),
            "::",
            stringify!(inputcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpExpr>())).args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OpExpr),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OpExpr>())).location as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OpExpr),
            "::",
            stringify!(location)
        )
    );
}
pub type DistinctExpr = OpExpr;
pub type NullIfExpr = OpExpr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScalarArrayOpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub useOr: bool,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ScalarArrayOpExpr() {
    assert_eq!(
        ::std::mem::size_of::<ScalarArrayOpExpr>(),
        40usize,
        concat!("Size of: ", stringify!(ScalarArrayOpExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<ScalarArrayOpExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(ScalarArrayOpExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScalarArrayOpExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ScalarArrayOpExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScalarArrayOpExpr>())).opno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ScalarArrayOpExpr),
            "::",
            stringify!(opno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScalarArrayOpExpr>())).opfuncid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ScalarArrayOpExpr),
            "::",
            stringify!(opfuncid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScalarArrayOpExpr>())).useOr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ScalarArrayOpExpr),
            "::",
            stringify!(useOr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScalarArrayOpExpr>())).inputcollid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ScalarArrayOpExpr),
            "::",
            stringify!(inputcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScalarArrayOpExpr>())).args as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ScalarArrayOpExpr),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScalarArrayOpExpr>())).location as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ScalarArrayOpExpr),
            "::",
            stringify!(location)
        )
    );
}
pub const BoolExprType_AND_EXPR: BoolExprType = 0;
pub const BoolExprType_OR_EXPR: BoolExprType = 1;
pub const BoolExprType_NOT_EXPR: BoolExprType = 2;
pub type BoolExprType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BoolExpr {
    pub xpr: Expr,
    pub boolop: BoolExprType,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BoolExpr() {
    assert_eq!(
        ::std::mem::size_of::<BoolExpr>(),
        24usize,
        concat!("Size of: ", stringify!(BoolExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<BoolExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(BoolExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BoolExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BoolExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BoolExpr>())).boolop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BoolExpr),
            "::",
            stringify!(boolop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BoolExpr>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BoolExpr),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BoolExpr>())).location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BoolExpr),
            "::",
            stringify!(location)
        )
    );
}
pub const SubLinkType_EXISTS_SUBLINK: SubLinkType = 0;
pub const SubLinkType_ALL_SUBLINK: SubLinkType = 1;
pub const SubLinkType_ANY_SUBLINK: SubLinkType = 2;
pub const SubLinkType_ROWCOMPARE_SUBLINK: SubLinkType = 3;
pub const SubLinkType_EXPR_SUBLINK: SubLinkType = 4;
pub const SubLinkType_MULTIEXPR_SUBLINK: SubLinkType = 5;
pub const SubLinkType_ARRAY_SUBLINK: SubLinkType = 6;
pub const SubLinkType_CTE_SUBLINK: SubLinkType = 7;
pub type SubLinkType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubLink {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub subLinkId: ::std::os::raw::c_int,
    pub testexpr: *mut Node,
    pub operName: *mut List,
    pub subselect: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SubLink() {
    assert_eq!(
        ::std::mem::size_of::<SubLink>(),
        48usize,
        concat!("Size of: ", stringify!(SubLink))
    );
    assert_eq!(
        ::std::mem::align_of::<SubLink>(),
        8usize,
        concat!("Alignment of ", stringify!(SubLink))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubLink>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubLink),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubLink>())).subLinkType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubLink),
            "::",
            stringify!(subLinkType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubLink>())).subLinkId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubLink),
            "::",
            stringify!(subLinkId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubLink>())).testexpr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubLink),
            "::",
            stringify!(testexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubLink>())).operName as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubLink),
            "::",
            stringify!(operName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubLink>())).subselect as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SubLink),
            "::",
            stringify!(subselect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubLink>())).location as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SubLink),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubPlan {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub paramIds: *mut List,
    pub plan_id: ::std::os::raw::c_int,
    pub plan_name: *mut ::std::os::raw::c_char,
    pub firstColType: Oid,
    pub firstColTypmod: int32,
    pub firstColCollation: Oid,
    pub useHashTable: bool,
    pub unknownEqFalse: bool,
    pub parallel_safe: bool,
    pub setParam: *mut List,
    pub parParam: *mut List,
    pub args: *mut List,
    pub startup_cost: Cost,
    pub per_call_cost: Cost,
}
#[test]
fn bindgen_test_layout_SubPlan() {
    assert_eq!(
        ::std::mem::size_of::<SubPlan>(),
        96usize,
        concat!("Size of: ", stringify!(SubPlan))
    );
    assert_eq!(
        ::std::mem::align_of::<SubPlan>(),
        8usize,
        concat!("Alignment of ", stringify!(SubPlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).subLinkType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(subLinkType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).testexpr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(testexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).paramIds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(paramIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).plan_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(plan_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).plan_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(plan_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).firstColType as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(firstColType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).firstColTypmod as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(firstColTypmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).firstColCollation as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(firstColCollation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).useHashTable as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(useHashTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).unknownEqFalse as *const _ as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(unknownEqFalse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).parallel_safe as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(parallel_safe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).setParam as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(setParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).parParam as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(parParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).args as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).startup_cost as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(startup_cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlan>())).per_call_cost as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlan),
            "::",
            stringify!(per_call_cost)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlternativeSubPlan {
    pub xpr: Expr,
    pub subplans: *mut List,
}
#[test]
fn bindgen_test_layout_AlternativeSubPlan() {
    assert_eq!(
        ::std::mem::size_of::<AlternativeSubPlan>(),
        16usize,
        concat!("Size of: ", stringify!(AlternativeSubPlan))
    );
    assert_eq!(
        ::std::mem::align_of::<AlternativeSubPlan>(),
        8usize,
        concat!("Alignment of ", stringify!(AlternativeSubPlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlternativeSubPlan>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlternativeSubPlan),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlternativeSubPlan>())).subplans as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlternativeSubPlan),
            "::",
            stringify!(subplans)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FieldSelect {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
}
#[test]
fn bindgen_test_layout_FieldSelect() {
    assert_eq!(
        ::std::mem::size_of::<FieldSelect>(),
        32usize,
        concat!("Size of: ", stringify!(FieldSelect))
    );
    assert_eq!(
        ::std::mem::align_of::<FieldSelect>(),
        8usize,
        concat!("Alignment of ", stringify!(FieldSelect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FieldSelect>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FieldSelect),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FieldSelect>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FieldSelect),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FieldSelect>())).fieldnum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FieldSelect),
            "::",
            stringify!(fieldnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FieldSelect>())).resulttype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FieldSelect),
            "::",
            stringify!(resulttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FieldSelect>())).resulttypmod as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FieldSelect),
            "::",
            stringify!(resulttypmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FieldSelect>())).resultcollid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FieldSelect),
            "::",
            stringify!(resultcollid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FieldStore {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub newvals: *mut List,
    pub fieldnums: *mut List,
    pub resulttype: Oid,
}
#[test]
fn bindgen_test_layout_FieldStore() {
    assert_eq!(
        ::std::mem::size_of::<FieldStore>(),
        40usize,
        concat!("Size of: ", stringify!(FieldStore))
    );
    assert_eq!(
        ::std::mem::align_of::<FieldStore>(),
        8usize,
        concat!("Alignment of ", stringify!(FieldStore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FieldStore>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FieldStore),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FieldStore>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FieldStore),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FieldStore>())).newvals as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FieldStore),
            "::",
            stringify!(newvals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FieldStore>())).fieldnums as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FieldStore),
            "::",
            stringify!(fieldnums)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FieldStore>())).resulttype as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FieldStore),
            "::",
            stringify!(resulttype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelabelType {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub relabelformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RelabelType() {
    assert_eq!(
        ::std::mem::size_of::<RelabelType>(),
        40usize,
        concat!("Size of: ", stringify!(RelabelType))
    );
    assert_eq!(
        ::std::mem::align_of::<RelabelType>(),
        8usize,
        concat!("Alignment of ", stringify!(RelabelType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RelabelType>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RelabelType),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RelabelType>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RelabelType),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RelabelType>())).resulttype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RelabelType),
            "::",
            stringify!(resulttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RelabelType>())).resulttypmod as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RelabelType),
            "::",
            stringify!(resulttypmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RelabelType>())).resultcollid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RelabelType),
            "::",
            stringify!(resultcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RelabelType>())).relabelformat as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RelabelType),
            "::",
            stringify!(relabelformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RelabelType>())).location as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RelabelType),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceViaIO {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoerceViaIO() {
    assert_eq!(
        ::std::mem::size_of::<CoerceViaIO>(),
        32usize,
        concat!("Size of: ", stringify!(CoerceViaIO))
    );
    assert_eq!(
        ::std::mem::align_of::<CoerceViaIO>(),
        8usize,
        concat!("Alignment of ", stringify!(CoerceViaIO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceViaIO>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceViaIO),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceViaIO>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceViaIO),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceViaIO>())).resulttype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceViaIO),
            "::",
            stringify!(resulttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceViaIO>())).resultcollid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceViaIO),
            "::",
            stringify!(resultcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceViaIO>())).coerceformat as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceViaIO),
            "::",
            stringify!(coerceformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceViaIO>())).location as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceViaIO),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayCoerceExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub elemexpr: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ArrayCoerceExpr() {
    assert_eq!(
        ::std::mem::size_of::<ArrayCoerceExpr>(),
        48usize,
        concat!("Size of: ", stringify!(ArrayCoerceExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrayCoerceExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrayCoerceExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayCoerceExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayCoerceExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayCoerceExpr>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayCoerceExpr),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayCoerceExpr>())).elemexpr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayCoerceExpr),
            "::",
            stringify!(elemexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayCoerceExpr>())).resulttype as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayCoerceExpr),
            "::",
            stringify!(resulttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayCoerceExpr>())).resulttypmod as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayCoerceExpr),
            "::",
            stringify!(resulttypmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayCoerceExpr>())).resultcollid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayCoerceExpr),
            "::",
            stringify!(resultcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayCoerceExpr>())).coerceformat as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayCoerceExpr),
            "::",
            stringify!(coerceformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayCoerceExpr>())).location as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayCoerceExpr),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConvertRowtypeExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub convertformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ConvertRowtypeExpr() {
    assert_eq!(
        ::std::mem::size_of::<ConvertRowtypeExpr>(),
        32usize,
        concat!("Size of: ", stringify!(ConvertRowtypeExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<ConvertRowtypeExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(ConvertRowtypeExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConvertRowtypeExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConvertRowtypeExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConvertRowtypeExpr>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConvertRowtypeExpr),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConvertRowtypeExpr>())).resulttype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ConvertRowtypeExpr),
            "::",
            stringify!(resulttype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ConvertRowtypeExpr>())).convertformat as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ConvertRowtypeExpr),
            "::",
            stringify!(convertformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConvertRowtypeExpr>())).location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ConvertRowtypeExpr),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollateExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub collOid: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CollateExpr() {
    assert_eq!(
        ::std::mem::size_of::<CollateExpr>(),
        24usize,
        concat!("Size of: ", stringify!(CollateExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<CollateExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(CollateExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CollateExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CollateExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CollateExpr>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CollateExpr),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CollateExpr>())).collOid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CollateExpr),
            "::",
            stringify!(collOid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CollateExpr>())).location as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CollateExpr),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseExpr {
    pub xpr: Expr,
    pub casetype: Oid,
    pub casecollid: Oid,
    pub arg: *mut Expr,
    pub args: *mut List,
    pub defresult: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CaseExpr() {
    assert_eq!(
        ::std::mem::size_of::<CaseExpr>(),
        48usize,
        concat!("Size of: ", stringify!(CaseExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<CaseExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(CaseExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseExpr>())).casetype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseExpr),
            "::",
            stringify!(casetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseExpr>())).casecollid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseExpr),
            "::",
            stringify!(casecollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseExpr>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseExpr),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseExpr>())).args as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseExpr),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseExpr>())).defresult as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseExpr),
            "::",
            stringify!(defresult)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseExpr>())).location as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseExpr),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseWhen {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub result: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CaseWhen() {
    assert_eq!(
        ::std::mem::size_of::<CaseWhen>(),
        32usize,
        concat!("Size of: ", stringify!(CaseWhen))
    );
    assert_eq!(
        ::std::mem::align_of::<CaseWhen>(),
        8usize,
        concat!("Alignment of ", stringify!(CaseWhen))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseWhen>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseWhen),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseWhen>())).expr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseWhen),
            "::",
            stringify!(expr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseWhen>())).result as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseWhen),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseWhen>())).location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseWhen),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseTestExpr {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
}
#[test]
fn bindgen_test_layout_CaseTestExpr() {
    assert_eq!(
        ::std::mem::size_of::<CaseTestExpr>(),
        16usize,
        concat!("Size of: ", stringify!(CaseTestExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<CaseTestExpr>(),
        4usize,
        concat!("Alignment of ", stringify!(CaseTestExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseTestExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseTestExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseTestExpr>())).typeId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseTestExpr),
            "::",
            stringify!(typeId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseTestExpr>())).typeMod as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseTestExpr),
            "::",
            stringify!(typeMod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CaseTestExpr>())).collation as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CaseTestExpr),
            "::",
            stringify!(collation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayExpr {
    pub xpr: Expr,
    pub array_typeid: Oid,
    pub array_collid: Oid,
    pub element_typeid: Oid,
    pub elements: *mut List,
    pub multidims: bool,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ArrayExpr() {
    assert_eq!(
        ::std::mem::size_of::<ArrayExpr>(),
        32usize,
        concat!("Size of: ", stringify!(ArrayExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrayExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrayExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayExpr>())).array_typeid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayExpr),
            "::",
            stringify!(array_typeid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayExpr>())).array_collid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayExpr),
            "::",
            stringify!(array_collid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayExpr>())).element_typeid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayExpr),
            "::",
            stringify!(element_typeid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayExpr>())).elements as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayExpr),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayExpr>())).multidims as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayExpr),
            "::",
            stringify!(multidims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayExpr>())).location as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayExpr),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowExpr {
    pub xpr: Expr,
    pub args: *mut List,
    pub row_typeid: Oid,
    pub row_format: CoercionForm,
    pub colnames: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RowExpr() {
    assert_eq!(
        ::std::mem::size_of::<RowExpr>(),
        40usize,
        concat!("Size of: ", stringify!(RowExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<RowExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(RowExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RowExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowExpr>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RowExpr),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowExpr>())).row_typeid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RowExpr),
            "::",
            stringify!(row_typeid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowExpr>())).row_format as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RowExpr),
            "::",
            stringify!(row_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowExpr>())).colnames as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RowExpr),
            "::",
            stringify!(colnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowExpr>())).location as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RowExpr),
            "::",
            stringify!(location)
        )
    );
}
pub const RowCompareType_ROWCOMPARE_LT: RowCompareType = 1;
pub const RowCompareType_ROWCOMPARE_LE: RowCompareType = 2;
pub const RowCompareType_ROWCOMPARE_EQ: RowCompareType = 3;
pub const RowCompareType_ROWCOMPARE_GE: RowCompareType = 4;
pub const RowCompareType_ROWCOMPARE_GT: RowCompareType = 5;
pub const RowCompareType_ROWCOMPARE_NE: RowCompareType = 6;
pub type RowCompareType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowCompareExpr {
    pub xpr: Expr,
    pub rctype: RowCompareType,
    pub opnos: *mut List,
    pub opfamilies: *mut List,
    pub inputcollids: *mut List,
    pub largs: *mut List,
    pub rargs: *mut List,
}
#[test]
fn bindgen_test_layout_RowCompareExpr() {
    assert_eq!(
        ::std::mem::size_of::<RowCompareExpr>(),
        48usize,
        concat!("Size of: ", stringify!(RowCompareExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<RowCompareExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(RowCompareExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowCompareExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RowCompareExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowCompareExpr>())).rctype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RowCompareExpr),
            "::",
            stringify!(rctype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowCompareExpr>())).opnos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RowCompareExpr),
            "::",
            stringify!(opnos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowCompareExpr>())).opfamilies as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RowCompareExpr),
            "::",
            stringify!(opfamilies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowCompareExpr>())).inputcollids as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RowCompareExpr),
            "::",
            stringify!(inputcollids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowCompareExpr>())).largs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RowCompareExpr),
            "::",
            stringify!(largs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowCompareExpr>())).rargs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RowCompareExpr),
            "::",
            stringify!(rargs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoalesceExpr {
    pub xpr: Expr,
    pub coalescetype: Oid,
    pub coalescecollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoalesceExpr() {
    assert_eq!(
        ::std::mem::size_of::<CoalesceExpr>(),
        32usize,
        concat!("Size of: ", stringify!(CoalesceExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<CoalesceExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(CoalesceExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoalesceExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CoalesceExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoalesceExpr>())).coalescetype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CoalesceExpr),
            "::",
            stringify!(coalescetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoalesceExpr>())).coalescecollid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CoalesceExpr),
            "::",
            stringify!(coalescecollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoalesceExpr>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CoalesceExpr),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoalesceExpr>())).location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CoalesceExpr),
            "::",
            stringify!(location)
        )
    );
}
pub const MinMaxOp_IS_GREATEST: MinMaxOp = 0;
pub const MinMaxOp_IS_LEAST: MinMaxOp = 1;
pub type MinMaxOp = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinMaxExpr {
    pub xpr: Expr,
    pub minmaxtype: Oid,
    pub minmaxcollid: Oid,
    pub inputcollid: Oid,
    pub op: MinMaxOp,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MinMaxExpr() {
    assert_eq!(
        ::std::mem::size_of::<MinMaxExpr>(),
        40usize,
        concat!("Size of: ", stringify!(MinMaxExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<MinMaxExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(MinMaxExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MinMaxExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MinMaxExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MinMaxExpr>())).minmaxtype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MinMaxExpr),
            "::",
            stringify!(minmaxtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MinMaxExpr>())).minmaxcollid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MinMaxExpr),
            "::",
            stringify!(minmaxcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MinMaxExpr>())).inputcollid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MinMaxExpr),
            "::",
            stringify!(inputcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MinMaxExpr>())).op as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MinMaxExpr),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MinMaxExpr>())).args as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MinMaxExpr),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MinMaxExpr>())).location as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MinMaxExpr),
            "::",
            stringify!(location)
        )
    );
}
pub const SQLValueFunctionOp_SVFOP_CURRENT_DATE: SQLValueFunctionOp = 0;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIME: SQLValueFunctionOp = 1;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIME_N: SQLValueFunctionOp = 2;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIMESTAMP: SQLValueFunctionOp = 3;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIMESTAMP_N: SQLValueFunctionOp = 4;
pub const SQLValueFunctionOp_SVFOP_LOCALTIME: SQLValueFunctionOp = 5;
pub const SQLValueFunctionOp_SVFOP_LOCALTIME_N: SQLValueFunctionOp = 6;
pub const SQLValueFunctionOp_SVFOP_LOCALTIMESTAMP: SQLValueFunctionOp = 7;
pub const SQLValueFunctionOp_SVFOP_LOCALTIMESTAMP_N: SQLValueFunctionOp = 8;
pub const SQLValueFunctionOp_SVFOP_CURRENT_ROLE: SQLValueFunctionOp = 9;
pub const SQLValueFunctionOp_SVFOP_CURRENT_USER: SQLValueFunctionOp = 10;
pub const SQLValueFunctionOp_SVFOP_USER: SQLValueFunctionOp = 11;
pub const SQLValueFunctionOp_SVFOP_SESSION_USER: SQLValueFunctionOp = 12;
pub const SQLValueFunctionOp_SVFOP_CURRENT_CATALOG: SQLValueFunctionOp = 13;
pub const SQLValueFunctionOp_SVFOP_CURRENT_SCHEMA: SQLValueFunctionOp = 14;
pub type SQLValueFunctionOp = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SQLValueFunction {
    pub xpr: Expr,
    pub op: SQLValueFunctionOp,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SQLValueFunction() {
    assert_eq!(
        ::std::mem::size_of::<SQLValueFunction>(),
        20usize,
        concat!("Size of: ", stringify!(SQLValueFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<SQLValueFunction>(),
        4usize,
        concat!("Alignment of ", stringify!(SQLValueFunction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SQLValueFunction>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SQLValueFunction),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SQLValueFunction>())).op as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SQLValueFunction),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SQLValueFunction>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SQLValueFunction),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SQLValueFunction>())).typmod as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SQLValueFunction),
            "::",
            stringify!(typmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SQLValueFunction>())).location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SQLValueFunction),
            "::",
            stringify!(location)
        )
    );
}
pub const XmlExprOp_IS_XMLCONCAT: XmlExprOp = 0;
pub const XmlExprOp_IS_XMLELEMENT: XmlExprOp = 1;
pub const XmlExprOp_IS_XMLFOREST: XmlExprOp = 2;
pub const XmlExprOp_IS_XMLPARSE: XmlExprOp = 3;
pub const XmlExprOp_IS_XMLPI: XmlExprOp = 4;
pub const XmlExprOp_IS_XMLROOT: XmlExprOp = 5;
pub const XmlExprOp_IS_XMLSERIALIZE: XmlExprOp = 6;
pub const XmlExprOp_IS_DOCUMENT: XmlExprOp = 7;
pub type XmlExprOp = u32;
pub const XmlOptionType_XMLOPTION_DOCUMENT: XmlOptionType = 0;
pub const XmlOptionType_XMLOPTION_CONTENT: XmlOptionType = 1;
pub type XmlOptionType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmlExpr {
    pub xpr: Expr,
    pub op: XmlExprOp,
    pub name: *mut ::std::os::raw::c_char,
    pub named_args: *mut List,
    pub arg_names: *mut List,
    pub args: *mut List,
    pub xmloption: XmlOptionType,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XmlExpr() {
    assert_eq!(
        ::std::mem::size_of::<XmlExpr>(),
        56usize,
        concat!("Size of: ", stringify!(XmlExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<XmlExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(XmlExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlExpr>())).op as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlExpr),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlExpr>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlExpr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlExpr>())).named_args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlExpr),
            "::",
            stringify!(named_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlExpr>())).arg_names as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlExpr),
            "::",
            stringify!(arg_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlExpr>())).args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlExpr),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlExpr>())).xmloption as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlExpr),
            "::",
            stringify!(xmloption)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlExpr>())).type_ as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlExpr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlExpr>())).typmod as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlExpr),
            "::",
            stringify!(typmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlExpr>())).location as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlExpr),
            "::",
            stringify!(location)
        )
    );
}
pub const NullTestType_IS_NULL: NullTestType = 0;
pub const NullTestType_IS_NOT_NULL: NullTestType = 1;
pub type NullTestType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NullTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub nulltesttype: NullTestType,
    pub argisrow: bool,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NullTest() {
    assert_eq!(
        ::std::mem::size_of::<NullTest>(),
        32usize,
        concat!("Size of: ", stringify!(NullTest))
    );
    assert_eq!(
        ::std::mem::align_of::<NullTest>(),
        8usize,
        concat!("Alignment of ", stringify!(NullTest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NullTest>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NullTest),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NullTest>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NullTest),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NullTest>())).nulltesttype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NullTest),
            "::",
            stringify!(nulltesttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NullTest>())).argisrow as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NullTest),
            "::",
            stringify!(argisrow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NullTest>())).location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NullTest),
            "::",
            stringify!(location)
        )
    );
}
pub const BoolTestType_IS_TRUE: BoolTestType = 0;
pub const BoolTestType_IS_NOT_TRUE: BoolTestType = 1;
pub const BoolTestType_IS_FALSE: BoolTestType = 2;
pub const BoolTestType_IS_NOT_FALSE: BoolTestType = 3;
pub const BoolTestType_IS_UNKNOWN: BoolTestType = 4;
pub const BoolTestType_IS_NOT_UNKNOWN: BoolTestType = 5;
pub type BoolTestType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BooleanTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub booltesttype: BoolTestType,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BooleanTest() {
    assert_eq!(
        ::std::mem::size_of::<BooleanTest>(),
        24usize,
        concat!("Size of: ", stringify!(BooleanTest))
    );
    assert_eq!(
        ::std::mem::align_of::<BooleanTest>(),
        8usize,
        concat!("Alignment of ", stringify!(BooleanTest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BooleanTest>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BooleanTest),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BooleanTest>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BooleanTest),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BooleanTest>())).booltesttype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BooleanTest),
            "::",
            stringify!(booltesttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BooleanTest>())).location as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BooleanTest),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceToDomain {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coercionformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoerceToDomain() {
    assert_eq!(
        ::std::mem::size_of::<CoerceToDomain>(),
        40usize,
        concat!("Size of: ", stringify!(CoerceToDomain))
    );
    assert_eq!(
        ::std::mem::align_of::<CoerceToDomain>(),
        8usize,
        concat!("Alignment of ", stringify!(CoerceToDomain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomain>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomain),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomain>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomain),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomain>())).resulttype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomain),
            "::",
            stringify!(resulttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomain>())).resulttypmod as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomain),
            "::",
            stringify!(resulttypmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomain>())).resultcollid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomain),
            "::",
            stringify!(resultcollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomain>())).coercionformat as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomain),
            "::",
            stringify!(coercionformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomain>())).location as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomain),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceToDomainValue {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoerceToDomainValue() {
    assert_eq!(
        ::std::mem::size_of::<CoerceToDomainValue>(),
        20usize,
        concat!("Size of: ", stringify!(CoerceToDomainValue))
    );
    assert_eq!(
        ::std::mem::align_of::<CoerceToDomainValue>(),
        4usize,
        concat!("Alignment of ", stringify!(CoerceToDomainValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomainValue>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomainValue),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomainValue>())).typeId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomainValue),
            "::",
            stringify!(typeId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomainValue>())).typeMod as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomainValue),
            "::",
            stringify!(typeMod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomainValue>())).collation as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomainValue),
            "::",
            stringify!(collation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CoerceToDomainValue>())).location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CoerceToDomainValue),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetToDefault {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SetToDefault() {
    assert_eq!(
        ::std::mem::size_of::<SetToDefault>(),
        20usize,
        concat!("Size of: ", stringify!(SetToDefault))
    );
    assert_eq!(
        ::std::mem::align_of::<SetToDefault>(),
        4usize,
        concat!("Alignment of ", stringify!(SetToDefault))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetToDefault>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SetToDefault),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetToDefault>())).typeId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SetToDefault),
            "::",
            stringify!(typeId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetToDefault>())).typeMod as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SetToDefault),
            "::",
            stringify!(typeMod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetToDefault>())).collation as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SetToDefault),
            "::",
            stringify!(collation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetToDefault>())).location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SetToDefault),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CurrentOfExpr {
    pub xpr: Expr,
    pub cvarno: Index,
    pub cursor_name: *mut ::std::os::raw::c_char,
    pub cursor_param: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CurrentOfExpr() {
    assert_eq!(
        ::std::mem::size_of::<CurrentOfExpr>(),
        24usize,
        concat!("Size of: ", stringify!(CurrentOfExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<CurrentOfExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(CurrentOfExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CurrentOfExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CurrentOfExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CurrentOfExpr>())).cvarno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CurrentOfExpr),
            "::",
            stringify!(cvarno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CurrentOfExpr>())).cursor_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CurrentOfExpr),
            "::",
            stringify!(cursor_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CurrentOfExpr>())).cursor_param as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CurrentOfExpr),
            "::",
            stringify!(cursor_param)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NextValueExpr {
    pub xpr: Expr,
    pub seqid: Oid,
    pub typeId: Oid,
}
#[test]
fn bindgen_test_layout_NextValueExpr() {
    assert_eq!(
        ::std::mem::size_of::<NextValueExpr>(),
        12usize,
        concat!("Size of: ", stringify!(NextValueExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<NextValueExpr>(),
        4usize,
        concat!("Alignment of ", stringify!(NextValueExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NextValueExpr>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NextValueExpr),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NextValueExpr>())).seqid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NextValueExpr),
            "::",
            stringify!(seqid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NextValueExpr>())).typeId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NextValueExpr),
            "::",
            stringify!(typeId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InferenceElem {
    pub xpr: Expr,
    pub expr: *mut Node,
    pub infercollid: Oid,
    pub inferopclass: Oid,
}
#[test]
fn bindgen_test_layout_InferenceElem() {
    assert_eq!(
        ::std::mem::size_of::<InferenceElem>(),
        24usize,
        concat!("Size of: ", stringify!(InferenceElem))
    );
    assert_eq!(
        ::std::mem::align_of::<InferenceElem>(),
        8usize,
        concat!("Alignment of ", stringify!(InferenceElem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InferenceElem>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InferenceElem),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InferenceElem>())).expr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InferenceElem),
            "::",
            stringify!(expr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InferenceElem>())).infercollid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InferenceElem),
            "::",
            stringify!(infercollid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InferenceElem>())).inferopclass as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(InferenceElem),
            "::",
            stringify!(inferopclass)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TargetEntry {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub resno: AttrNumber,
    pub resname: *mut ::std::os::raw::c_char,
    pub ressortgroupref: Index,
    pub resorigtbl: Oid,
    pub resorigcol: AttrNumber,
    pub resjunk: bool,
}
#[test]
fn bindgen_test_layout_TargetEntry() {
    assert_eq!(
        ::std::mem::size_of::<TargetEntry>(),
        48usize,
        concat!("Size of: ", stringify!(TargetEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<TargetEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(TargetEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TargetEntry>())).xpr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TargetEntry),
            "::",
            stringify!(xpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TargetEntry>())).expr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TargetEntry),
            "::",
            stringify!(expr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TargetEntry>())).resno as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TargetEntry),
            "::",
            stringify!(resno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TargetEntry>())).resname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TargetEntry),
            "::",
            stringify!(resname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TargetEntry>())).ressortgroupref as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TargetEntry),
            "::",
            stringify!(ressortgroupref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TargetEntry>())).resorigtbl as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TargetEntry),
            "::",
            stringify!(resorigtbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TargetEntry>())).resorigcol as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TargetEntry),
            "::",
            stringify!(resorigcol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TargetEntry>())).resjunk as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(TargetEntry),
            "::",
            stringify!(resjunk)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblRef {
    pub type_: NodeTag,
    pub rtindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeTblRef() {
    assert_eq!(
        ::std::mem::size_of::<RangeTblRef>(),
        8usize,
        concat!("Size of: ", stringify!(RangeTblRef))
    );
    assert_eq!(
        ::std::mem::align_of::<RangeTblRef>(),
        4usize,
        concat!("Alignment of ", stringify!(RangeTblRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblRef>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblRef),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblRef>())).rtindex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblRef),
            "::",
            stringify!(rtindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinExpr {
    pub type_: NodeTag,
    pub jointype: JoinType,
    pub isNatural: bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub usingClause: *mut List,
    pub quals: *mut Node,
    pub alias: *mut Alias,
    pub rtindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_JoinExpr() {
    assert_eq!(
        ::std::mem::size_of::<JoinExpr>(),
        64usize,
        concat!("Size of: ", stringify!(JoinExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<JoinExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(JoinExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinExpr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinExpr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinExpr>())).jointype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinExpr),
            "::",
            stringify!(jointype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinExpr>())).isNatural as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinExpr),
            "::",
            stringify!(isNatural)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinExpr>())).larg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinExpr),
            "::",
            stringify!(larg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinExpr>())).rarg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinExpr),
            "::",
            stringify!(rarg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinExpr>())).usingClause as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinExpr),
            "::",
            stringify!(usingClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinExpr>())).quals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinExpr),
            "::",
            stringify!(quals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinExpr>())).alias as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinExpr),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinExpr>())).rtindex as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinExpr),
            "::",
            stringify!(rtindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FromExpr {
    pub type_: NodeTag,
    pub fromlist: *mut List,
    pub quals: *mut Node,
}
#[test]
fn bindgen_test_layout_FromExpr() {
    assert_eq!(
        ::std::mem::size_of::<FromExpr>(),
        24usize,
        concat!("Size of: ", stringify!(FromExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<FromExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(FromExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FromExpr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FromExpr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FromExpr>())).fromlist as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FromExpr),
            "::",
            stringify!(fromlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FromExpr>())).quals as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FromExpr),
            "::",
            stringify!(quals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictExpr {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub arbiterElems: *mut List,
    pub arbiterWhere: *mut Node,
    pub constraint: Oid,
    pub onConflictSet: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelIndex: ::std::os::raw::c_int,
    pub exclRelTlist: *mut List,
}
#[test]
fn bindgen_test_layout_OnConflictExpr() {
    assert_eq!(
        ::std::mem::size_of::<OnConflictExpr>(),
        64usize,
        concat!("Size of: ", stringify!(OnConflictExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<OnConflictExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(OnConflictExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictExpr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictExpr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictExpr>())).action as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictExpr),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictExpr>())).arbiterElems as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictExpr),
            "::",
            stringify!(arbiterElems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictExpr>())).arbiterWhere as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictExpr),
            "::",
            stringify!(arbiterWhere)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictExpr>())).constraint as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictExpr),
            "::",
            stringify!(constraint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictExpr>())).onConflictSet as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictExpr),
            "::",
            stringify!(onConflictSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictExpr>())).onConflictWhere as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictExpr),
            "::",
            stringify!(onConflictWhere)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictExpr>())).exclRelIndex as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictExpr),
            "::",
            stringify!(exclRelIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictExpr>())).exclRelTlist as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictExpr),
            "::",
            stringify!(exclRelTlist)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Value {
    pub type_: NodeTag,
    pub val: Value_ValUnion,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Value_ValUnion {
    pub ival: ::std::os::raw::c_int,
    pub str: *mut ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Value_ValUnion() {
    assert_eq!(
        ::std::mem::size_of::<Value_ValUnion>(),
        8usize,
        concat!("Size of: ", stringify!(Value_ValUnion))
    );
    assert_eq!(
        ::std::mem::align_of::<Value_ValUnion>(),
        8usize,
        concat!("Alignment of ", stringify!(Value_ValUnion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value_ValUnion>())).ival as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Value_ValUnion),
            "::",
            stringify!(ival)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value_ValUnion>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Value_ValUnion),
            "::",
            stringify!(str)
        )
    );
}
#[test]
fn bindgen_test_layout_Value() {
    assert_eq!(
        ::std::mem::size_of::<Value>(),
        16usize,
        concat!("Size of: ", stringify!(Value))
    );
    assert_eq!(
        ::std::mem::align_of::<Value>(),
        8usize,
        concat!("Alignment of ", stringify!(Value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Value),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Value>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Value),
            "::",
            stringify!(val)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_makeInteger"]
    pub fn makeInteger(i: ::std::os::raw::c_int) -> *mut Value;
}
extern "C" {
    #[link_name = "\u{1}_makeFloat"]
    pub fn makeFloat(numericStr: *mut ::std::os::raw::c_char) -> *mut Value;
}
extern "C" {
    #[link_name = "\u{1}_makeString"]
    pub fn makeString(str: *mut ::std::os::raw::c_char) -> *mut Value;
}
extern "C" {
    #[link_name = "\u{1}_makeBitString"]
    pub fn makeBitString(str: *mut ::std::os::raw::c_char) -> *mut Value;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionBoundInfoData {
    _unused: [u8; 0],
}
pub type PartitionBoundInfo = *mut PartitionBoundInfoData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionKeyData {
    _unused: [u8; 0],
}
pub type PartitionKey = *mut PartitionKeyData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionDescData {
    _unused: [u8; 0],
}
pub type PartitionDesc = *mut PartitionDescData;
pub const OverridingKind_OVERRIDING_NOT_SET: OverridingKind = 0;
pub const OverridingKind_OVERRIDING_USER_VALUE: OverridingKind = 1;
pub const OverridingKind_OVERRIDING_SYSTEM_VALUE: OverridingKind = 2;
pub type OverridingKind = u32;
pub const QuerySource_QSRC_ORIGINAL: QuerySource = 0;
pub const QuerySource_QSRC_PARSER: QuerySource = 1;
pub const QuerySource_QSRC_INSTEAD_RULE: QuerySource = 2;
pub const QuerySource_QSRC_QUAL_INSTEAD_RULE: QuerySource = 3;
pub const QuerySource_QSRC_NON_INSTEAD_RULE: QuerySource = 4;
pub type QuerySource = u32;
pub const SortByDir_SORTBY_DEFAULT: SortByDir = 0;
pub const SortByDir_SORTBY_ASC: SortByDir = 1;
pub const SortByDir_SORTBY_DESC: SortByDir = 2;
pub const SortByDir_SORTBY_USING: SortByDir = 3;
pub type SortByDir = u32;
pub const SortByNulls_SORTBY_NULLS_DEFAULT: SortByNulls = 0;
pub const SortByNulls_SORTBY_NULLS_FIRST: SortByNulls = 1;
pub const SortByNulls_SORTBY_NULLS_LAST: SortByNulls = 2;
pub type SortByNulls = u32;
pub type AclMode = uint32;
///	Query Tree
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Query {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub querySource: QuerySource,
    pub queryId: uint64,
    pub canSetTag: bool,
    pub utilityStmt: *mut Node,
    pub resultRelation: ::std::os::raw::c_int,
    pub hasAggs: bool,
    pub hasWindowFuncs: bool,
    pub hasTargetSRFs: bool,
    pub hasSubLinks: bool,
    pub hasDistinctOn: bool,
    pub hasRecursive: bool,
    pub hasModifyingCTE: bool,
    pub hasForUpdate: bool,
    pub hasRowSecurity: bool,
    pub cteList: *mut List,
    pub rtable: *mut List,
    pub jointree: *mut FromExpr,
    pub targetList: *mut List,
    pub override_: OverridingKind,
    pub onConflict: *mut OnConflictExpr,
    pub returningList: *mut List,
    pub groupClause: *mut List,
    pub groupingSets: *mut List,
    pub havingQual: *mut Node,
    pub windowClause: *mut List,
    pub distinctClause: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub rowMarks: *mut List,
    pub setOperations: *mut Node,
    pub constraintDeps: *mut List,
    pub withCheckOptions: *mut List,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Query() {
    assert_eq!(
        ::std::mem::size_of::<Query>(),
        216usize,
        concat!("Size of: ", stringify!(Query))
    );
    assert_eq!(
        ::std::mem::align_of::<Query>(),
        8usize,
        concat!("Alignment of ", stringify!(Query))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).commandType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(commandType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).querySource as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(querySource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).queryId as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(queryId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).canSetTag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(canSetTag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).utilityStmt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(utilityStmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).resultRelation as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(resultRelation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).hasAggs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(hasAggs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).hasWindowFuncs as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(hasWindowFuncs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).hasTargetSRFs as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(hasTargetSRFs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).hasSubLinks as *const _ as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(hasSubLinks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).hasDistinctOn as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(hasDistinctOn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).hasRecursive as *const _ as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(hasRecursive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).hasModifyingCTE as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(hasModifyingCTE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).hasForUpdate as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(hasForUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).hasRowSecurity as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(hasRowSecurity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).cteList as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(cteList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).rtable as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(rtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).jointree as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(jointree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).targetList as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(targetList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).override_ as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(override_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).onConflict as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(onConflict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).returningList as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(returningList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).groupClause as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(groupClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).groupingSets as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(groupingSets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).havingQual as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(havingQual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).windowClause as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(windowClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).distinctClause as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(distinctClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).sortClause as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(sortClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).limitOffset as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(limitOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).limitCount as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(limitCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).rowMarks as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(rowMarks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).setOperations as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(setOperations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).constraintDeps as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(constraintDeps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).withCheckOptions as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(withCheckOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).stmt_location as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(stmt_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Query>())).stmt_len as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(Query),
            "::",
            stringify!(stmt_len)
        )
    );
}
///	Supporting data structures for Parse Trees
///
///	Most of these node types appear in raw parsetrees output by the grammar,
///	and get transformed to something else by the analyzer.  A few of them
///	are used as-is in transformed querytrees.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeName {
    pub type_: NodeTag,
    pub names: *mut List,
    pub typeOid: Oid,
    pub setof: bool,
    pub pct_type: bool,
    pub typmods: *mut List,
    pub typemod: int32,
    pub arrayBounds: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TypeName() {
    assert_eq!(
        ::std::mem::size_of::<TypeName>(),
        56usize,
        concat!("Size of: ", stringify!(TypeName))
    );
    assert_eq!(
        ::std::mem::align_of::<TypeName>(),
        8usize,
        concat!("Alignment of ", stringify!(TypeName))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeName>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeName),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeName>())).names as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeName),
            "::",
            stringify!(names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeName>())).typeOid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeName),
            "::",
            stringify!(typeOid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeName>())).setof as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeName),
            "::",
            stringify!(setof)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeName>())).pct_type as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeName),
            "::",
            stringify!(pct_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeName>())).typmods as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeName),
            "::",
            stringify!(typmods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeName>())).typemod as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeName),
            "::",
            stringify!(typemod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeName>())).arrayBounds as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeName),
            "::",
            stringify!(arrayBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeName>())).location as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeName),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColumnRef {
    pub type_: NodeTag,
    pub fields: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ColumnRef() {
    assert_eq!(
        ::std::mem::size_of::<ColumnRef>(),
        24usize,
        concat!("Size of: ", stringify!(ColumnRef))
    );
    assert_eq!(
        ::std::mem::align_of::<ColumnRef>(),
        8usize,
        concat!("Alignment of ", stringify!(ColumnRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnRef>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnRef),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnRef>())).fields as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnRef),
            "::",
            stringify!(fields)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnRef>())).location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnRef),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamRef {
    pub type_: NodeTag,
    pub number: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ParamRef() {
    assert_eq!(
        ::std::mem::size_of::<ParamRef>(),
        12usize,
        concat!("Size of: ", stringify!(ParamRef))
    );
    assert_eq!(
        ::std::mem::align_of::<ParamRef>(),
        4usize,
        concat!("Alignment of ", stringify!(ParamRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParamRef>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ParamRef),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParamRef>())).number as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ParamRef),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParamRef>())).location as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ParamRef),
            "::",
            stringify!(location)
        )
    );
}
pub const A_Expr_Kind_AEXPR_OP: A_Expr_Kind = 0;
pub const A_Expr_Kind_AEXPR_OP_ANY: A_Expr_Kind = 1;
pub const A_Expr_Kind_AEXPR_OP_ALL: A_Expr_Kind = 2;
pub const A_Expr_Kind_AEXPR_DISTINCT: A_Expr_Kind = 3;
pub const A_Expr_Kind_AEXPR_NOT_DISTINCT: A_Expr_Kind = 4;
pub const A_Expr_Kind_AEXPR_NULLIF: A_Expr_Kind = 5;
pub const A_Expr_Kind_AEXPR_OF: A_Expr_Kind = 6;
pub const A_Expr_Kind_AEXPR_IN: A_Expr_Kind = 7;
pub const A_Expr_Kind_AEXPR_LIKE: A_Expr_Kind = 8;
pub const A_Expr_Kind_AEXPR_ILIKE: A_Expr_Kind = 9;
pub const A_Expr_Kind_AEXPR_SIMILAR: A_Expr_Kind = 10;
pub const A_Expr_Kind_AEXPR_BETWEEN: A_Expr_Kind = 11;
pub const A_Expr_Kind_AEXPR_NOT_BETWEEN: A_Expr_Kind = 12;
pub const A_Expr_Kind_AEXPR_BETWEEN_SYM: A_Expr_Kind = 13;
pub const A_Expr_Kind_AEXPR_NOT_BETWEEN_SYM: A_Expr_Kind = 14;
pub const A_Expr_Kind_AEXPR_PAREN: A_Expr_Kind = 15;
pub type A_Expr_Kind = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Expr {
    pub type_: NodeTag,
    pub kind: A_Expr_Kind,
    pub name: *mut List,
    pub lexpr: *mut Node,
    pub rexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_A_Expr() {
    assert_eq!(
        ::std::mem::size_of::<A_Expr>(),
        40usize,
        concat!("Size of: ", stringify!(A_Expr))
    );
    assert_eq!(
        ::std::mem::align_of::<A_Expr>(),
        8usize,
        concat!("Alignment of ", stringify!(A_Expr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Expr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Expr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Expr>())).kind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Expr),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Expr>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Expr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Expr>())).lexpr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Expr),
            "::",
            stringify!(lexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Expr>())).rexpr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Expr),
            "::",
            stringify!(rexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Expr>())).location as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Expr),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct A_Const {
    pub type_: NodeTag,
    pub val: Value,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_A_Const() {
    assert_eq!(
        ::std::mem::size_of::<A_Const>(),
        32usize,
        concat!("Size of: ", stringify!(A_Const))
    );
    assert_eq!(
        ::std::mem::align_of::<A_Const>(),
        8usize,
        concat!("Alignment of ", stringify!(A_Const))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Const>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Const),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Const>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Const),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Const>())).location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Const),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeCast {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TypeCast() {
    assert_eq!(
        ::std::mem::size_of::<TypeCast>(),
        32usize,
        concat!("Size of: ", stringify!(TypeCast))
    );
    assert_eq!(
        ::std::mem::align_of::<TypeCast>(),
        8usize,
        concat!("Alignment of ", stringify!(TypeCast))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeCast>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeCast),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeCast>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeCast),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeCast>())).typeName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeCast),
            "::",
            stringify!(typeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeCast>())).location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeCast),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollateClause {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub collname: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CollateClause() {
    assert_eq!(
        ::std::mem::size_of::<CollateClause>(),
        32usize,
        concat!("Size of: ", stringify!(CollateClause))
    );
    assert_eq!(
        ::std::mem::align_of::<CollateClause>(),
        8usize,
        concat!("Alignment of ", stringify!(CollateClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CollateClause>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CollateClause),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CollateClause>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CollateClause),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CollateClause>())).collname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CollateClause),
            "::",
            stringify!(collname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CollateClause>())).location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CollateClause),
            "::",
            stringify!(location)
        )
    );
}
pub const RoleSpecType_ROLESPEC_CSTRING: RoleSpecType = 0;
pub const RoleSpecType_ROLESPEC_CURRENT_USER: RoleSpecType = 1;
pub const RoleSpecType_ROLESPEC_SESSION_USER: RoleSpecType = 2;
pub const RoleSpecType_ROLESPEC_PUBLIC: RoleSpecType = 3;
pub type RoleSpecType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RoleSpec {
    pub type_: NodeTag,
    pub roletype: RoleSpecType,
    pub rolename: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RoleSpec() {
    assert_eq!(
        ::std::mem::size_of::<RoleSpec>(),
        24usize,
        concat!("Size of: ", stringify!(RoleSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<RoleSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(RoleSpec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RoleSpec>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RoleSpec),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RoleSpec>())).roletype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RoleSpec),
            "::",
            stringify!(roletype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RoleSpec>())).rolename as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RoleSpec),
            "::",
            stringify!(rolename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RoleSpec>())).location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RoleSpec),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuncCall {
    pub type_: NodeTag,
    pub funcname: *mut List,
    pub args: *mut List,
    pub agg_order: *mut List,
    pub agg_filter: *mut Node,
    pub agg_within_group: bool,
    pub agg_star: bool,
    pub agg_distinct: bool,
    pub func_variadic: bool,
    pub over: *mut WindowDef,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FuncCall() {
    assert_eq!(
        ::std::mem::size_of::<FuncCall>(),
        64usize,
        concat!("Size of: ", stringify!(FuncCall))
    );
    assert_eq!(
        ::std::mem::align_of::<FuncCall>(),
        8usize,
        concat!("Alignment of ", stringify!(FuncCall))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncCall>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncCall),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncCall>())).funcname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncCall),
            "::",
            stringify!(funcname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncCall>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncCall),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncCall>())).agg_order as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncCall),
            "::",
            stringify!(agg_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncCall>())).agg_filter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncCall),
            "::",
            stringify!(agg_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncCall>())).agg_within_group as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncCall),
            "::",
            stringify!(agg_within_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncCall>())).agg_star as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncCall),
            "::",
            stringify!(agg_star)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncCall>())).agg_distinct as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncCall),
            "::",
            stringify!(agg_distinct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncCall>())).func_variadic as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncCall),
            "::",
            stringify!(func_variadic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncCall>())).over as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncCall),
            "::",
            stringify!(over)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FuncCall>())).location as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FuncCall),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Star {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_A_Star() {
    assert_eq!(
        ::std::mem::size_of::<A_Star>(),
        4usize,
        concat!("Size of: ", stringify!(A_Star))
    );
    assert_eq!(
        ::std::mem::align_of::<A_Star>(),
        4usize,
        concat!("Alignment of ", stringify!(A_Star))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Star>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Star),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Indices {
    pub type_: NodeTag,
    pub is_slice: bool,
    pub lidx: *mut Node,
    pub uidx: *mut Node,
}
#[test]
fn bindgen_test_layout_A_Indices() {
    assert_eq!(
        ::std::mem::size_of::<A_Indices>(),
        24usize,
        concat!("Size of: ", stringify!(A_Indices))
    );
    assert_eq!(
        ::std::mem::align_of::<A_Indices>(),
        8usize,
        concat!("Alignment of ", stringify!(A_Indices))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Indices>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Indices),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Indices>())).is_slice as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Indices),
            "::",
            stringify!(is_slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Indices>())).lidx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Indices),
            "::",
            stringify!(lidx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Indices>())).uidx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Indices),
            "::",
            stringify!(uidx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Indirection {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub indirection: *mut List,
}
#[test]
fn bindgen_test_layout_A_Indirection() {
    assert_eq!(
        ::std::mem::size_of::<A_Indirection>(),
        24usize,
        concat!("Size of: ", stringify!(A_Indirection))
    );
    assert_eq!(
        ::std::mem::align_of::<A_Indirection>(),
        8usize,
        concat!("Alignment of ", stringify!(A_Indirection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Indirection>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Indirection),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Indirection>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Indirection),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_Indirection>())).indirection as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(A_Indirection),
            "::",
            stringify!(indirection)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_ArrayExpr {
    pub type_: NodeTag,
    pub elements: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_A_ArrayExpr() {
    assert_eq!(
        ::std::mem::size_of::<A_ArrayExpr>(),
        24usize,
        concat!("Size of: ", stringify!(A_ArrayExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<A_ArrayExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(A_ArrayExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_ArrayExpr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(A_ArrayExpr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_ArrayExpr>())).elements as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(A_ArrayExpr),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<A_ArrayExpr>())).location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(A_ArrayExpr),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResTarget {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub indirection: *mut List,
    pub val: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ResTarget() {
    assert_eq!(
        ::std::mem::size_of::<ResTarget>(),
        40usize,
        concat!("Size of: ", stringify!(ResTarget))
    );
    assert_eq!(
        ::std::mem::align_of::<ResTarget>(),
        8usize,
        concat!("Alignment of ", stringify!(ResTarget))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResTarget>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ResTarget),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResTarget>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ResTarget),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResTarget>())).indirection as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ResTarget),
            "::",
            stringify!(indirection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResTarget>())).val as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ResTarget),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResTarget>())).location as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ResTarget),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MultiAssignRef {
    pub type_: NodeTag,
    pub source: *mut Node,
    pub colno: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MultiAssignRef() {
    assert_eq!(
        ::std::mem::size_of::<MultiAssignRef>(),
        24usize,
        concat!("Size of: ", stringify!(MultiAssignRef))
    );
    assert_eq!(
        ::std::mem::align_of::<MultiAssignRef>(),
        8usize,
        concat!("Alignment of ", stringify!(MultiAssignRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MultiAssignRef>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MultiAssignRef),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MultiAssignRef>())).source as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MultiAssignRef),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MultiAssignRef>())).colno as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MultiAssignRef),
            "::",
            stringify!(colno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MultiAssignRef>())).ncolumns as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MultiAssignRef),
            "::",
            stringify!(ncolumns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortBy {
    pub type_: NodeTag,
    pub node: *mut Node,
    pub sortby_dir: SortByDir,
    pub sortby_nulls: SortByNulls,
    pub useOp: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SortBy() {
    assert_eq!(
        ::std::mem::size_of::<SortBy>(),
        40usize,
        concat!("Size of: ", stringify!(SortBy))
    );
    assert_eq!(
        ::std::mem::align_of::<SortBy>(),
        8usize,
        concat!("Alignment of ", stringify!(SortBy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortBy>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SortBy),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortBy>())).node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SortBy),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortBy>())).sortby_dir as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SortBy),
            "::",
            stringify!(sortby_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortBy>())).sortby_nulls as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SortBy),
            "::",
            stringify!(sortby_nulls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortBy>())).useOp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SortBy),
            "::",
            stringify!(useOp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortBy>())).location as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SortBy),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowDef {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WindowDef() {
    assert_eq!(
        ::std::mem::size_of::<WindowDef>(),
        72usize,
        concat!("Size of: ", stringify!(WindowDef))
    );
    assert_eq!(
        ::std::mem::align_of::<WindowDef>(),
        8usize,
        concat!("Alignment of ", stringify!(WindowDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowDef>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowDef),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowDef>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowDef),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowDef>())).refname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowDef),
            "::",
            stringify!(refname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowDef>())).partitionClause as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowDef),
            "::",
            stringify!(partitionClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowDef>())).orderClause as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowDef),
            "::",
            stringify!(orderClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowDef>())).frameOptions as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowDef),
            "::",
            stringify!(frameOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowDef>())).startOffset as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowDef),
            "::",
            stringify!(startOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowDef>())).endOffset as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowDef),
            "::",
            stringify!(endOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowDef>())).location as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowDef),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeSubselect {
    pub type_: NodeTag,
    pub lateral: bool,
    pub subquery: *mut Node,
    pub alias: *mut Alias,
}
#[test]
fn bindgen_test_layout_RangeSubselect() {
    assert_eq!(
        ::std::mem::size_of::<RangeSubselect>(),
        24usize,
        concat!("Size of: ", stringify!(RangeSubselect))
    );
    assert_eq!(
        ::std::mem::align_of::<RangeSubselect>(),
        8usize,
        concat!("Alignment of ", stringify!(RangeSubselect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeSubselect>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeSubselect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeSubselect>())).lateral as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeSubselect),
            "::",
            stringify!(lateral)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeSubselect>())).subquery as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeSubselect),
            "::",
            stringify!(subquery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeSubselect>())).alias as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeSubselect),
            "::",
            stringify!(alias)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeFunction {
    pub type_: NodeTag,
    pub lateral: bool,
    pub ordinality: bool,
    pub is_rowsfrom: bool,
    pub functions: *mut List,
    pub alias: *mut Alias,
    pub coldeflist: *mut List,
}
#[test]
fn bindgen_test_layout_RangeFunction() {
    assert_eq!(
        ::std::mem::size_of::<RangeFunction>(),
        32usize,
        concat!("Size of: ", stringify!(RangeFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<RangeFunction>(),
        8usize,
        concat!("Alignment of ", stringify!(RangeFunction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeFunction>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeFunction),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeFunction>())).lateral as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeFunction),
            "::",
            stringify!(lateral)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeFunction>())).ordinality as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeFunction),
            "::",
            stringify!(ordinality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeFunction>())).is_rowsfrom as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeFunction),
            "::",
            stringify!(is_rowsfrom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeFunction>())).functions as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeFunction),
            "::",
            stringify!(functions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeFunction>())).alias as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeFunction),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeFunction>())).coldeflist as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeFunction),
            "::",
            stringify!(coldeflist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableFunc {
    pub type_: NodeTag,
    pub lateral: bool,
    pub docexpr: *mut Node,
    pub rowexpr: *mut Node,
    pub namespaces: *mut List,
    pub columns: *mut List,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeTableFunc() {
    assert_eq!(
        ::std::mem::size_of::<RangeTableFunc>(),
        56usize,
        concat!("Size of: ", stringify!(RangeTableFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<RangeTableFunc>(),
        8usize,
        concat!("Alignment of ", stringify!(RangeTableFunc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFunc>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFunc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFunc>())).lateral as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFunc),
            "::",
            stringify!(lateral)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFunc>())).docexpr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFunc),
            "::",
            stringify!(docexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFunc>())).rowexpr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFunc),
            "::",
            stringify!(rowexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFunc>())).namespaces as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFunc),
            "::",
            stringify!(namespaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFunc>())).columns as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFunc),
            "::",
            stringify!(columns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFunc>())).alias as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFunc),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFunc>())).location as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFunc),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableFuncCol {
    pub type_: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub for_ordinality: bool,
    pub is_not_null: bool,
    pub colexpr: *mut Node,
    pub coldefexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeTableFuncCol() {
    assert_eq!(
        ::std::mem::size_of::<RangeTableFuncCol>(),
        56usize,
        concat!("Size of: ", stringify!(RangeTableFuncCol))
    );
    assert_eq!(
        ::std::mem::align_of::<RangeTableFuncCol>(),
        8usize,
        concat!("Alignment of ", stringify!(RangeTableFuncCol))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFuncCol>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFuncCol),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFuncCol>())).colname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFuncCol),
            "::",
            stringify!(colname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFuncCol>())).typeName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFuncCol),
            "::",
            stringify!(typeName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RangeTableFuncCol>())).for_ordinality as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFuncCol),
            "::",
            stringify!(for_ordinality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFuncCol>())).is_not_null as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFuncCol),
            "::",
            stringify!(is_not_null)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFuncCol>())).colexpr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFuncCol),
            "::",
            stringify!(colexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFuncCol>())).coldefexpr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFuncCol),
            "::",
            stringify!(coldefexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableFuncCol>())).location as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableFuncCol),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableSample {
    pub type_: NodeTag,
    pub relation: *mut Node,
    pub method: *mut List,
    pub args: *mut List,
    pub repeatable: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeTableSample() {
    assert_eq!(
        ::std::mem::size_of::<RangeTableSample>(),
        48usize,
        concat!("Size of: ", stringify!(RangeTableSample))
    );
    assert_eq!(
        ::std::mem::align_of::<RangeTableSample>(),
        8usize,
        concat!("Alignment of ", stringify!(RangeTableSample))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableSample>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableSample),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableSample>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableSample),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableSample>())).method as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableSample),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableSample>())).args as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableSample),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableSample>())).repeatable as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableSample),
            "::",
            stringify!(repeatable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTableSample>())).location as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTableSample),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColumnDef {
    pub type_: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub inhcount: ::std::os::raw::c_int,
    pub is_local: bool,
    pub is_not_null: bool,
    pub is_from_type: bool,
    pub is_from_parent: bool,
    pub storage: ::std::os::raw::c_char,
    pub raw_default: *mut Node,
    pub cooked_default: *mut Node,
    pub identity: ::std::os::raw::c_char,
    pub identitySequence: *mut RangeVar,
    pub collClause: *mut CollateClause,
    pub collOid: Oid,
    pub constraints: *mut List,
    pub fdwoptions: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ColumnDef() {
    assert_eq!(
        ::std::mem::size_of::<ColumnDef>(),
        112usize,
        concat!("Size of: ", stringify!(ColumnDef))
    );
    assert_eq!(
        ::std::mem::align_of::<ColumnDef>(),
        8usize,
        concat!("Alignment of ", stringify!(ColumnDef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).colname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(colname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).typeName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(typeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).inhcount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(inhcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).is_local as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(is_local)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).is_not_null as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(is_not_null)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).is_from_type as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(is_from_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).is_from_parent as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(is_from_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).storage as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).raw_default as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(raw_default)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).cooked_default as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(cooked_default)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).identity as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(identity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).identitySequence as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(identitySequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).collClause as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(collClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).collOid as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(collOid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).constraints as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(constraints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).fdwoptions as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(fdwoptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColumnDef>())).location as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ColumnDef),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableLikeClause {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub options: bits32,
}
#[test]
fn bindgen_test_layout_TableLikeClause() {
    assert_eq!(
        ::std::mem::size_of::<TableLikeClause>(),
        24usize,
        concat!("Size of: ", stringify!(TableLikeClause))
    );
    assert_eq!(
        ::std::mem::align_of::<TableLikeClause>(),
        8usize,
        concat!("Alignment of ", stringify!(TableLikeClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableLikeClause>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TableLikeClause),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableLikeClause>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TableLikeClause),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableLikeClause>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TableLikeClause),
            "::",
            stringify!(options)
        )
    );
}
pub const TableLikeOption_CREATE_TABLE_LIKE_COMMENTS: TableLikeOption = 1;
pub const TableLikeOption_CREATE_TABLE_LIKE_CONSTRAINTS: TableLikeOption = 2;
pub const TableLikeOption_CREATE_TABLE_LIKE_DEFAULTS: TableLikeOption = 4;
pub const TableLikeOption_CREATE_TABLE_LIKE_IDENTITY: TableLikeOption = 8;
pub const TableLikeOption_CREATE_TABLE_LIKE_INDEXES: TableLikeOption = 16;
pub const TableLikeOption_CREATE_TABLE_LIKE_STATISTICS: TableLikeOption = 32;
pub const TableLikeOption_CREATE_TABLE_LIKE_STORAGE: TableLikeOption = 64;
pub const TableLikeOption_CREATE_TABLE_LIKE_ALL: TableLikeOption = 2147483647;
pub type TableLikeOption = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexElem {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub indexcolname: *mut ::std::os::raw::c_char,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub ordering: SortByDir,
    pub nulls_ordering: SortByNulls,
}
#[test]
fn bindgen_test_layout_IndexElem() {
    assert_eq!(
        ::std::mem::size_of::<IndexElem>(),
        56usize,
        concat!("Size of: ", stringify!(IndexElem))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexElem>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexElem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexElem>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexElem),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexElem>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexElem),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexElem>())).expr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexElem),
            "::",
            stringify!(expr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexElem>())).indexcolname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexElem),
            "::",
            stringify!(indexcolname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexElem>())).collation as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexElem),
            "::",
            stringify!(collation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexElem>())).opclass as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexElem),
            "::",
            stringify!(opclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexElem>())).ordering as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexElem),
            "::",
            stringify!(ordering)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexElem>())).nulls_ordering as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexElem),
            "::",
            stringify!(nulls_ordering)
        )
    );
}
pub const DefElemAction_DEFELEM_UNSPEC: DefElemAction = 0;
pub const DefElemAction_DEFELEM_SET: DefElemAction = 1;
pub const DefElemAction_DEFELEM_ADD: DefElemAction = 2;
pub const DefElemAction_DEFELEM_DROP: DefElemAction = 3;
pub type DefElemAction = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DefElem {
    pub type_: NodeTag,
    pub defnamespace: *mut ::std::os::raw::c_char,
    pub defname: *mut ::std::os::raw::c_char,
    pub arg: *mut Node,
    pub defaction: DefElemAction,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DefElem() {
    assert_eq!(
        ::std::mem::size_of::<DefElem>(),
        40usize,
        concat!("Size of: ", stringify!(DefElem))
    );
    assert_eq!(
        ::std::mem::align_of::<DefElem>(),
        8usize,
        concat!("Alignment of ", stringify!(DefElem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefElem>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DefElem),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefElem>())).defnamespace as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DefElem),
            "::",
            stringify!(defnamespace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefElem>())).defname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DefElem),
            "::",
            stringify!(defname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefElem>())).arg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DefElem),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefElem>())).defaction as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DefElem),
            "::",
            stringify!(defaction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefElem>())).location as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DefElem),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockingClause {
    pub type_: NodeTag,
    pub lockedRels: *mut List,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
}
#[test]
fn bindgen_test_layout_LockingClause() {
    assert_eq!(
        ::std::mem::size_of::<LockingClause>(),
        24usize,
        concat!("Size of: ", stringify!(LockingClause))
    );
    assert_eq!(
        ::std::mem::align_of::<LockingClause>(),
        8usize,
        concat!("Alignment of ", stringify!(LockingClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockingClause>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LockingClause),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockingClause>())).lockedRels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LockingClause),
            "::",
            stringify!(lockedRels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockingClause>())).strength as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LockingClause),
            "::",
            stringify!(strength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockingClause>())).waitPolicy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LockingClause),
            "::",
            stringify!(waitPolicy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmlSerialize {
    pub type_: NodeTag,
    pub xmloption: XmlOptionType,
    pub expr: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XmlSerialize() {
    assert_eq!(
        ::std::mem::size_of::<XmlSerialize>(),
        32usize,
        concat!("Size of: ", stringify!(XmlSerialize))
    );
    assert_eq!(
        ::std::mem::align_of::<XmlSerialize>(),
        8usize,
        concat!("Alignment of ", stringify!(XmlSerialize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlSerialize>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlSerialize),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlSerialize>())).xmloption as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlSerialize),
            "::",
            stringify!(xmloption)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlSerialize>())).expr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlSerialize),
            "::",
            stringify!(expr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlSerialize>())).typeName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlSerialize),
            "::",
            stringify!(typeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XmlSerialize>())).location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XmlSerialize),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionElem {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PartitionElem() {
    assert_eq!(
        ::std::mem::size_of::<PartitionElem>(),
        48usize,
        concat!("Size of: ", stringify!(PartitionElem))
    );
    assert_eq!(
        ::std::mem::align_of::<PartitionElem>(),
        8usize,
        concat!("Alignment of ", stringify!(PartitionElem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionElem>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionElem),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionElem>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionElem),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionElem>())).expr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionElem),
            "::",
            stringify!(expr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionElem>())).collation as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionElem),
            "::",
            stringify!(collation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionElem>())).opclass as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionElem),
            "::",
            stringify!(opclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionElem>())).location as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionElem),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionSpec {
    pub type_: NodeTag,
    pub strategy: *mut ::std::os::raw::c_char,
    pub partParams: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PartitionSpec() {
    assert_eq!(
        ::std::mem::size_of::<PartitionSpec>(),
        32usize,
        concat!("Size of: ", stringify!(PartitionSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<PartitionSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(PartitionSpec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionSpec>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionSpec),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionSpec>())).strategy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionSpec),
            "::",
            stringify!(strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionSpec>())).partParams as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionSpec),
            "::",
            stringify!(partParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionSpec>())).location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionSpec),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionBoundSpec {
    pub type_: NodeTag,
    pub strategy: ::std::os::raw::c_char,
    pub is_default: bool,
    pub modulus: ::std::os::raw::c_int,
    pub remainder: ::std::os::raw::c_int,
    pub listdatums: *mut List,
    pub lowerdatums: *mut List,
    pub upperdatums: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PartitionBoundSpec() {
    assert_eq!(
        ::std::mem::size_of::<PartitionBoundSpec>(),
        48usize,
        concat!("Size of: ", stringify!(PartitionBoundSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<PartitionBoundSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(PartitionBoundSpec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionBoundSpec>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionBoundSpec),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionBoundSpec>())).strategy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionBoundSpec),
            "::",
            stringify!(strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionBoundSpec>())).is_default as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionBoundSpec),
            "::",
            stringify!(is_default)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionBoundSpec>())).modulus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionBoundSpec),
            "::",
            stringify!(modulus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionBoundSpec>())).remainder as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionBoundSpec),
            "::",
            stringify!(remainder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionBoundSpec>())).listdatums as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionBoundSpec),
            "::",
            stringify!(listdatums)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionBoundSpec>())).lowerdatums as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionBoundSpec),
            "::",
            stringify!(lowerdatums)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionBoundSpec>())).upperdatums as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionBoundSpec),
            "::",
            stringify!(upperdatums)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionBoundSpec>())).location as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionBoundSpec),
            "::",
            stringify!(location)
        )
    );
}
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_MINVALUE: PartitionRangeDatumKind = -1;
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_VALUE: PartitionRangeDatumKind = 0;
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_MAXVALUE: PartitionRangeDatumKind = 1;
pub type PartitionRangeDatumKind = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionRangeDatum {
    pub type_: NodeTag,
    pub kind: PartitionRangeDatumKind,
    pub value: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PartitionRangeDatum() {
    assert_eq!(
        ::std::mem::size_of::<PartitionRangeDatum>(),
        24usize,
        concat!("Size of: ", stringify!(PartitionRangeDatum))
    );
    assert_eq!(
        ::std::mem::align_of::<PartitionRangeDatum>(),
        8usize,
        concat!("Alignment of ", stringify!(PartitionRangeDatum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionRangeDatum>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionRangeDatum),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionRangeDatum>())).kind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionRangeDatum),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionRangeDatum>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionRangeDatum),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionRangeDatum>())).location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionRangeDatum),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionCmd {
    pub type_: NodeTag,
    pub name: *mut RangeVar,
    pub bound: *mut PartitionBoundSpec,
}
#[test]
fn bindgen_test_layout_PartitionCmd() {
    assert_eq!(
        ::std::mem::size_of::<PartitionCmd>(),
        24usize,
        concat!("Size of: ", stringify!(PartitionCmd))
    );
    assert_eq!(
        ::std::mem::align_of::<PartitionCmd>(),
        8usize,
        concat!("Alignment of ", stringify!(PartitionCmd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionCmd>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionCmd),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionCmd>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionCmd),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionCmd>())).bound as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionCmd),
            "::",
            stringify!(bound)
        )
    );
}
pub const RTEKind_RTE_RELATION: RTEKind = 0;
pub const RTEKind_RTE_SUBQUERY: RTEKind = 1;
pub const RTEKind_RTE_JOIN: RTEKind = 2;
pub const RTEKind_RTE_FUNCTION: RTEKind = 3;
pub const RTEKind_RTE_TABLEFUNC: RTEKind = 4;
pub const RTEKind_RTE_VALUES: RTEKind = 5;
pub const RTEKind_RTE_CTE: RTEKind = 6;
pub const RTEKind_RTE_NAMEDTUPLESTORE: RTEKind = 7;
pub type RTEKind = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblEntry {
    pub type_: NodeTag,
    pub rtekind: RTEKind,
    pub relid: Oid,
    pub relkind: ::std::os::raw::c_char,
    pub tablesample: *mut TableSampleClause,
    pub subquery: *mut Query,
    pub security_barrier: bool,
    pub jointype: JoinType,
    pub joinaliasvars: *mut List,
    pub functions: *mut List,
    pub funcordinality: bool,
    pub tablefunc: *mut TableFunc,
    pub values_lists: *mut List,
    pub ctename: *mut ::std::os::raw::c_char,
    pub ctelevelsup: Index,
    pub self_reference: bool,
    pub coltypes: *mut List,
    pub coltypmods: *mut List,
    pub colcollations: *mut List,
    pub enrname: *mut ::std::os::raw::c_char,
    pub enrtuples: f64,
    pub alias: *mut Alias,
    pub eref: *mut Alias,
    pub lateral: bool,
    pub inh: bool,
    pub inFromCl: bool,
    pub requiredPerms: AclMode,
    pub checkAsUser: Oid,
    pub selectedCols: *mut Bitmapset,
    pub insertedCols: *mut Bitmapset,
    pub updatedCols: *mut Bitmapset,
    pub securityQuals: *mut List,
}
#[test]
fn bindgen_test_layout_RangeTblEntry() {
    assert_eq!(
        ::std::mem::size_of::<RangeTblEntry>(),
        200usize,
        concat!("Size of: ", stringify!(RangeTblEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<RangeTblEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(RangeTblEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).rtekind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(rtekind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).relid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(relid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).relkind as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(relkind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).tablesample as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(tablesample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).subquery as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(subquery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).security_barrier as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(security_barrier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).jointype as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(jointype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).joinaliasvars as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(joinaliasvars)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).functions as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(functions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).funcordinality as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(funcordinality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).tablefunc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(tablefunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).values_lists as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(values_lists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).ctename as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(ctename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).ctelevelsup as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(ctelevelsup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).self_reference as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(self_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).coltypes as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(coltypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).coltypmods as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(coltypmods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).colcollations as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(colcollations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).enrname as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(enrname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).enrtuples as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(enrtuples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).alias as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).eref as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(eref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).lateral as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(lateral)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).inh as *const _ as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(inh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).inFromCl as *const _ as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(inFromCl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).requiredPerms as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(requiredPerms)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).checkAsUser as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(checkAsUser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).selectedCols as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(selectedCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).insertedCols as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(insertedCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).updatedCols as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(updatedCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblEntry>())).securityQuals as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblEntry),
            "::",
            stringify!(securityQuals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblFunction {
    pub type_: NodeTag,
    pub funcexpr: *mut Node,
    pub funccolcount: ::std::os::raw::c_int,
    pub funccolnames: *mut List,
    pub funccoltypes: *mut List,
    pub funccoltypmods: *mut List,
    pub funccolcollations: *mut List,
    pub funcparams: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_RangeTblFunction() {
    assert_eq!(
        ::std::mem::size_of::<RangeTblFunction>(),
        64usize,
        concat!("Size of: ", stringify!(RangeTblFunction))
    );
    assert_eq!(
        ::std::mem::align_of::<RangeTblFunction>(),
        8usize,
        concat!("Alignment of ", stringify!(RangeTblFunction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblFunction>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblFunction),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblFunction>())).funcexpr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblFunction),
            "::",
            stringify!(funcexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblFunction>())).funccolcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblFunction),
            "::",
            stringify!(funccolcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblFunction>())).funccolnames as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblFunction),
            "::",
            stringify!(funccolnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblFunction>())).funccoltypes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblFunction),
            "::",
            stringify!(funccoltypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblFunction>())).funccoltypmods as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblFunction),
            "::",
            stringify!(funccoltypmods)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RangeTblFunction>())).funccolcollations as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblFunction),
            "::",
            stringify!(funccolcollations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RangeTblFunction>())).funcparams as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RangeTblFunction),
            "::",
            stringify!(funcparams)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableSampleClause {
    pub type_: NodeTag,
    pub tsmhandler: Oid,
    pub args: *mut List,
    pub repeatable: *mut Expr,
}
#[test]
fn bindgen_test_layout_TableSampleClause() {
    assert_eq!(
        ::std::mem::size_of::<TableSampleClause>(),
        24usize,
        concat!("Size of: ", stringify!(TableSampleClause))
    );
    assert_eq!(
        ::std::mem::align_of::<TableSampleClause>(),
        8usize,
        concat!("Alignment of ", stringify!(TableSampleClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableSampleClause>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TableSampleClause),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableSampleClause>())).tsmhandler as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TableSampleClause),
            "::",
            stringify!(tsmhandler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableSampleClause>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TableSampleClause),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableSampleClause>())).repeatable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TableSampleClause),
            "::",
            stringify!(repeatable)
        )
    );
}
pub const WCOKind_WCO_VIEW_CHECK: WCOKind = 0;
pub const WCOKind_WCO_RLS_INSERT_CHECK: WCOKind = 1;
pub const WCOKind_WCO_RLS_UPDATE_CHECK: WCOKind = 2;
pub const WCOKind_WCO_RLS_CONFLICT_CHECK: WCOKind = 3;
pub type WCOKind = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WithCheckOption {
    pub type_: NodeTag,
    pub kind: WCOKind,
    pub relname: *mut ::std::os::raw::c_char,
    pub polname: *mut ::std::os::raw::c_char,
    pub qual: *mut Node,
    pub cascaded: bool,
}
#[test]
fn bindgen_test_layout_WithCheckOption() {
    assert_eq!(
        ::std::mem::size_of::<WithCheckOption>(),
        40usize,
        concat!("Size of: ", stringify!(WithCheckOption))
    );
    assert_eq!(
        ::std::mem::align_of::<WithCheckOption>(),
        8usize,
        concat!("Alignment of ", stringify!(WithCheckOption))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WithCheckOption>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WithCheckOption),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WithCheckOption>())).kind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WithCheckOption),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WithCheckOption>())).relname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WithCheckOption),
            "::",
            stringify!(relname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WithCheckOption>())).polname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WithCheckOption),
            "::",
            stringify!(polname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WithCheckOption>())).qual as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WithCheckOption),
            "::",
            stringify!(qual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WithCheckOption>())).cascaded as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WithCheckOption),
            "::",
            stringify!(cascaded)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortGroupClause {
    pub type_: NodeTag,
    pub tleSortGroupRef: Index,
    pub eqop: Oid,
    pub sortop: Oid,
    pub nulls_first: bool,
    pub hashable: bool,
}
#[test]
fn bindgen_test_layout_SortGroupClause() {
    assert_eq!(
        ::std::mem::size_of::<SortGroupClause>(),
        20usize,
        concat!("Size of: ", stringify!(SortGroupClause))
    );
    assert_eq!(
        ::std::mem::align_of::<SortGroupClause>(),
        4usize,
        concat!("Alignment of ", stringify!(SortGroupClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortGroupClause>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SortGroupClause),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortGroupClause>())).tleSortGroupRef as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SortGroupClause),
            "::",
            stringify!(tleSortGroupRef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortGroupClause>())).eqop as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SortGroupClause),
            "::",
            stringify!(eqop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortGroupClause>())).sortop as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SortGroupClause),
            "::",
            stringify!(sortop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortGroupClause>())).nulls_first as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SortGroupClause),
            "::",
            stringify!(nulls_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortGroupClause>())).hashable as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SortGroupClause),
            "::",
            stringify!(hashable)
        )
    );
}
pub const GroupingSetKind_GROUPING_SET_EMPTY: GroupingSetKind = 0;
pub const GroupingSetKind_GROUPING_SET_SIMPLE: GroupingSetKind = 1;
pub const GroupingSetKind_GROUPING_SET_ROLLUP: GroupingSetKind = 2;
pub const GroupingSetKind_GROUPING_SET_CUBE: GroupingSetKind = 3;
pub const GroupingSetKind_GROUPING_SET_SETS: GroupingSetKind = 4;
pub type GroupingSetKind = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingSet {
    pub type_: NodeTag,
    pub kind: GroupingSetKind,
    pub content: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GroupingSet() {
    assert_eq!(
        ::std::mem::size_of::<GroupingSet>(),
        24usize,
        concat!("Size of: ", stringify!(GroupingSet))
    );
    assert_eq!(
        ::std::mem::align_of::<GroupingSet>(),
        8usize,
        concat!("Alignment of ", stringify!(GroupingSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupingSet>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupingSet),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupingSet>())).kind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupingSet),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupingSet>())).content as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupingSet),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupingSet>())).location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupingSet),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowClause {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub startInRangeFunc: Oid,
    pub endInRangeFunc: Oid,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub winref: Index,
    pub copiedOrder: bool,
}
#[test]
fn bindgen_test_layout_WindowClause() {
    assert_eq!(
        ::std::mem::size_of::<WindowClause>(),
        88usize,
        concat!("Size of: ", stringify!(WindowClause))
    );
    assert_eq!(
        ::std::mem::align_of::<WindowClause>(),
        8usize,
        concat!("Alignment of ", stringify!(WindowClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).refname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(refname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).partitionClause as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(partitionClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).orderClause as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(orderClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).frameOptions as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(frameOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).startOffset as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(startOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).endOffset as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(endOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).startInRangeFunc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(startInRangeFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).endInRangeFunc as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(endInRangeFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).inRangeColl as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(inRangeColl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).inRangeAsc as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(inRangeAsc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).inRangeNullsFirst as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(inRangeNullsFirst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).winref as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(winref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowClause>())).copiedOrder as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowClause),
            "::",
            stringify!(copiedOrder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowMarkClause {
    pub type_: NodeTag,
    pub rti: Index,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub pushedDown: bool,
}
#[test]
fn bindgen_test_layout_RowMarkClause() {
    assert_eq!(
        ::std::mem::size_of::<RowMarkClause>(),
        20usize,
        concat!("Size of: ", stringify!(RowMarkClause))
    );
    assert_eq!(
        ::std::mem::align_of::<RowMarkClause>(),
        4usize,
        concat!("Alignment of ", stringify!(RowMarkClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowMarkClause>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RowMarkClause),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowMarkClause>())).rti as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RowMarkClause),
            "::",
            stringify!(rti)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowMarkClause>())).strength as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RowMarkClause),
            "::",
            stringify!(strength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowMarkClause>())).waitPolicy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RowMarkClause),
            "::",
            stringify!(waitPolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RowMarkClause>())).pushedDown as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RowMarkClause),
            "::",
            stringify!(pushedDown)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WithClause {
    pub type_: NodeTag,
    pub ctes: *mut List,
    pub recursive: bool,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WithClause() {
    assert_eq!(
        ::std::mem::size_of::<WithClause>(),
        24usize,
        concat!("Size of: ", stringify!(WithClause))
    );
    assert_eq!(
        ::std::mem::align_of::<WithClause>(),
        8usize,
        concat!("Alignment of ", stringify!(WithClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WithClause>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WithClause),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WithClause>())).ctes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WithClause),
            "::",
            stringify!(ctes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WithClause>())).recursive as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WithClause),
            "::",
            stringify!(recursive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WithClause>())).location as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WithClause),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InferClause {
    pub type_: NodeTag,
    pub indexElems: *mut List,
    pub whereClause: *mut Node,
    pub conname: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_InferClause() {
    assert_eq!(
        ::std::mem::size_of::<InferClause>(),
        40usize,
        concat!("Size of: ", stringify!(InferClause))
    );
    assert_eq!(
        ::std::mem::align_of::<InferClause>(),
        8usize,
        concat!("Alignment of ", stringify!(InferClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InferClause>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InferClause),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InferClause>())).indexElems as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InferClause),
            "::",
            stringify!(indexElems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InferClause>())).whereClause as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InferClause),
            "::",
            stringify!(whereClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InferClause>())).conname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(InferClause),
            "::",
            stringify!(conname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InferClause>())).location as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(InferClause),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictClause {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub infer: *mut InferClause,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OnConflictClause() {
    assert_eq!(
        ::std::mem::size_of::<OnConflictClause>(),
        40usize,
        concat!("Size of: ", stringify!(OnConflictClause))
    );
    assert_eq!(
        ::std::mem::align_of::<OnConflictClause>(),
        8usize,
        concat!("Alignment of ", stringify!(OnConflictClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictClause>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictClause),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictClause>())).action as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictClause),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictClause>())).infer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictClause),
            "::",
            stringify!(infer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictClause>())).targetList as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictClause),
            "::",
            stringify!(targetList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictClause>())).whereClause as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictClause),
            "::",
            stringify!(whereClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictClause>())).location as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictClause),
            "::",
            stringify!(location)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommonTableExpr {
    pub type_: NodeTag,
    pub ctename: *mut ::std::os::raw::c_char,
    pub aliascolnames: *mut List,
    pub ctequery: *mut Node,
    pub location: ::std::os::raw::c_int,
    pub cterecursive: bool,
    pub cterefcount: ::std::os::raw::c_int,
    pub ctecolnames: *mut List,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
}
#[test]
fn bindgen_test_layout_CommonTableExpr() {
    assert_eq!(
        ::std::mem::size_of::<CommonTableExpr>(),
        80usize,
        concat!("Size of: ", stringify!(CommonTableExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<CommonTableExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(CommonTableExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommonTableExpr>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CommonTableExpr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommonTableExpr>())).ctename as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CommonTableExpr),
            "::",
            stringify!(ctename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommonTableExpr>())).aliascolnames as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CommonTableExpr),
            "::",
            stringify!(aliascolnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommonTableExpr>())).ctequery as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CommonTableExpr),
            "::",
            stringify!(ctequery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommonTableExpr>())).location as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CommonTableExpr),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommonTableExpr>())).cterecursive as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CommonTableExpr),
            "::",
            stringify!(cterecursive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommonTableExpr>())).cterefcount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CommonTableExpr),
            "::",
            stringify!(cterefcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommonTableExpr>())).ctecolnames as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CommonTableExpr),
            "::",
            stringify!(ctecolnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommonTableExpr>())).ctecoltypes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CommonTableExpr),
            "::",
            stringify!(ctecoltypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommonTableExpr>())).ctecoltypmods as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CommonTableExpr),
            "::",
            stringify!(ctecoltypmods)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CommonTableExpr>())).ctecolcollations as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CommonTableExpr),
            "::",
            stringify!(ctecolcollations)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerTransition {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub isNew: bool,
    pub isTable: bool,
}
#[test]
fn bindgen_test_layout_TriggerTransition() {
    assert_eq!(
        ::std::mem::size_of::<TriggerTransition>(),
        24usize,
        concat!("Size of: ", stringify!(TriggerTransition))
    );
    assert_eq!(
        ::std::mem::align_of::<TriggerTransition>(),
        8usize,
        concat!("Alignment of ", stringify!(TriggerTransition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerTransition>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerTransition),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerTransition>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerTransition),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerTransition>())).isNew as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerTransition),
            "::",
            stringify!(isNew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerTransition>())).isTable as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerTransition),
            "::",
            stringify!(isTable)
        )
    );
}
///		Raw Grammar Output Statements
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RawStmt {
    pub type_: NodeTag,
    pub stmt: *mut Node,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RawStmt() {
    assert_eq!(
        ::std::mem::size_of::<RawStmt>(),
        24usize,
        concat!("Size of: ", stringify!(RawStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<RawStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(RawStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RawStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RawStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RawStmt>())).stmt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RawStmt),
            "::",
            stringify!(stmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RawStmt>())).stmt_location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RawStmt),
            "::",
            stringify!(stmt_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RawStmt>())).stmt_len as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RawStmt),
            "::",
            stringify!(stmt_len)
        )
    );
}
///		Optimizable Statements
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InsertStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cols: *mut List,
    pub selectStmt: *mut Node,
    pub onConflictClause: *mut OnConflictClause,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
    pub override_: OverridingKind,
}
#[test]
fn bindgen_test_layout_InsertStmt() {
    assert_eq!(
        ::std::mem::size_of::<InsertStmt>(),
        64usize,
        concat!("Size of: ", stringify!(InsertStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<InsertStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(InsertStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InsertStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InsertStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InsertStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InsertStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InsertStmt>())).cols as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InsertStmt),
            "::",
            stringify!(cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InsertStmt>())).selectStmt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(InsertStmt),
            "::",
            stringify!(selectStmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InsertStmt>())).onConflictClause as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(InsertStmt),
            "::",
            stringify!(onConflictClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InsertStmt>())).returningList as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(InsertStmt),
            "::",
            stringify!(returningList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InsertStmt>())).withClause as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(InsertStmt),
            "::",
            stringify!(withClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InsertStmt>())).override_ as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(InsertStmt),
            "::",
            stringify!(override_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeleteStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub usingClause: *mut List,
    pub whereClause: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
#[test]
fn bindgen_test_layout_DeleteStmt() {
    assert_eq!(
        ::std::mem::size_of::<DeleteStmt>(),
        48usize,
        concat!("Size of: ", stringify!(DeleteStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DeleteStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DeleteStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeleteStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeleteStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeleteStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DeleteStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeleteStmt>())).usingClause as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DeleteStmt),
            "::",
            stringify!(usingClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeleteStmt>())).whereClause as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DeleteStmt),
            "::",
            stringify!(whereClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeleteStmt>())).returningList as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DeleteStmt),
            "::",
            stringify!(returningList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeleteStmt>())).withClause as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DeleteStmt),
            "::",
            stringify!(withClause)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UpdateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub fromClause: *mut List,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
#[test]
fn bindgen_test_layout_UpdateStmt() {
    assert_eq!(
        ::std::mem::size_of::<UpdateStmt>(),
        56usize,
        concat!("Size of: ", stringify!(UpdateStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<UpdateStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(UpdateStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UpdateStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UpdateStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UpdateStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UpdateStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UpdateStmt>())).targetList as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UpdateStmt),
            "::",
            stringify!(targetList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UpdateStmt>())).whereClause as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UpdateStmt),
            "::",
            stringify!(whereClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UpdateStmt>())).fromClause as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UpdateStmt),
            "::",
            stringify!(fromClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UpdateStmt>())).returningList as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UpdateStmt),
            "::",
            stringify!(returningList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UpdateStmt>())).withClause as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UpdateStmt),
            "::",
            stringify!(withClause)
        )
    );
}
pub const SetOperation_SETOP_NONE: SetOperation = 0;
pub const SetOperation_SETOP_UNION: SetOperation = 1;
pub const SetOperation_SETOP_INTERSECT: SetOperation = 2;
pub const SetOperation_SETOP_EXCEPT: SetOperation = 3;
pub type SetOperation = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SelectStmt {
    pub type_: NodeTag,
    pub distinctClause: *mut List,
    pub intoClause: *mut IntoClause,
    pub targetList: *mut List,
    pub fromClause: *mut List,
    pub whereClause: *mut Node,
    pub groupClause: *mut List,
    pub havingClause: *mut Node,
    pub windowClause: *mut List,
    pub valuesLists: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub lockingClause: *mut List,
    pub withClause: *mut WithClause,
    pub op: SetOperation,
    pub all: bool,
    pub larg: *mut SelectStmt,
    pub rarg: *mut SelectStmt,
}
#[test]
fn bindgen_test_layout_SelectStmt() {
    assert_eq!(
        ::std::mem::size_of::<SelectStmt>(),
        144usize,
        concat!("Size of: ", stringify!(SelectStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<SelectStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(SelectStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).distinctClause as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(distinctClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).intoClause as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(intoClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).targetList as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(targetList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).fromClause as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(fromClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).whereClause as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(whereClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).groupClause as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(groupClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).havingClause as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(havingClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).windowClause as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(windowClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).valuesLists as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(valuesLists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).sortClause as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(sortClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).limitOffset as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(limitOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).limitCount as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(limitCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).lockingClause as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(lockingClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).withClause as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(withClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).op as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).all as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(all)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).larg as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(larg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SelectStmt>())).rarg as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SelectStmt),
            "::",
            stringify!(rarg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOperationStmt {
    pub type_: NodeTag,
    pub op: SetOperation,
    pub all: bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub colTypes: *mut List,
    pub colTypmods: *mut List,
    pub colCollations: *mut List,
    pub groupClauses: *mut List,
}
#[test]
fn bindgen_test_layout_SetOperationStmt() {
    assert_eq!(
        ::std::mem::size_of::<SetOperationStmt>(),
        64usize,
        concat!("Size of: ", stringify!(SetOperationStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<SetOperationStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(SetOperationStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOperationStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOperationStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOperationStmt>())).op as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOperationStmt),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOperationStmt>())).all as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOperationStmt),
            "::",
            stringify!(all)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOperationStmt>())).larg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOperationStmt),
            "::",
            stringify!(larg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOperationStmt>())).rarg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOperationStmt),
            "::",
            stringify!(rarg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOperationStmt>())).colTypes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOperationStmt),
            "::",
            stringify!(colTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOperationStmt>())).colTypmods as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOperationStmt),
            "::",
            stringify!(colTypmods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOperationStmt>())).colCollations as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOperationStmt),
            "::",
            stringify!(colCollations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOperationStmt>())).groupClauses as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOperationStmt),
            "::",
            stringify!(groupClauses)
        )
    );
}
pub const ObjectType_OBJECT_ACCESS_METHOD: ObjectType = 0;
pub const ObjectType_OBJECT_AGGREGATE: ObjectType = 1;
pub const ObjectType_OBJECT_AMOP: ObjectType = 2;
pub const ObjectType_OBJECT_AMPROC: ObjectType = 3;
pub const ObjectType_OBJECT_ATTRIBUTE: ObjectType = 4;
pub const ObjectType_OBJECT_CAST: ObjectType = 5;
pub const ObjectType_OBJECT_COLUMN: ObjectType = 6;
pub const ObjectType_OBJECT_COLLATION: ObjectType = 7;
pub const ObjectType_OBJECT_CONVERSION: ObjectType = 8;
pub const ObjectType_OBJECT_DATABASE: ObjectType = 9;
pub const ObjectType_OBJECT_DEFAULT: ObjectType = 10;
pub const ObjectType_OBJECT_DEFACL: ObjectType = 11;
pub const ObjectType_OBJECT_DOMAIN: ObjectType = 12;
pub const ObjectType_OBJECT_DOMCONSTRAINT: ObjectType = 13;
pub const ObjectType_OBJECT_EVENT_TRIGGER: ObjectType = 14;
pub const ObjectType_OBJECT_EXTENSION: ObjectType = 15;
pub const ObjectType_OBJECT_FDW: ObjectType = 16;
pub const ObjectType_OBJECT_FOREIGN_SERVER: ObjectType = 17;
pub const ObjectType_OBJECT_FOREIGN_TABLE: ObjectType = 18;
pub const ObjectType_OBJECT_FUNCTION: ObjectType = 19;
pub const ObjectType_OBJECT_INDEX: ObjectType = 20;
pub const ObjectType_OBJECT_LANGUAGE: ObjectType = 21;
pub const ObjectType_OBJECT_LARGEOBJECT: ObjectType = 22;
pub const ObjectType_OBJECT_MATVIEW: ObjectType = 23;
pub const ObjectType_OBJECT_OPCLASS: ObjectType = 24;
pub const ObjectType_OBJECT_OPERATOR: ObjectType = 25;
pub const ObjectType_OBJECT_OPFAMILY: ObjectType = 26;
pub const ObjectType_OBJECT_POLICY: ObjectType = 27;
pub const ObjectType_OBJECT_PROCEDURE: ObjectType = 28;
pub const ObjectType_OBJECT_PUBLICATION: ObjectType = 29;
pub const ObjectType_OBJECT_PUBLICATION_REL: ObjectType = 30;
pub const ObjectType_OBJECT_ROLE: ObjectType = 31;
pub const ObjectType_OBJECT_ROUTINE: ObjectType = 32;
pub const ObjectType_OBJECT_RULE: ObjectType = 33;
pub const ObjectType_OBJECT_SCHEMA: ObjectType = 34;
pub const ObjectType_OBJECT_SEQUENCE: ObjectType = 35;
pub const ObjectType_OBJECT_SUBSCRIPTION: ObjectType = 36;
pub const ObjectType_OBJECT_STATISTIC_EXT: ObjectType = 37;
pub const ObjectType_OBJECT_TABCONSTRAINT: ObjectType = 38;
pub const ObjectType_OBJECT_TABLE: ObjectType = 39;
pub const ObjectType_OBJECT_TABLESPACE: ObjectType = 40;
pub const ObjectType_OBJECT_TRANSFORM: ObjectType = 41;
pub const ObjectType_OBJECT_TRIGGER: ObjectType = 42;
pub const ObjectType_OBJECT_TSCONFIGURATION: ObjectType = 43;
pub const ObjectType_OBJECT_TSDICTIONARY: ObjectType = 44;
pub const ObjectType_OBJECT_TSPARSER: ObjectType = 45;
pub const ObjectType_OBJECT_TSTEMPLATE: ObjectType = 46;
pub const ObjectType_OBJECT_TYPE: ObjectType = 47;
pub const ObjectType_OBJECT_USER_MAPPING: ObjectType = 48;
pub const ObjectType_OBJECT_VIEW: ObjectType = 49;
///		Other Statements (no optimizations required)
///
///		These are not touched by parser/analyze.c except to put them into
///		the utilityStmt field of a Query.  This is eventually passed to
///		ProcessUtility (by-passing rewriting and planning).  Some of the
///		statements do need attention from parse analysis, and this is
///		done by routines in parser/parse_utilcmd.c after ProcessUtility
///		receives the command for execution.
///		DECLARE CURSOR, EXPLAIN, and CREATE TABLE AS are special cases:
///		they contain optimizable statements, which get processed normally
///		by parser/analyze.c.
pub type ObjectType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSchemaStmt {
    pub type_: NodeTag,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub authrole: *mut RoleSpec,
    pub schemaElts: *mut List,
    pub if_not_exists: bool,
}
#[test]
fn bindgen_test_layout_CreateSchemaStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateSchemaStmt>(),
        40usize,
        concat!("Size of: ", stringify!(CreateSchemaStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateSchemaStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateSchemaStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSchemaStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSchemaStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSchemaStmt>())).schemaname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSchemaStmt),
            "::",
            stringify!(schemaname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSchemaStmt>())).authrole as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSchemaStmt),
            "::",
            stringify!(authrole)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSchemaStmt>())).schemaElts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSchemaStmt),
            "::",
            stringify!(schemaElts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSchemaStmt>())).if_not_exists as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSchemaStmt),
            "::",
            stringify!(if_not_exists)
        )
    );
}
pub const DropBehavior_DROP_RESTRICT: DropBehavior = 0;
pub const DropBehavior_DROP_CASCADE: DropBehavior = 1;
pub type DropBehavior = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cmds: *mut List,
    pub relkind: ObjectType,
    pub missing_ok: bool,
}
#[test]
fn bindgen_test_layout_AlterTableStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterTableStmt>(),
        32usize,
        concat!("Size of: ", stringify!(AlterTableStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterTableStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterTableStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableStmt>())).cmds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableStmt),
            "::",
            stringify!(cmds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableStmt>())).relkind as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableStmt),
            "::",
            stringify!(relkind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableStmt>())).missing_ok as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableStmt),
            "::",
            stringify!(missing_ok)
        )
    );
}
pub const AlterTableType_AT_AddColumn: AlterTableType = 0;
pub const AlterTableType_AT_AddColumnRecurse: AlterTableType = 1;
pub const AlterTableType_AT_AddColumnToView: AlterTableType = 2;
pub const AlterTableType_AT_ColumnDefault: AlterTableType = 3;
pub const AlterTableType_AT_DropNotNull: AlterTableType = 4;
pub const AlterTableType_AT_SetNotNull: AlterTableType = 5;
pub const AlterTableType_AT_SetStatistics: AlterTableType = 6;
pub const AlterTableType_AT_SetOptions: AlterTableType = 7;
pub const AlterTableType_AT_ResetOptions: AlterTableType = 8;
pub const AlterTableType_AT_SetStorage: AlterTableType = 9;
pub const AlterTableType_AT_DropColumn: AlterTableType = 10;
pub const AlterTableType_AT_DropColumnRecurse: AlterTableType = 11;
pub const AlterTableType_AT_AddIndex: AlterTableType = 12;
pub const AlterTableType_AT_ReAddIndex: AlterTableType = 13;
pub const AlterTableType_AT_AddConstraint: AlterTableType = 14;
pub const AlterTableType_AT_AddConstraintRecurse: AlterTableType = 15;
pub const AlterTableType_AT_ReAddConstraint: AlterTableType = 16;
pub const AlterTableType_AT_ReAddDomainConstraint: AlterTableType = 17;
pub const AlterTableType_AT_AlterConstraint: AlterTableType = 18;
pub const AlterTableType_AT_ValidateConstraint: AlterTableType = 19;
pub const AlterTableType_AT_ValidateConstraintRecurse: AlterTableType = 20;
pub const AlterTableType_AT_ProcessedConstraint: AlterTableType = 21;
pub const AlterTableType_AT_AddIndexConstraint: AlterTableType = 22;
pub const AlterTableType_AT_DropConstraint: AlterTableType = 23;
pub const AlterTableType_AT_DropConstraintRecurse: AlterTableType = 24;
pub const AlterTableType_AT_ReAddComment: AlterTableType = 25;
pub const AlterTableType_AT_AlterColumnType: AlterTableType = 26;
pub const AlterTableType_AT_AlterColumnGenericOptions: AlterTableType = 27;
pub const AlterTableType_AT_ChangeOwner: AlterTableType = 28;
pub const AlterTableType_AT_ClusterOn: AlterTableType = 29;
pub const AlterTableType_AT_DropCluster: AlterTableType = 30;
pub const AlterTableType_AT_SetLogged: AlterTableType = 31;
pub const AlterTableType_AT_SetUnLogged: AlterTableType = 32;
pub const AlterTableType_AT_AddOids: AlterTableType = 33;
pub const AlterTableType_AT_AddOidsRecurse: AlterTableType = 34;
pub const AlterTableType_AT_DropOids: AlterTableType = 35;
pub const AlterTableType_AT_SetTableSpace: AlterTableType = 36;
pub const AlterTableType_AT_SetRelOptions: AlterTableType = 37;
pub const AlterTableType_AT_ResetRelOptions: AlterTableType = 38;
pub const AlterTableType_AT_ReplaceRelOptions: AlterTableType = 39;
pub const AlterTableType_AT_EnableTrig: AlterTableType = 40;
pub const AlterTableType_AT_EnableAlwaysTrig: AlterTableType = 41;
pub const AlterTableType_AT_EnableReplicaTrig: AlterTableType = 42;
pub const AlterTableType_AT_DisableTrig: AlterTableType = 43;
pub const AlterTableType_AT_EnableTrigAll: AlterTableType = 44;
pub const AlterTableType_AT_DisableTrigAll: AlterTableType = 45;
pub const AlterTableType_AT_EnableTrigUser: AlterTableType = 46;
pub const AlterTableType_AT_DisableTrigUser: AlterTableType = 47;
pub const AlterTableType_AT_EnableRule: AlterTableType = 48;
pub const AlterTableType_AT_EnableAlwaysRule: AlterTableType = 49;
pub const AlterTableType_AT_EnableReplicaRule: AlterTableType = 50;
pub const AlterTableType_AT_DisableRule: AlterTableType = 51;
pub const AlterTableType_AT_AddInherit: AlterTableType = 52;
pub const AlterTableType_AT_DropInherit: AlterTableType = 53;
pub const AlterTableType_AT_AddOf: AlterTableType = 54;
pub const AlterTableType_AT_DropOf: AlterTableType = 55;
pub const AlterTableType_AT_ReplicaIdentity: AlterTableType = 56;
pub const AlterTableType_AT_EnableRowSecurity: AlterTableType = 57;
pub const AlterTableType_AT_DisableRowSecurity: AlterTableType = 58;
pub const AlterTableType_AT_ForceRowSecurity: AlterTableType = 59;
pub const AlterTableType_AT_NoForceRowSecurity: AlterTableType = 60;
pub const AlterTableType_AT_GenericOptions: AlterTableType = 61;
pub const AlterTableType_AT_AttachPartition: AlterTableType = 62;
pub const AlterTableType_AT_DetachPartition: AlterTableType = 63;
pub const AlterTableType_AT_AddIdentity: AlterTableType = 64;
pub const AlterTableType_AT_SetIdentity: AlterTableType = 65;
pub const AlterTableType_AT_DropIdentity: AlterTableType = 66;
pub type AlterTableType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReplicaIdentityStmt {
    pub type_: NodeTag,
    pub identity_type: ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ReplicaIdentityStmt() {
    assert_eq!(
        ::std::mem::size_of::<ReplicaIdentityStmt>(),
        16usize,
        concat!("Size of: ", stringify!(ReplicaIdentityStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<ReplicaIdentityStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(ReplicaIdentityStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReplicaIdentityStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ReplicaIdentityStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ReplicaIdentityStmt>())).identity_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ReplicaIdentityStmt),
            "::",
            stringify!(identity_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReplicaIdentityStmt>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ReplicaIdentityStmt),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableCmd {
    pub type_: NodeTag,
    pub subtype: AlterTableType,
    pub name: *mut ::std::os::raw::c_char,
    pub num: int16,
    pub newowner: *mut RoleSpec,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
}
#[test]
fn bindgen_test_layout_AlterTableCmd() {
    assert_eq!(
        ::std::mem::size_of::<AlterTableCmd>(),
        48usize,
        concat!("Size of: ", stringify!(AlterTableCmd))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterTableCmd>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterTableCmd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableCmd>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableCmd),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableCmd>())).subtype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableCmd),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableCmd>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableCmd),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableCmd>())).num as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableCmd),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableCmd>())).newowner as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableCmd),
            "::",
            stringify!(newowner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableCmd>())).def as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableCmd),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableCmd>())).behavior as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableCmd),
            "::",
            stringify!(behavior)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableCmd>())).missing_ok as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableCmd),
            "::",
            stringify!(missing_ok)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterCollationStmt {
    pub type_: NodeTag,
    pub collname: *mut List,
}
#[test]
fn bindgen_test_layout_AlterCollationStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterCollationStmt>(),
        16usize,
        concat!("Size of: ", stringify!(AlterCollationStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterCollationStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterCollationStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterCollationStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterCollationStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterCollationStmt>())).collname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterCollationStmt),
            "::",
            stringify!(collname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDomainStmt {
    pub type_: NodeTag,
    pub subtype: ::std::os::raw::c_char,
    pub typeName: *mut List,
    pub name: *mut ::std::os::raw::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
}
#[test]
fn bindgen_test_layout_AlterDomainStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterDomainStmt>(),
        40usize,
        concat!("Size of: ", stringify!(AlterDomainStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterDomainStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterDomainStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDomainStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDomainStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDomainStmt>())).subtype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDomainStmt),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDomainStmt>())).typeName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDomainStmt),
            "::",
            stringify!(typeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDomainStmt>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDomainStmt),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDomainStmt>())).def as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDomainStmt),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDomainStmt>())).behavior as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDomainStmt),
            "::",
            stringify!(behavior)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDomainStmt>())).missing_ok as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDomainStmt),
            "::",
            stringify!(missing_ok)
        )
    );
}
pub const GrantTargetType_ACL_TARGET_OBJECT: GrantTargetType = 0;
pub const GrantTargetType_ACL_TARGET_ALL_IN_SCHEMA: GrantTargetType = 1;
pub const GrantTargetType_ACL_TARGET_DEFAULTS: GrantTargetType = 2;
pub type GrantTargetType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrantStmt {
    pub type_: NodeTag,
    pub is_grant: bool,
    pub targtype: GrantTargetType,
    pub objtype: ObjectType,
    pub objects: *mut List,
    pub privileges: *mut List,
    pub grantees: *mut List,
    pub grant_option: bool,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_GrantStmt() {
    assert_eq!(
        ::std::mem::size_of::<GrantStmt>(),
        48usize,
        concat!("Size of: ", stringify!(GrantStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<GrantStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(GrantStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantStmt>())).is_grant as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantStmt),
            "::",
            stringify!(is_grant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantStmt>())).targtype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantStmt),
            "::",
            stringify!(targtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantStmt>())).objtype as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantStmt),
            "::",
            stringify!(objtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantStmt>())).objects as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantStmt),
            "::",
            stringify!(objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantStmt>())).privileges as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantStmt),
            "::",
            stringify!(privileges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantStmt>())).grantees as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantStmt),
            "::",
            stringify!(grantees)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantStmt>())).grant_option as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantStmt),
            "::",
            stringify!(grant_option)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantStmt>())).behavior as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantStmt),
            "::",
            stringify!(behavior)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectWithArgs {
    pub type_: NodeTag,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub args_unspecified: bool,
}
#[test]
fn bindgen_test_layout_ObjectWithArgs() {
    assert_eq!(
        ::std::mem::size_of::<ObjectWithArgs>(),
        32usize,
        concat!("Size of: ", stringify!(ObjectWithArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<ObjectWithArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjectWithArgs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjectWithArgs>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectWithArgs),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjectWithArgs>())).objname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectWithArgs),
            "::",
            stringify!(objname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjectWithArgs>())).objargs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectWithArgs),
            "::",
            stringify!(objargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjectWithArgs>())).args_unspecified as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectWithArgs),
            "::",
            stringify!(args_unspecified)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccessPriv {
    pub type_: NodeTag,
    pub priv_name: *mut ::std::os::raw::c_char,
    pub cols: *mut List,
}
#[test]
fn bindgen_test_layout_AccessPriv() {
    assert_eq!(
        ::std::mem::size_of::<AccessPriv>(),
        24usize,
        concat!("Size of: ", stringify!(AccessPriv))
    );
    assert_eq!(
        ::std::mem::align_of::<AccessPriv>(),
        8usize,
        concat!("Alignment of ", stringify!(AccessPriv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccessPriv>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AccessPriv),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccessPriv>())).priv_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AccessPriv),
            "::",
            stringify!(priv_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AccessPriv>())).cols as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AccessPriv),
            "::",
            stringify!(cols)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrantRoleStmt {
    pub type_: NodeTag,
    pub granted_roles: *mut List,
    pub grantee_roles: *mut List,
    pub is_grant: bool,
    pub admin_opt: bool,
    pub grantor: *mut RoleSpec,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_GrantRoleStmt() {
    assert_eq!(
        ::std::mem::size_of::<GrantRoleStmt>(),
        48usize,
        concat!("Size of: ", stringify!(GrantRoleStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<GrantRoleStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(GrantRoleStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantRoleStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantRoleStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantRoleStmt>())).granted_roles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantRoleStmt),
            "::",
            stringify!(granted_roles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantRoleStmt>())).grantee_roles as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantRoleStmt),
            "::",
            stringify!(grantee_roles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantRoleStmt>())).is_grant as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantRoleStmt),
            "::",
            stringify!(is_grant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantRoleStmt>())).admin_opt as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantRoleStmt),
            "::",
            stringify!(admin_opt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantRoleStmt>())).grantor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantRoleStmt),
            "::",
            stringify!(grantor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GrantRoleStmt>())).behavior as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GrantRoleStmt),
            "::",
            stringify!(behavior)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDefaultPrivilegesStmt {
    pub type_: NodeTag,
    pub options: *mut List,
    pub action: *mut GrantStmt,
}
#[test]
fn bindgen_test_layout_AlterDefaultPrivilegesStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterDefaultPrivilegesStmt>(),
        24usize,
        concat!("Size of: ", stringify!(AlterDefaultPrivilegesStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterDefaultPrivilegesStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterDefaultPrivilegesStmt))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterDefaultPrivilegesStmt>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDefaultPrivilegesStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterDefaultPrivilegesStmt>())).options as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDefaultPrivilegesStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterDefaultPrivilegesStmt>())).action as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDefaultPrivilegesStmt),
            "::",
            stringify!(action)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CopyStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub query: *mut Node,
    pub attlist: *mut List,
    pub is_from: bool,
    pub is_program: bool,
    pub filename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CopyStmt() {
    assert_eq!(
        ::std::mem::size_of::<CopyStmt>(),
        56usize,
        concat!("Size of: ", stringify!(CopyStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CopyStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CopyStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CopyStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CopyStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CopyStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CopyStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CopyStmt>())).query as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CopyStmt),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CopyStmt>())).attlist as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CopyStmt),
            "::",
            stringify!(attlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CopyStmt>())).is_from as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CopyStmt),
            "::",
            stringify!(is_from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CopyStmt>())).is_program as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(CopyStmt),
            "::",
            stringify!(is_program)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CopyStmt>())).filename as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CopyStmt),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CopyStmt>())).options as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CopyStmt),
            "::",
            stringify!(options)
        )
    );
}
pub const VariableSetKind_VAR_SET_VALUE: VariableSetKind = 0;
pub const VariableSetKind_VAR_SET_DEFAULT: VariableSetKind = 1;
pub const VariableSetKind_VAR_SET_CURRENT: VariableSetKind = 2;
pub const VariableSetKind_VAR_SET_MULTI: VariableSetKind = 3;
pub const VariableSetKind_VAR_RESET: VariableSetKind = 4;
pub const VariableSetKind_VAR_RESET_ALL: VariableSetKind = 5;
pub type VariableSetKind = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableSetStmt {
    pub type_: NodeTag,
    pub kind: VariableSetKind,
    pub name: *mut ::std::os::raw::c_char,
    pub args: *mut List,
    pub is_local: bool,
}
#[test]
fn bindgen_test_layout_VariableSetStmt() {
    assert_eq!(
        ::std::mem::size_of::<VariableSetStmt>(),
        32usize,
        concat!("Size of: ", stringify!(VariableSetStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<VariableSetStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(VariableSetStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VariableSetStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableSetStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VariableSetStmt>())).kind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableSetStmt),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VariableSetStmt>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableSetStmt),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VariableSetStmt>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableSetStmt),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VariableSetStmt>())).is_local as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableSetStmt),
            "::",
            stringify!(is_local)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableShowStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VariableShowStmt() {
    assert_eq!(
        ::std::mem::size_of::<VariableShowStmt>(),
        16usize,
        concat!("Size of: ", stringify!(VariableShowStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<VariableShowStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(VariableShowStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VariableShowStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableShowStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VariableShowStmt>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VariableShowStmt),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub tableElts: *mut List,
    pub inhRelations: *mut List,
    pub partbound: *mut PartitionBoundSpec,
    pub partspec: *mut PartitionSpec,
    pub ofTypename: *mut TypeName,
    pub constraints: *mut List,
    pub options: *mut List,
    pub oncommit: OnCommitAction,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
}
#[test]
fn bindgen_test_layout_CreateStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateStmt>(),
        96usize,
        concat!("Size of: ", stringify!(CreateStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).tableElts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(tableElts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).inhRelations as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(inhRelations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).partbound as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(partbound)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).partspec as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(partspec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).ofTypename as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(ofTypename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).constraints as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(constraints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).options as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).oncommit as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(oncommit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).tablespacename as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(tablespacename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStmt>())).if_not_exists as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStmt),
            "::",
            stringify!(if_not_exists)
        )
    );
}
pub const ConstrType_CONSTR_NULL: ConstrType = 0;
pub const ConstrType_CONSTR_NOTNULL: ConstrType = 1;
pub const ConstrType_CONSTR_DEFAULT: ConstrType = 2;
pub const ConstrType_CONSTR_IDENTITY: ConstrType = 3;
pub const ConstrType_CONSTR_CHECK: ConstrType = 4;
pub const ConstrType_CONSTR_PRIMARY: ConstrType = 5;
pub const ConstrType_CONSTR_UNIQUE: ConstrType = 6;
pub const ConstrType_CONSTR_EXCLUSION: ConstrType = 7;
pub const ConstrType_CONSTR_FOREIGN: ConstrType = 8;
pub const ConstrType_CONSTR_ATTR_DEFERRABLE: ConstrType = 9;
pub const ConstrType_CONSTR_ATTR_NOT_DEFERRABLE: ConstrType = 10;
pub const ConstrType_CONSTR_ATTR_DEFERRED: ConstrType = 11;
pub const ConstrType_CONSTR_ATTR_IMMEDIATE: ConstrType = 12;
pub type ConstrType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Constraint {
    pub type_: NodeTag,
    pub contype: ConstrType,
    pub conname: *mut ::std::os::raw::c_char,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub location: ::std::os::raw::c_int,
    pub is_no_inherit: bool,
    pub raw_expr: *mut Node,
    pub cooked_expr: *mut ::std::os::raw::c_char,
    pub generated_when: ::std::os::raw::c_char,
    pub keys: *mut List,
    pub including: *mut List,
    pub exclusions: *mut List,
    pub options: *mut List,
    pub indexname: *mut ::std::os::raw::c_char,
    pub indexspace: *mut ::std::os::raw::c_char,
    pub access_method: *mut ::std::os::raw::c_char,
    pub where_clause: *mut Node,
    pub pktable: *mut RangeVar,
    pub fk_attrs: *mut List,
    pub pk_attrs: *mut List,
    pub fk_matchtype: ::std::os::raw::c_char,
    pub fk_upd_action: ::std::os::raw::c_char,
    pub fk_del_action: ::std::os::raw::c_char,
    pub old_conpfeqop: *mut List,
    pub old_pktable_oid: Oid,
    pub skip_validation: bool,
    pub initially_valid: bool,
}
#[test]
fn bindgen_test_layout_Constraint() {
    assert_eq!(
        ::std::mem::size_of::<Constraint>(),
        168usize,
        concat!("Size of: ", stringify!(Constraint))
    );
    assert_eq!(
        ::std::mem::align_of::<Constraint>(),
        8usize,
        concat!("Alignment of ", stringify!(Constraint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).contype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(contype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).conname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(conname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).deferrable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(deferrable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).initdeferred as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(initdeferred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).location as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).is_no_inherit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(is_no_inherit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).raw_expr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(raw_expr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).cooked_expr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(cooked_expr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).generated_when as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(generated_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).keys as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).including as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(including)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).exclusions as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(exclusions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).options as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).indexname as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(indexname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).indexspace as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(indexspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).access_method as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(access_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).where_clause as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(where_clause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).pktable as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(pktable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).fk_attrs as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(fk_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).pk_attrs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(pk_attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).fk_matchtype as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(fk_matchtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).fk_upd_action as *const _ as usize },
        145usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(fk_upd_action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).fk_del_action as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(fk_del_action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).old_conpfeqop as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(old_conpfeqop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).old_pktable_oid as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(old_pktable_oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).skip_validation as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(skip_validation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Constraint>())).initially_valid as *const _ as usize },
        165usize,
        concat!(
            "Offset of field: ",
            stringify!(Constraint),
            "::",
            stringify!(initially_valid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub owner: *mut RoleSpec,
    pub location: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateTableSpaceStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateTableSpaceStmt>(),
        40usize,
        concat!("Size of: ", stringify!(CreateTableSpaceStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateTableSpaceStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateTableSpaceStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTableSpaceStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTableSpaceStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateTableSpaceStmt>())).tablespacename as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTableSpaceStmt),
            "::",
            stringify!(tablespacename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTableSpaceStmt>())).owner as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTableSpaceStmt),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTableSpaceStmt>())).location as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTableSpaceStmt),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTableSpaceStmt>())).options as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTableSpaceStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
}
#[test]
fn bindgen_test_layout_DropTableSpaceStmt() {
    assert_eq!(
        ::std::mem::size_of::<DropTableSpaceStmt>(),
        24usize,
        concat!("Size of: ", stringify!(DropTableSpaceStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DropTableSpaceStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DropTableSpaceStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropTableSpaceStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DropTableSpaceStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DropTableSpaceStmt>())).tablespacename as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DropTableSpaceStmt),
            "::",
            stringify!(tablespacename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropTableSpaceStmt>())).missing_ok as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DropTableSpaceStmt),
            "::",
            stringify!(missing_ok)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableSpaceOptionsStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub isReset: bool,
}
#[test]
fn bindgen_test_layout_AlterTableSpaceOptionsStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterTableSpaceOptionsStmt>(),
        32usize,
        concat!("Size of: ", stringify!(AlterTableSpaceOptionsStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterTableSpaceOptionsStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterTableSpaceOptionsStmt))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterTableSpaceOptionsStmt>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableSpaceOptionsStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterTableSpaceOptionsStmt>())).tablespacename as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableSpaceOptionsStmt),
            "::",
            stringify!(tablespacename)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterTableSpaceOptionsStmt>())).options as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableSpaceOptionsStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterTableSpaceOptionsStmt>())).isReset as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableSpaceOptionsStmt),
            "::",
            stringify!(isReset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableMoveAllStmt {
    pub type_: NodeTag,
    pub orig_tablespacename: *mut ::std::os::raw::c_char,
    pub objtype: ObjectType,
    pub roles: *mut List,
    pub new_tablespacename: *mut ::std::os::raw::c_char,
    pub nowait: bool,
}
#[test]
fn bindgen_test_layout_AlterTableMoveAllStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterTableMoveAllStmt>(),
        48usize,
        concat!("Size of: ", stringify!(AlterTableMoveAllStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterTableMoveAllStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterTableMoveAllStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableMoveAllStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableMoveAllStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterTableMoveAllStmt>())).orig_tablespacename as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableMoveAllStmt),
            "::",
            stringify!(orig_tablespacename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableMoveAllStmt>())).objtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableMoveAllStmt),
            "::",
            stringify!(objtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableMoveAllStmt>())).roles as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableMoveAllStmt),
            "::",
            stringify!(roles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterTableMoveAllStmt>())).new_tablespacename as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableMoveAllStmt),
            "::",
            stringify!(new_tablespacename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTableMoveAllStmt>())).nowait as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTableMoveAllStmt),
            "::",
            stringify!(nowait)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateExtensionStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateExtensionStmt>(),
        32usize,
        concat!("Size of: ", stringify!(CreateExtensionStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateExtensionStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateExtensionStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateExtensionStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateExtensionStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateExtensionStmt>())).extname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateExtensionStmt),
            "::",
            stringify!(extname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateExtensionStmt>())).if_not_exists as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateExtensionStmt),
            "::",
            stringify!(if_not_exists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateExtensionStmt>())).options as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateExtensionStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterExtensionStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterExtensionStmt>(),
        24usize,
        concat!("Size of: ", stringify!(AlterExtensionStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterExtensionStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterExtensionStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterExtensionStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterExtensionStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterExtensionStmt>())).extname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterExtensionStmt),
            "::",
            stringify!(extname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterExtensionStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterExtensionStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterExtensionContentsStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub action: ::std::os::raw::c_int,
    pub objtype: ObjectType,
    pub object: *mut Node,
}
#[test]
fn bindgen_test_layout_AlterExtensionContentsStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterExtensionContentsStmt>(),
        32usize,
        concat!("Size of: ", stringify!(AlterExtensionContentsStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterExtensionContentsStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterExtensionContentsStmt))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterExtensionContentsStmt>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterExtensionContentsStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterExtensionContentsStmt>())).extname as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterExtensionContentsStmt),
            "::",
            stringify!(extname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterExtensionContentsStmt>())).action as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterExtensionContentsStmt),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterExtensionContentsStmt>())).objtype as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterExtensionContentsStmt),
            "::",
            stringify!(objtype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterExtensionContentsStmt>())).object as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterExtensionContentsStmt),
            "::",
            stringify!(object)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateFdwStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateFdwStmt>(),
        32usize,
        concat!("Size of: ", stringify!(CreateFdwStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateFdwStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateFdwStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateFdwStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateFdwStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateFdwStmt>())).fdwname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateFdwStmt),
            "::",
            stringify!(fdwname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateFdwStmt>())).func_options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateFdwStmt),
            "::",
            stringify!(func_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateFdwStmt>())).options as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateFdwStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterFdwStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterFdwStmt>(),
        32usize,
        concat!("Size of: ", stringify!(AlterFdwStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterFdwStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterFdwStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterFdwStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterFdwStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterFdwStmt>())).fdwname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterFdwStmt),
            "::",
            stringify!(fdwname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterFdwStmt>())).func_options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterFdwStmt),
            "::",
            stringify!(func_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterFdwStmt>())).options as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterFdwStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateForeignServerStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateForeignServerStmt>(),
        56usize,
        concat!("Size of: ", stringify!(CreateForeignServerStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateForeignServerStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateForeignServerStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateForeignServerStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateForeignServerStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateForeignServerStmt>())).servername as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateForeignServerStmt),
            "::",
            stringify!(servername)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateForeignServerStmt>())).servertype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateForeignServerStmt),
            "::",
            stringify!(servertype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateForeignServerStmt>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateForeignServerStmt),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateForeignServerStmt>())).fdwname as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateForeignServerStmt),
            "::",
            stringify!(fdwname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateForeignServerStmt>())).if_not_exists as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateForeignServerStmt),
            "::",
            stringify!(if_not_exists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateForeignServerStmt>())).options as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateForeignServerStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub has_version: bool,
}
#[test]
fn bindgen_test_layout_AlterForeignServerStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterForeignServerStmt>(),
        40usize,
        concat!("Size of: ", stringify!(AlterForeignServerStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterForeignServerStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterForeignServerStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterForeignServerStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterForeignServerStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterForeignServerStmt>())).servername as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterForeignServerStmt),
            "::",
            stringify!(servername)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterForeignServerStmt>())).version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterForeignServerStmt),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterForeignServerStmt>())).options as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterForeignServerStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterForeignServerStmt>())).has_version as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterForeignServerStmt),
            "::",
            stringify!(has_version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateForeignTableStmt {
    pub base: CreateStmt,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateForeignTableStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateForeignTableStmt>(),
        112usize,
        concat!("Size of: ", stringify!(CreateForeignTableStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateForeignTableStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateForeignTableStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateForeignTableStmt>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateForeignTableStmt),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateForeignTableStmt>())).servername as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateForeignTableStmt),
            "::",
            stringify!(servername)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateForeignTableStmt>())).options as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateForeignTableStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateUserMappingStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateUserMappingStmt>(),
        40usize,
        concat!("Size of: ", stringify!(CreateUserMappingStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateUserMappingStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateUserMappingStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateUserMappingStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateUserMappingStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateUserMappingStmt>())).user as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateUserMappingStmt),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateUserMappingStmt>())).servername as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateUserMappingStmt),
            "::",
            stringify!(servername)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateUserMappingStmt>())).if_not_exists as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateUserMappingStmt),
            "::",
            stringify!(if_not_exists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateUserMappingStmt>())).options as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateUserMappingStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterUserMappingStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterUserMappingStmt>(),
        32usize,
        concat!("Size of: ", stringify!(AlterUserMappingStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterUserMappingStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterUserMappingStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterUserMappingStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterUserMappingStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterUserMappingStmt>())).user as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterUserMappingStmt),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterUserMappingStmt>())).servername as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterUserMappingStmt),
            "::",
            stringify!(servername)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterUserMappingStmt>())).options as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterUserMappingStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
}
#[test]
fn bindgen_test_layout_DropUserMappingStmt() {
    assert_eq!(
        ::std::mem::size_of::<DropUserMappingStmt>(),
        32usize,
        concat!("Size of: ", stringify!(DropUserMappingStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DropUserMappingStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DropUserMappingStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropUserMappingStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DropUserMappingStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropUserMappingStmt>())).user as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DropUserMappingStmt),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropUserMappingStmt>())).servername as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DropUserMappingStmt),
            "::",
            stringify!(servername)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropUserMappingStmt>())).missing_ok as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DropUserMappingStmt),
            "::",
            stringify!(missing_ok)
        )
    );
}
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_ALL: ImportForeignSchemaType = 0;
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_LIMIT_TO: ImportForeignSchemaType = 1;
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_EXCEPT: ImportForeignSchemaType = 2;
pub type ImportForeignSchemaType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportForeignSchemaStmt {
    pub type_: NodeTag,
    pub server_name: *mut ::std::os::raw::c_char,
    pub remote_schema: *mut ::std::os::raw::c_char,
    pub local_schema: *mut ::std::os::raw::c_char,
    pub list_type: ImportForeignSchemaType,
    pub table_list: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ImportForeignSchemaStmt() {
    assert_eq!(
        ::std::mem::size_of::<ImportForeignSchemaStmt>(),
        56usize,
        concat!("Size of: ", stringify!(ImportForeignSchemaStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<ImportForeignSchemaStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(ImportForeignSchemaStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImportForeignSchemaStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ImportForeignSchemaStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImportForeignSchemaStmt>())).server_name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ImportForeignSchemaStmt),
            "::",
            stringify!(server_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImportForeignSchemaStmt>())).remote_schema as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ImportForeignSchemaStmt),
            "::",
            stringify!(remote_schema)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImportForeignSchemaStmt>())).local_schema as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ImportForeignSchemaStmt),
            "::",
            stringify!(local_schema)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImportForeignSchemaStmt>())).list_type as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ImportForeignSchemaStmt),
            "::",
            stringify!(list_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ImportForeignSchemaStmt>())).table_list as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ImportForeignSchemaStmt),
            "::",
            stringify!(table_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ImportForeignSchemaStmt>())).options as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ImportForeignSchemaStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub cmd_name: *mut ::std::os::raw::c_char,
    pub permissive: bool,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
#[test]
fn bindgen_test_layout_CreatePolicyStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreatePolicyStmt>(),
        64usize,
        concat!("Size of: ", stringify!(CreatePolicyStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreatePolicyStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreatePolicyStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePolicyStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePolicyStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePolicyStmt>())).policy_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePolicyStmt),
            "::",
            stringify!(policy_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePolicyStmt>())).table as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePolicyStmt),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePolicyStmt>())).cmd_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePolicyStmt),
            "::",
            stringify!(cmd_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePolicyStmt>())).permissive as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePolicyStmt),
            "::",
            stringify!(permissive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePolicyStmt>())).roles as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePolicyStmt),
            "::",
            stringify!(roles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePolicyStmt>())).qual as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePolicyStmt),
            "::",
            stringify!(qual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePolicyStmt>())).with_check as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePolicyStmt),
            "::",
            stringify!(with_check)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterPolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
#[test]
fn bindgen_test_layout_AlterPolicyStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterPolicyStmt>(),
        48usize,
        concat!("Size of: ", stringify!(AlterPolicyStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterPolicyStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterPolicyStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterPolicyStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPolicyStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterPolicyStmt>())).policy_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPolicyStmt),
            "::",
            stringify!(policy_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterPolicyStmt>())).table as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPolicyStmt),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterPolicyStmt>())).roles as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPolicyStmt),
            "::",
            stringify!(roles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterPolicyStmt>())).qual as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPolicyStmt),
            "::",
            stringify!(qual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterPolicyStmt>())).with_check as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPolicyStmt),
            "::",
            stringify!(with_check)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateAmStmt {
    pub type_: NodeTag,
    pub amname: *mut ::std::os::raw::c_char,
    pub handler_name: *mut List,
    pub amtype: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CreateAmStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateAmStmt>(),
        32usize,
        concat!("Size of: ", stringify!(CreateAmStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateAmStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateAmStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateAmStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateAmStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateAmStmt>())).amname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateAmStmt),
            "::",
            stringify!(amname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateAmStmt>())).handler_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateAmStmt),
            "::",
            stringify!(handler_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateAmStmt>())).amtype as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateAmStmt),
            "::",
            stringify!(amtype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub funcname: *mut List,
    pub args: *mut List,
    pub row: bool,
    pub timing: int16,
    pub events: int16,
    pub columns: *mut List,
    pub whenClause: *mut Node,
    pub isconstraint: bool,
    pub transitionRels: *mut List,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub constrrel: *mut RangeVar,
}
#[test]
fn bindgen_test_layout_CreateTrigStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateTrigStmt>(),
        96usize,
        concat!("Size of: ", stringify!(CreateTrigStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateTrigStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateTrigStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).trigname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(trigname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).relation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).funcname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(funcname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).row as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(row)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).timing as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(timing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).events as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).columns as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(columns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).whenClause as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(whenClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).isconstraint as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(isconstraint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).transitionRels as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(transitionRels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).deferrable as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(deferrable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).initdeferred as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(initdeferred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTrigStmt>())).constrrel as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTrigStmt),
            "::",
            stringify!(constrrel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub eventname: *mut ::std::os::raw::c_char,
    pub whenclause: *mut List,
    pub funcname: *mut List,
}
#[test]
fn bindgen_test_layout_CreateEventTrigStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateEventTrigStmt>(),
        40usize,
        concat!("Size of: ", stringify!(CreateEventTrigStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateEventTrigStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateEventTrigStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateEventTrigStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateEventTrigStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateEventTrigStmt>())).trigname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateEventTrigStmt),
            "::",
            stringify!(trigname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateEventTrigStmt>())).eventname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateEventTrigStmt),
            "::",
            stringify!(eventname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateEventTrigStmt>())).whenclause as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateEventTrigStmt),
            "::",
            stringify!(whenclause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateEventTrigStmt>())).funcname as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateEventTrigStmt),
            "::",
            stringify!(funcname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub tgenabled: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AlterEventTrigStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterEventTrigStmt>(),
        24usize,
        concat!("Size of: ", stringify!(AlterEventTrigStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterEventTrigStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterEventTrigStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterEventTrigStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterEventTrigStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterEventTrigStmt>())).trigname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterEventTrigStmt),
            "::",
            stringify!(trigname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterEventTrigStmt>())).tgenabled as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterEventTrigStmt),
            "::",
            stringify!(tgenabled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePLangStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub plname: *mut ::std::os::raw::c_char,
    pub plhandler: *mut List,
    pub plinline: *mut List,
    pub plvalidator: *mut List,
    pub pltrusted: bool,
}
#[test]
fn bindgen_test_layout_CreatePLangStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreatePLangStmt>(),
        48usize,
        concat!("Size of: ", stringify!(CreatePLangStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreatePLangStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreatePLangStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePLangStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePLangStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePLangStmt>())).replace as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePLangStmt),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePLangStmt>())).plname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePLangStmt),
            "::",
            stringify!(plname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePLangStmt>())).plhandler as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePLangStmt),
            "::",
            stringify!(plhandler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePLangStmt>())).plinline as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePLangStmt),
            "::",
            stringify!(plinline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePLangStmt>())).plvalidator as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePLangStmt),
            "::",
            stringify!(plvalidator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePLangStmt>())).pltrusted as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePLangStmt),
            "::",
            stringify!(pltrusted)
        )
    );
}
pub const RoleStmtType_ROLESTMT_ROLE: RoleStmtType = 0;
pub const RoleStmtType_ROLESTMT_USER: RoleStmtType = 1;
pub const RoleStmtType_ROLESTMT_GROUP: RoleStmtType = 2;
pub type RoleStmtType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateRoleStmt {
    pub type_: NodeTag,
    pub stmt_type: RoleStmtType,
    pub role: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateRoleStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateRoleStmt>(),
        24usize,
        concat!("Size of: ", stringify!(CreateRoleStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateRoleStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateRoleStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateRoleStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateRoleStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateRoleStmt>())).stmt_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateRoleStmt),
            "::",
            stringify!(stmt_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateRoleStmt>())).role as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateRoleStmt),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateRoleStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateRoleStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterRoleStmt {
    pub type_: NodeTag,
    pub role: *mut RoleSpec,
    pub options: *mut List,
    pub action: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AlterRoleStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterRoleStmt>(),
        32usize,
        concat!("Size of: ", stringify!(AlterRoleStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterRoleStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterRoleStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterRoleStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterRoleStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterRoleStmt>())).role as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterRoleStmt),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterRoleStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterRoleStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterRoleStmt>())).action as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterRoleStmt),
            "::",
            stringify!(action)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterRoleSetStmt {
    pub type_: NodeTag,
    pub role: *mut RoleSpec,
    pub database: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
#[test]
fn bindgen_test_layout_AlterRoleSetStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterRoleSetStmt>(),
        32usize,
        concat!("Size of: ", stringify!(AlterRoleSetStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterRoleSetStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterRoleSetStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterRoleSetStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterRoleSetStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterRoleSetStmt>())).role as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterRoleSetStmt),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterRoleSetStmt>())).database as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterRoleSetStmt),
            "::",
            stringify!(database)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterRoleSetStmt>())).setstmt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterRoleSetStmt),
            "::",
            stringify!(setstmt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropRoleStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub missing_ok: bool,
}
#[test]
fn bindgen_test_layout_DropRoleStmt() {
    assert_eq!(
        ::std::mem::size_of::<DropRoleStmt>(),
        24usize,
        concat!("Size of: ", stringify!(DropRoleStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DropRoleStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DropRoleStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropRoleStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DropRoleStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropRoleStmt>())).roles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DropRoleStmt),
            "::",
            stringify!(roles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropRoleStmt>())).missing_ok as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DropRoleStmt),
            "::",
            stringify!(missing_ok)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub ownerId: Oid,
    pub for_identity: bool,
    pub if_not_exists: bool,
}
#[test]
fn bindgen_test_layout_CreateSeqStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateSeqStmt>(),
        32usize,
        concat!("Size of: ", stringify!(CreateSeqStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateSeqStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateSeqStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSeqStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSeqStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSeqStmt>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSeqStmt),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSeqStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSeqStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSeqStmt>())).ownerId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSeqStmt),
            "::",
            stringify!(ownerId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSeqStmt>())).for_identity as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSeqStmt),
            "::",
            stringify!(for_identity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSeqStmt>())).if_not_exists as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSeqStmt),
            "::",
            stringify!(if_not_exists)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub for_identity: bool,
    pub missing_ok: bool,
}
#[test]
fn bindgen_test_layout_AlterSeqStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterSeqStmt>(),
        32usize,
        concat!("Size of: ", stringify!(AlterSeqStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterSeqStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterSeqStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSeqStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSeqStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSeqStmt>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSeqStmt),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSeqStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSeqStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSeqStmt>())).for_identity as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSeqStmt),
            "::",
            stringify!(for_identity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSeqStmt>())).missing_ok as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSeqStmt),
            "::",
            stringify!(missing_ok)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DefineStmt {
    pub type_: NodeTag,
    pub kind: ObjectType,
    pub oldstyle: bool,
    pub defnames: *mut List,
    pub args: *mut List,
    pub definition: *mut List,
    pub if_not_exists: bool,
}
#[test]
fn bindgen_test_layout_DefineStmt() {
    assert_eq!(
        ::std::mem::size_of::<DefineStmt>(),
        48usize,
        concat!("Size of: ", stringify!(DefineStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DefineStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DefineStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefineStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DefineStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefineStmt>())).kind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DefineStmt),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefineStmt>())).oldstyle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DefineStmt),
            "::",
            stringify!(oldstyle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefineStmt>())).defnames as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DefineStmt),
            "::",
            stringify!(defnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefineStmt>())).args as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DefineStmt),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefineStmt>())).definition as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DefineStmt),
            "::",
            stringify!(definition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DefineStmt>())).if_not_exists as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DefineStmt),
            "::",
            stringify!(if_not_exists)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateDomainStmt {
    pub type_: NodeTag,
    pub domainname: *mut List,
    pub typeName: *mut TypeName,
    pub collClause: *mut CollateClause,
    pub constraints: *mut List,
}
#[test]
fn bindgen_test_layout_CreateDomainStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateDomainStmt>(),
        40usize,
        concat!("Size of: ", stringify!(CreateDomainStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateDomainStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateDomainStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateDomainStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateDomainStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateDomainStmt>())).domainname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateDomainStmt),
            "::",
            stringify!(domainname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateDomainStmt>())).typeName as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateDomainStmt),
            "::",
            stringify!(typeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateDomainStmt>())).collClause as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateDomainStmt),
            "::",
            stringify!(collClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateDomainStmt>())).constraints as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateDomainStmt),
            "::",
            stringify!(constraints)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpClassStmt {
    pub type_: NodeTag,
    pub opclassname: *mut List,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub datatype: *mut TypeName,
    pub items: *mut List,
    pub isDefault: bool,
}
#[test]
fn bindgen_test_layout_CreateOpClassStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateOpClassStmt>(),
        56usize,
        concat!("Size of: ", stringify!(CreateOpClassStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateOpClassStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateOpClassStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassStmt>())).opclassname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassStmt),
            "::",
            stringify!(opclassname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassStmt>())).opfamilyname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassStmt),
            "::",
            stringify!(opfamilyname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassStmt>())).amname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassStmt),
            "::",
            stringify!(amname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassStmt>())).datatype as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassStmt),
            "::",
            stringify!(datatype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassStmt>())).items as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassStmt),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassStmt>())).isDefault as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassStmt),
            "::",
            stringify!(isDefault)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpClassItem {
    pub type_: NodeTag,
    pub itemtype: ::std::os::raw::c_int,
    pub name: *mut ObjectWithArgs,
    pub number: ::std::os::raw::c_int,
    pub order_family: *mut List,
    pub class_args: *mut List,
    pub storedtype: *mut TypeName,
}
#[test]
fn bindgen_test_layout_CreateOpClassItem() {
    assert_eq!(
        ::std::mem::size_of::<CreateOpClassItem>(),
        48usize,
        concat!("Size of: ", stringify!(CreateOpClassItem))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateOpClassItem>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateOpClassItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassItem>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassItem),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassItem>())).itemtype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassItem),
            "::",
            stringify!(itemtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassItem>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassItem),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassItem>())).number as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassItem),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassItem>())).order_family as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassItem),
            "::",
            stringify!(order_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassItem>())).class_args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassItem),
            "::",
            stringify!(class_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpClassItem>())).storedtype as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpClassItem),
            "::",
            stringify!(storedtype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CreateOpFamilyStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateOpFamilyStmt>(),
        24usize,
        concat!("Size of: ", stringify!(CreateOpFamilyStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateOpFamilyStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateOpFamilyStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpFamilyStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpFamilyStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpFamilyStmt>())).opfamilyname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpFamilyStmt),
            "::",
            stringify!(opfamilyname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateOpFamilyStmt>())).amname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateOpFamilyStmt),
            "::",
            stringify!(amname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub isDrop: bool,
    pub items: *mut List,
}
#[test]
fn bindgen_test_layout_AlterOpFamilyStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterOpFamilyStmt>(),
        40usize,
        concat!("Size of: ", stringify!(AlterOpFamilyStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterOpFamilyStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterOpFamilyStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOpFamilyStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOpFamilyStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOpFamilyStmt>())).opfamilyname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOpFamilyStmt),
            "::",
            stringify!(opfamilyname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOpFamilyStmt>())).amname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOpFamilyStmt),
            "::",
            stringify!(amname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOpFamilyStmt>())).isDrop as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOpFamilyStmt),
            "::",
            stringify!(isDrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOpFamilyStmt>())).items as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOpFamilyStmt),
            "::",
            stringify!(items)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropStmt {
    pub type_: NodeTag,
    pub objects: *mut List,
    pub removeType: ObjectType,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
    pub concurrent: bool,
}
#[test]
fn bindgen_test_layout_DropStmt() {
    assert_eq!(
        ::std::mem::size_of::<DropStmt>(),
        32usize,
        concat!("Size of: ", stringify!(DropStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DropStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DropStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DropStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropStmt>())).objects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DropStmt),
            "::",
            stringify!(objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropStmt>())).removeType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DropStmt),
            "::",
            stringify!(removeType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropStmt>())).behavior as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DropStmt),
            "::",
            stringify!(behavior)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropStmt>())).missing_ok as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DropStmt),
            "::",
            stringify!(missing_ok)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropStmt>())).concurrent as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(DropStmt),
            "::",
            stringify!(concurrent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TruncateStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub restart_seqs: bool,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_TruncateStmt() {
    assert_eq!(
        ::std::mem::size_of::<TruncateStmt>(),
        24usize,
        concat!("Size of: ", stringify!(TruncateStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<TruncateStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(TruncateStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TruncateStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TruncateStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TruncateStmt>())).relations as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TruncateStmt),
            "::",
            stringify!(relations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TruncateStmt>())).restart_seqs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TruncateStmt),
            "::",
            stringify!(restart_seqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TruncateStmt>())).behavior as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TruncateStmt),
            "::",
            stringify!(behavior)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommentStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub object: *mut Node,
    pub comment: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CommentStmt() {
    assert_eq!(
        ::std::mem::size_of::<CommentStmt>(),
        24usize,
        concat!("Size of: ", stringify!(CommentStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CommentStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CommentStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommentStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CommentStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommentStmt>())).objtype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CommentStmt),
            "::",
            stringify!(objtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommentStmt>())).object as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CommentStmt),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommentStmt>())).comment as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CommentStmt),
            "::",
            stringify!(comment)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SecLabelStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub object: *mut Node,
    pub provider: *mut ::std::os::raw::c_char,
    pub label: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SecLabelStmt() {
    assert_eq!(
        ::std::mem::size_of::<SecLabelStmt>(),
        32usize,
        concat!("Size of: ", stringify!(SecLabelStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<SecLabelStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(SecLabelStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SecLabelStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SecLabelStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SecLabelStmt>())).objtype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SecLabelStmt),
            "::",
            stringify!(objtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SecLabelStmt>())).object as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SecLabelStmt),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SecLabelStmt>())).provider as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SecLabelStmt),
            "::",
            stringify!(provider)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SecLabelStmt>())).label as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SecLabelStmt),
            "::",
            stringify!(label)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeclareCursorStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
    pub query: *mut Node,
}
#[test]
fn bindgen_test_layout_DeclareCursorStmt() {
    assert_eq!(
        ::std::mem::size_of::<DeclareCursorStmt>(),
        32usize,
        concat!("Size of: ", stringify!(DeclareCursorStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DeclareCursorStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DeclareCursorStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeclareCursorStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeclareCursorStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeclareCursorStmt>())).portalname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DeclareCursorStmt),
            "::",
            stringify!(portalname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeclareCursorStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DeclareCursorStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeclareCursorStmt>())).query as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DeclareCursorStmt),
            "::",
            stringify!(query)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClosePortalStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ClosePortalStmt() {
    assert_eq!(
        ::std::mem::size_of::<ClosePortalStmt>(),
        16usize,
        concat!("Size of: ", stringify!(ClosePortalStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<ClosePortalStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(ClosePortalStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClosePortalStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClosePortalStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClosePortalStmt>())).portalname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClosePortalStmt),
            "::",
            stringify!(portalname)
        )
    );
}
pub const FetchDirection_FETCH_FORWARD: FetchDirection = 0;
pub const FetchDirection_FETCH_BACKWARD: FetchDirection = 1;
pub const FetchDirection_FETCH_ABSOLUTE: FetchDirection = 2;
pub const FetchDirection_FETCH_RELATIVE: FetchDirection = 3;
pub type FetchDirection = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FetchStmt {
    pub type_: NodeTag,
    pub direction: FetchDirection,
    pub howMany: ::std::os::raw::c_long,
    pub portalname: *mut ::std::os::raw::c_char,
    pub ismove: bool,
}
#[test]
fn bindgen_test_layout_FetchStmt() {
    assert_eq!(
        ::std::mem::size_of::<FetchStmt>(),
        32usize,
        concat!("Size of: ", stringify!(FetchStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<FetchStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(FetchStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FetchStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FetchStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FetchStmt>())).direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FetchStmt),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FetchStmt>())).howMany as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FetchStmt),
            "::",
            stringify!(howMany)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FetchStmt>())).portalname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FetchStmt),
            "::",
            stringify!(portalname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FetchStmt>())).ismove as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FetchStmt),
            "::",
            stringify!(ismove)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexStmt {
    pub type_: NodeTag,
    pub idxname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub relationId: Oid,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub tableSpace: *mut ::std::os::raw::c_char,
    pub indexParams: *mut List,
    pub indexIncludingParams: *mut List,
    pub options: *mut List,
    pub whereClause: *mut Node,
    pub excludeOpNames: *mut List,
    pub idxcomment: *mut ::std::os::raw::c_char,
    pub indexOid: Oid,
    pub oldNode: Oid,
    pub unique: bool,
    pub primary: bool,
    pub isconstraint: bool,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub transformed: bool,
    pub concurrent: bool,
    pub if_not_exists: bool,
}
#[test]
fn bindgen_test_layout_IndexStmt() {
    assert_eq!(
        ::std::mem::size_of::<IndexStmt>(),
        112usize,
        concat!("Size of: ", stringify!(IndexStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).idxname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(idxname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).relation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).relationId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(relationId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).accessMethod as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(accessMethod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).tableSpace as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(tableSpace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).indexParams as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(indexParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).indexIncludingParams as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(indexIncludingParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).options as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).whereClause as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(whereClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).excludeOpNames as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(excludeOpNames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).idxcomment as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(idxcomment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).indexOid as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(indexOid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).oldNode as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(oldNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).unique as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(unique)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).primary as *const _ as usize },
        105usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(primary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).isconstraint as *const _ as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(isconstraint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).deferrable as *const _ as usize },
        107usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(deferrable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).initdeferred as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(initdeferred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).transformed as *const _ as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(transformed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).concurrent as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(concurrent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexStmt>())).if_not_exists as *const _ as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexStmt),
            "::",
            stringify!(if_not_exists)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateStatsStmt {
    pub type_: NodeTag,
    pub defnames: *mut List,
    pub stat_types: *mut List,
    pub exprs: *mut List,
    pub relations: *mut List,
    pub stxcomment: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
}
#[test]
fn bindgen_test_layout_CreateStatsStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateStatsStmt>(),
        56usize,
        concat!("Size of: ", stringify!(CreateStatsStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateStatsStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateStatsStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStatsStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStatsStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStatsStmt>())).defnames as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStatsStmt),
            "::",
            stringify!(defnames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStatsStmt>())).stat_types as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStatsStmt),
            "::",
            stringify!(stat_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStatsStmt>())).exprs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStatsStmt),
            "::",
            stringify!(exprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStatsStmt>())).relations as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStatsStmt),
            "::",
            stringify!(relations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStatsStmt>())).stxcomment as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStatsStmt),
            "::",
            stringify!(stxcomment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateStatsStmt>())).if_not_exists as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateStatsStmt),
            "::",
            stringify!(if_not_exists)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateFunctionStmt {
    pub type_: NodeTag,
    pub is_procedure: bool,
    pub replace: bool,
    pub funcname: *mut List,
    pub parameters: *mut List,
    pub returnType: *mut TypeName,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateFunctionStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateFunctionStmt>(),
        40usize,
        concat!("Size of: ", stringify!(CreateFunctionStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateFunctionStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateFunctionStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateFunctionStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateFunctionStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateFunctionStmt>())).is_procedure as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateFunctionStmt),
            "::",
            stringify!(is_procedure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateFunctionStmt>())).replace as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateFunctionStmt),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateFunctionStmt>())).funcname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateFunctionStmt),
            "::",
            stringify!(funcname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateFunctionStmt>())).parameters as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateFunctionStmt),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateFunctionStmt>())).returnType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateFunctionStmt),
            "::",
            stringify!(returnType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateFunctionStmt>())).options as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateFunctionStmt),
            "::",
            stringify!(options)
        )
    );
}
pub const FunctionParameterMode_FUNC_PARAM_IN: FunctionParameterMode = 105;
pub const FunctionParameterMode_FUNC_PARAM_OUT: FunctionParameterMode = 111;
pub const FunctionParameterMode_FUNC_PARAM_INOUT: FunctionParameterMode = 98;
pub const FunctionParameterMode_FUNC_PARAM_VARIADIC: FunctionParameterMode = 118;
pub const FunctionParameterMode_FUNC_PARAM_TABLE: FunctionParameterMode = 116;
pub type FunctionParameterMode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionParameter {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argType: *mut TypeName,
    pub mode: FunctionParameterMode,
    pub defexpr: *mut Node,
}
#[test]
fn bindgen_test_layout_FunctionParameter() {
    assert_eq!(
        ::std::mem::size_of::<FunctionParameter>(),
        40usize,
        concat!("Size of: ", stringify!(FunctionParameter))
    );
    assert_eq!(
        ::std::mem::align_of::<FunctionParameter>(),
        8usize,
        concat!("Alignment of ", stringify!(FunctionParameter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionParameter>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionParameter),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionParameter>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionParameter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionParameter>())).argType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionParameter),
            "::",
            stringify!(argType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionParameter>())).mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionParameter),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionParameter>())).defexpr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionParameter),
            "::",
            stringify!(defexpr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterFunctionStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub func: *mut ObjectWithArgs,
    pub actions: *mut List,
}
#[test]
fn bindgen_test_layout_AlterFunctionStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterFunctionStmt>(),
        24usize,
        concat!("Size of: ", stringify!(AlterFunctionStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterFunctionStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterFunctionStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterFunctionStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterFunctionStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterFunctionStmt>())).objtype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterFunctionStmt),
            "::",
            stringify!(objtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterFunctionStmt>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterFunctionStmt),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterFunctionStmt>())).actions as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterFunctionStmt),
            "::",
            stringify!(actions)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DoStmt {
    pub type_: NodeTag,
    pub args: *mut List,
}
#[test]
fn bindgen_test_layout_DoStmt() {
    assert_eq!(
        ::std::mem::size_of::<DoStmt>(),
        16usize,
        concat!("Size of: ", stringify!(DoStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DoStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DoStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DoStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DoStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DoStmt>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DoStmt),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InlineCodeBlock {
    pub type_: NodeTag,
    pub source_text: *mut ::std::os::raw::c_char,
    pub langOid: Oid,
    pub langIsTrusted: bool,
    pub atomic: bool,
}
#[test]
fn bindgen_test_layout_InlineCodeBlock() {
    assert_eq!(
        ::std::mem::size_of::<InlineCodeBlock>(),
        24usize,
        concat!("Size of: ", stringify!(InlineCodeBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<InlineCodeBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(InlineCodeBlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InlineCodeBlock>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InlineCodeBlock),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InlineCodeBlock>())).source_text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InlineCodeBlock),
            "::",
            stringify!(source_text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InlineCodeBlock>())).langOid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InlineCodeBlock),
            "::",
            stringify!(langOid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InlineCodeBlock>())).langIsTrusted as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(InlineCodeBlock),
            "::",
            stringify!(langIsTrusted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InlineCodeBlock>())).atomic as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(InlineCodeBlock),
            "::",
            stringify!(atomic)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallStmt {
    pub type_: NodeTag,
    pub funccall: *mut FuncCall,
    pub funcexpr: *mut FuncExpr,
}
#[test]
fn bindgen_test_layout_CallStmt() {
    assert_eq!(
        ::std::mem::size_of::<CallStmt>(),
        24usize,
        concat!("Size of: ", stringify!(CallStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CallStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CallStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CallStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CallStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CallStmt>())).funccall as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CallStmt),
            "::",
            stringify!(funccall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CallStmt>())).funcexpr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CallStmt),
            "::",
            stringify!(funcexpr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallContext {
    pub type_: NodeTag,
    pub atomic: bool,
}
#[test]
fn bindgen_test_layout_CallContext() {
    assert_eq!(
        ::std::mem::size_of::<CallContext>(),
        8usize,
        concat!("Size of: ", stringify!(CallContext))
    );
    assert_eq!(
        ::std::mem::align_of::<CallContext>(),
        4usize,
        concat!("Alignment of ", stringify!(CallContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CallContext>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CallContext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CallContext>())).atomic as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CallContext),
            "::",
            stringify!(atomic)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenameStmt {
    pub type_: NodeTag,
    pub renameType: ObjectType,
    pub relationType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub subname: *mut ::std::os::raw::c_char,
    pub newname: *mut ::std::os::raw::c_char,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
}
#[test]
fn bindgen_test_layout_RenameStmt() {
    assert_eq!(
        ::std::mem::size_of::<RenameStmt>(),
        56usize,
        concat!("Size of: ", stringify!(RenameStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<RenameStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(RenameStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenameStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RenameStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenameStmt>())).renameType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RenameStmt),
            "::",
            stringify!(renameType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenameStmt>())).relationType as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RenameStmt),
            "::",
            stringify!(relationType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenameStmt>())).relation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RenameStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenameStmt>())).object as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RenameStmt),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenameStmt>())).subname as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RenameStmt),
            "::",
            stringify!(subname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenameStmt>())).newname as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RenameStmt),
            "::",
            stringify!(newname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenameStmt>())).behavior as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RenameStmt),
            "::",
            stringify!(behavior)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenameStmt>())).missing_ok as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(RenameStmt),
            "::",
            stringify!(missing_ok)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterObjectDependsStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub extname: *mut Value,
}
#[test]
fn bindgen_test_layout_AlterObjectDependsStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterObjectDependsStmt>(),
        32usize,
        concat!("Size of: ", stringify!(AlterObjectDependsStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterObjectDependsStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterObjectDependsStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterObjectDependsStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterObjectDependsStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterObjectDependsStmt>())).objectType as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterObjectDependsStmt),
            "::",
            stringify!(objectType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterObjectDependsStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterObjectDependsStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterObjectDependsStmt>())).object as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterObjectDependsStmt),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterObjectDependsStmt>())).extname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterObjectDependsStmt),
            "::",
            stringify!(extname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterObjectSchemaStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub newschema: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
}
#[test]
fn bindgen_test_layout_AlterObjectSchemaStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterObjectSchemaStmt>(),
        40usize,
        concat!("Size of: ", stringify!(AlterObjectSchemaStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterObjectSchemaStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterObjectSchemaStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterObjectSchemaStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterObjectSchemaStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterObjectSchemaStmt>())).objectType as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterObjectSchemaStmt),
            "::",
            stringify!(objectType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterObjectSchemaStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterObjectSchemaStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterObjectSchemaStmt>())).object as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterObjectSchemaStmt),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterObjectSchemaStmt>())).newschema as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterObjectSchemaStmt),
            "::",
            stringify!(newschema)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterObjectSchemaStmt>())).missing_ok as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterObjectSchemaStmt),
            "::",
            stringify!(missing_ok)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOwnerStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub newowner: *mut RoleSpec,
}
#[test]
fn bindgen_test_layout_AlterOwnerStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterOwnerStmt>(),
        32usize,
        concat!("Size of: ", stringify!(AlterOwnerStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterOwnerStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterOwnerStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOwnerStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOwnerStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOwnerStmt>())).objectType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOwnerStmt),
            "::",
            stringify!(objectType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOwnerStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOwnerStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOwnerStmt>())).object as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOwnerStmt),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOwnerStmt>())).newowner as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOwnerStmt),
            "::",
            stringify!(newowner)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOperatorStmt {
    pub type_: NodeTag,
    pub opername: *mut ObjectWithArgs,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterOperatorStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterOperatorStmt>(),
        24usize,
        concat!("Size of: ", stringify!(AlterOperatorStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterOperatorStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterOperatorStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOperatorStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOperatorStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOperatorStmt>())).opername as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOperatorStmt),
            "::",
            stringify!(opername)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterOperatorStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterOperatorStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuleStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub rulename: *mut ::std::os::raw::c_char,
    pub whereClause: *mut Node,
    pub event: CmdType,
    pub instead: bool,
    pub actions: *mut List,
    pub replace: bool,
}
#[test]
fn bindgen_test_layout_RuleStmt() {
    assert_eq!(
        ::std::mem::size_of::<RuleStmt>(),
        56usize,
        concat!("Size of: ", stringify!(RuleStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<RuleStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(RuleStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RuleStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RuleStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RuleStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RuleStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RuleStmt>())).rulename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RuleStmt),
            "::",
            stringify!(rulename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RuleStmt>())).whereClause as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RuleStmt),
            "::",
            stringify!(whereClause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RuleStmt>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RuleStmt),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RuleStmt>())).instead as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RuleStmt),
            "::",
            stringify!(instead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RuleStmt>())).actions as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RuleStmt),
            "::",
            stringify!(actions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RuleStmt>())).replace as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RuleStmt),
            "::",
            stringify!(replace)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifyStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
    pub payload: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NotifyStmt() {
    assert_eq!(
        ::std::mem::size_of::<NotifyStmt>(),
        24usize,
        concat!("Size of: ", stringify!(NotifyStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<NotifyStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(NotifyStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NotifyStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotifyStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NotifyStmt>())).conditionname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NotifyStmt),
            "::",
            stringify!(conditionname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NotifyStmt>())).payload as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NotifyStmt),
            "::",
            stringify!(payload)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ListenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ListenStmt() {
    assert_eq!(
        ::std::mem::size_of::<ListenStmt>(),
        16usize,
        concat!("Size of: ", stringify!(ListenStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<ListenStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(ListenStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ListenStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ListenStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ListenStmt>())).conditionname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ListenStmt),
            "::",
            stringify!(conditionname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnlistenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_UnlistenStmt() {
    assert_eq!(
        ::std::mem::size_of::<UnlistenStmt>(),
        16usize,
        concat!("Size of: ", stringify!(UnlistenStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<UnlistenStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(UnlistenStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UnlistenStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UnlistenStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UnlistenStmt>())).conditionname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UnlistenStmt),
            "::",
            stringify!(conditionname)
        )
    );
}
pub const TransactionStmtKind_TRANS_STMT_BEGIN: TransactionStmtKind = 0;
pub const TransactionStmtKind_TRANS_STMT_START: TransactionStmtKind = 1;
pub const TransactionStmtKind_TRANS_STMT_COMMIT: TransactionStmtKind = 2;
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK: TransactionStmtKind = 3;
pub const TransactionStmtKind_TRANS_STMT_SAVEPOINT: TransactionStmtKind = 4;
pub const TransactionStmtKind_TRANS_STMT_RELEASE: TransactionStmtKind = 5;
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK_TO: TransactionStmtKind = 6;
pub const TransactionStmtKind_TRANS_STMT_PREPARE: TransactionStmtKind = 7;
pub const TransactionStmtKind_TRANS_STMT_COMMIT_PREPARED: TransactionStmtKind = 8;
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK_PREPARED: TransactionStmtKind = 9;
pub type TransactionStmtKind = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TransactionStmt {
    pub type_: NodeTag,
    pub kind: TransactionStmtKind,
    pub options: *mut List,
    pub savepoint_name: *mut ::std::os::raw::c_char,
    pub gid: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_TransactionStmt() {
    assert_eq!(
        ::std::mem::size_of::<TransactionStmt>(),
        32usize,
        concat!("Size of: ", stringify!(TransactionStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<TransactionStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(TransactionStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TransactionStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TransactionStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TransactionStmt>())).kind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TransactionStmt),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TransactionStmt>())).options as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TransactionStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TransactionStmt>())).savepoint_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TransactionStmt),
            "::",
            stringify!(savepoint_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TransactionStmt>())).gid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TransactionStmt),
            "::",
            stringify!(gid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompositeTypeStmt {
    pub type_: NodeTag,
    pub typevar: *mut RangeVar,
    pub coldeflist: *mut List,
}
#[test]
fn bindgen_test_layout_CompositeTypeStmt() {
    assert_eq!(
        ::std::mem::size_of::<CompositeTypeStmt>(),
        24usize,
        concat!("Size of: ", stringify!(CompositeTypeStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CompositeTypeStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CompositeTypeStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CompositeTypeStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CompositeTypeStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CompositeTypeStmt>())).typevar as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CompositeTypeStmt),
            "::",
            stringify!(typevar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CompositeTypeStmt>())).coldeflist as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CompositeTypeStmt),
            "::",
            stringify!(coldeflist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub vals: *mut List,
}
#[test]
fn bindgen_test_layout_CreateEnumStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateEnumStmt>(),
        24usize,
        concat!("Size of: ", stringify!(CreateEnumStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateEnumStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateEnumStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateEnumStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateEnumStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateEnumStmt>())).typeName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateEnumStmt),
            "::",
            stringify!(typeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateEnumStmt>())).vals as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateEnumStmt),
            "::",
            stringify!(vals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateRangeStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub params: *mut List,
}
#[test]
fn bindgen_test_layout_CreateRangeStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateRangeStmt>(),
        24usize,
        concat!("Size of: ", stringify!(CreateRangeStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateRangeStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateRangeStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateRangeStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateRangeStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateRangeStmt>())).typeName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateRangeStmt),
            "::",
            stringify!(typeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateRangeStmt>())).params as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateRangeStmt),
            "::",
            stringify!(params)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub oldVal: *mut ::std::os::raw::c_char,
    pub newVal: *mut ::std::os::raw::c_char,
    pub newValNeighbor: *mut ::std::os::raw::c_char,
    pub newValIsAfter: bool,
    pub skipIfNewValExists: bool,
}
#[test]
fn bindgen_test_layout_AlterEnumStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterEnumStmt>(),
        48usize,
        concat!("Size of: ", stringify!(AlterEnumStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterEnumStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterEnumStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterEnumStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterEnumStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterEnumStmt>())).typeName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterEnumStmt),
            "::",
            stringify!(typeName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterEnumStmt>())).oldVal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterEnumStmt),
            "::",
            stringify!(oldVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterEnumStmt>())).newVal as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterEnumStmt),
            "::",
            stringify!(newVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterEnumStmt>())).newValNeighbor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterEnumStmt),
            "::",
            stringify!(newValNeighbor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterEnumStmt>())).newValIsAfter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterEnumStmt),
            "::",
            stringify!(newValIsAfter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterEnumStmt>())).skipIfNewValExists as *const _ as usize
        },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterEnumStmt),
            "::",
            stringify!(skipIfNewValExists)
        )
    );
}
pub const ViewCheckOption_NO_CHECK_OPTION: ViewCheckOption = 0;
pub const ViewCheckOption_LOCAL_CHECK_OPTION: ViewCheckOption = 1;
pub const ViewCheckOption_CASCADED_CHECK_OPTION: ViewCheckOption = 2;
pub type ViewCheckOption = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewStmt {
    pub type_: NodeTag,
    pub view: *mut RangeVar,
    pub aliases: *mut List,
    pub query: *mut Node,
    pub replace: bool,
    pub options: *mut List,
    pub withCheckOption: ViewCheckOption,
}
#[test]
fn bindgen_test_layout_ViewStmt() {
    assert_eq!(
        ::std::mem::size_of::<ViewStmt>(),
        56usize,
        concat!("Size of: ", stringify!(ViewStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<ViewStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(ViewStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ViewStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ViewStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ViewStmt>())).view as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ViewStmt),
            "::",
            stringify!(view)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ViewStmt>())).aliases as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ViewStmt),
            "::",
            stringify!(aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ViewStmt>())).query as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ViewStmt),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ViewStmt>())).replace as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ViewStmt),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ViewStmt>())).options as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ViewStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ViewStmt>())).withCheckOption as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ViewStmt),
            "::",
            stringify!(withCheckOption)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LoadStmt {
    pub type_: NodeTag,
    pub filename: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_LoadStmt() {
    assert_eq!(
        ::std::mem::size_of::<LoadStmt>(),
        16usize,
        concat!("Size of: ", stringify!(LoadStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<LoadStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(LoadStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LoadStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LoadStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LoadStmt>())).filename as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LoadStmt),
            "::",
            stringify!(filename)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatedbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreatedbStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreatedbStmt>(),
        24usize,
        concat!("Size of: ", stringify!(CreatedbStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreatedbStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreatedbStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatedbStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatedbStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatedbStmt>())).dbname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatedbStmt),
            "::",
            stringify!(dbname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatedbStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatedbStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDatabaseStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterDatabaseStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterDatabaseStmt>(),
        24usize,
        concat!("Size of: ", stringify!(AlterDatabaseStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterDatabaseStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterDatabaseStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDatabaseStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDatabaseStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDatabaseStmt>())).dbname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDatabaseStmt),
            "::",
            stringify!(dbname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDatabaseStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDatabaseStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDatabaseSetStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
#[test]
fn bindgen_test_layout_AlterDatabaseSetStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterDatabaseSetStmt>(),
        24usize,
        concat!("Size of: ", stringify!(AlterDatabaseSetStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterDatabaseSetStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterDatabaseSetStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDatabaseSetStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDatabaseSetStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDatabaseSetStmt>())).dbname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDatabaseSetStmt),
            "::",
            stringify!(dbname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterDatabaseSetStmt>())).setstmt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterDatabaseSetStmt),
            "::",
            stringify!(setstmt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropdbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
}
#[test]
fn bindgen_test_layout_DropdbStmt() {
    assert_eq!(
        ::std::mem::size_of::<DropdbStmt>(),
        24usize,
        concat!("Size of: ", stringify!(DropdbStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DropdbStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DropdbStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropdbStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DropdbStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropdbStmt>())).dbname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DropdbStmt),
            "::",
            stringify!(dbname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropdbStmt>())).missing_ok as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DropdbStmt),
            "::",
            stringify!(missing_ok)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSystemStmt {
    pub type_: NodeTag,
    pub setstmt: *mut VariableSetStmt,
}
#[test]
fn bindgen_test_layout_AlterSystemStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterSystemStmt>(),
        16usize,
        concat!("Size of: ", stringify!(AlterSystemStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterSystemStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterSystemStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSystemStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSystemStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSystemStmt>())).setstmt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSystemStmt),
            "::",
            stringify!(setstmt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClusterStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub indexname: *mut ::std::os::raw::c_char,
    pub verbose: bool,
}
#[test]
fn bindgen_test_layout_ClusterStmt() {
    assert_eq!(
        ::std::mem::size_of::<ClusterStmt>(),
        32usize,
        concat!("Size of: ", stringify!(ClusterStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<ClusterStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(ClusterStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClusterStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClusterStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClusterStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClusterStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClusterStmt>())).indexname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClusterStmt),
            "::",
            stringify!(indexname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ClusterStmt>())).verbose as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClusterStmt),
            "::",
            stringify!(verbose)
        )
    );
}
pub const VacuumOption_VACOPT_VACUUM: VacuumOption = 1;
pub const VacuumOption_VACOPT_ANALYZE: VacuumOption = 2;
pub const VacuumOption_VACOPT_VERBOSE: VacuumOption = 4;
pub const VacuumOption_VACOPT_FREEZE: VacuumOption = 8;
pub const VacuumOption_VACOPT_FULL: VacuumOption = 16;
pub const VacuumOption_VACOPT_NOWAIT: VacuumOption = 32;
pub const VacuumOption_VACOPT_SKIPTOAST: VacuumOption = 64;
pub const VacuumOption_VACOPT_DISABLE_PAGE_SKIPPING: VacuumOption = 128;
pub type VacuumOption = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacuumRelation {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub oid: Oid,
    pub va_cols: *mut List,
}
#[test]
fn bindgen_test_layout_VacuumRelation() {
    assert_eq!(
        ::std::mem::size_of::<VacuumRelation>(),
        32usize,
        concat!("Size of: ", stringify!(VacuumRelation))
    );
    assert_eq!(
        ::std::mem::align_of::<VacuumRelation>(),
        8usize,
        concat!("Alignment of ", stringify!(VacuumRelation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VacuumRelation>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VacuumRelation),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VacuumRelation>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VacuumRelation),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VacuumRelation>())).oid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VacuumRelation),
            "::",
            stringify!(oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VacuumRelation>())).va_cols as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VacuumRelation),
            "::",
            stringify!(va_cols)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacuumStmt {
    pub type_: NodeTag,
    pub options: ::std::os::raw::c_int,
    pub rels: *mut List,
}
#[test]
fn bindgen_test_layout_VacuumStmt() {
    assert_eq!(
        ::std::mem::size_of::<VacuumStmt>(),
        16usize,
        concat!("Size of: ", stringify!(VacuumStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<VacuumStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(VacuumStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VacuumStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VacuumStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VacuumStmt>())).options as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VacuumStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VacuumStmt>())).rels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VacuumStmt),
            "::",
            stringify!(rels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ExplainStmt() {
    assert_eq!(
        ::std::mem::size_of::<ExplainStmt>(),
        24usize,
        concat!("Size of: ", stringify!(ExplainStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<ExplainStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(ExplainStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExplainStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExplainStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExplainStmt>())).query as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ExplainStmt),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExplainStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ExplainStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTableAsStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub into: *mut IntoClause,
    pub relkind: ObjectType,
    pub is_select_into: bool,
    pub if_not_exists: bool,
}
#[test]
fn bindgen_test_layout_CreateTableAsStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateTableAsStmt>(),
        32usize,
        concat!("Size of: ", stringify!(CreateTableAsStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateTableAsStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateTableAsStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTableAsStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTableAsStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTableAsStmt>())).query as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTableAsStmt),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTableAsStmt>())).into as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTableAsStmt),
            "::",
            stringify!(into)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTableAsStmt>())).relkind as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTableAsStmt),
            "::",
            stringify!(relkind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateTableAsStmt>())).is_select_into as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTableAsStmt),
            "::",
            stringify!(is_select_into)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTableAsStmt>())).if_not_exists as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTableAsStmt),
            "::",
            stringify!(if_not_exists)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RefreshMatViewStmt {
    pub type_: NodeTag,
    pub concurrent: bool,
    pub skipData: bool,
    pub relation: *mut RangeVar,
}
#[test]
fn bindgen_test_layout_RefreshMatViewStmt() {
    assert_eq!(
        ::std::mem::size_of::<RefreshMatViewStmt>(),
        16usize,
        concat!("Size of: ", stringify!(RefreshMatViewStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<RefreshMatViewStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(RefreshMatViewStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RefreshMatViewStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RefreshMatViewStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RefreshMatViewStmt>())).concurrent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RefreshMatViewStmt),
            "::",
            stringify!(concurrent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RefreshMatViewStmt>())).skipData as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(RefreshMatViewStmt),
            "::",
            stringify!(skipData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RefreshMatViewStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RefreshMatViewStmt),
            "::",
            stringify!(relation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CheckPointStmt {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_CheckPointStmt() {
    assert_eq!(
        ::std::mem::size_of::<CheckPointStmt>(),
        4usize,
        concat!("Size of: ", stringify!(CheckPointStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CheckPointStmt>(),
        4usize,
        concat!("Alignment of ", stringify!(CheckPointStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CheckPointStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CheckPointStmt),
            "::",
            stringify!(type_)
        )
    );
}
pub const DiscardMode_DISCARD_ALL: DiscardMode = 0;
pub const DiscardMode_DISCARD_PLANS: DiscardMode = 1;
pub const DiscardMode_DISCARD_SEQUENCES: DiscardMode = 2;
pub const DiscardMode_DISCARD_TEMP: DiscardMode = 3;
pub type DiscardMode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DiscardStmt {
    pub type_: NodeTag,
    pub target: DiscardMode,
}
#[test]
fn bindgen_test_layout_DiscardStmt() {
    assert_eq!(
        ::std::mem::size_of::<DiscardStmt>(),
        8usize,
        concat!("Size of: ", stringify!(DiscardStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DiscardStmt>(),
        4usize,
        concat!("Alignment of ", stringify!(DiscardStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DiscardStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DiscardStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DiscardStmt>())).target as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DiscardStmt),
            "::",
            stringify!(target)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub mode: ::std::os::raw::c_int,
    pub nowait: bool,
}
#[test]
fn bindgen_test_layout_LockStmt() {
    assert_eq!(
        ::std::mem::size_of::<LockStmt>(),
        24usize,
        concat!("Size of: ", stringify!(LockStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<LockStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(LockStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LockStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockStmt>())).relations as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LockStmt),
            "::",
            stringify!(relations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockStmt>())).mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LockStmt),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockStmt>())).nowait as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LockStmt),
            "::",
            stringify!(nowait)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstraintsSetStmt {
    pub type_: NodeTag,
    pub constraints: *mut List,
    pub deferred: bool,
}
#[test]
fn bindgen_test_layout_ConstraintsSetStmt() {
    assert_eq!(
        ::std::mem::size_of::<ConstraintsSetStmt>(),
        24usize,
        concat!("Size of: ", stringify!(ConstraintsSetStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<ConstraintsSetStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(ConstraintsSetStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConstraintsSetStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConstraintsSetStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConstraintsSetStmt>())).constraints as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConstraintsSetStmt),
            "::",
            stringify!(constraints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConstraintsSetStmt>())).deferred as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ConstraintsSetStmt),
            "::",
            stringify!(deferred)
        )
    );
}
pub const ReindexObjectType_REINDEX_OBJECT_INDEX: ReindexObjectType = 0;
pub const ReindexObjectType_REINDEX_OBJECT_TABLE: ReindexObjectType = 1;
pub const ReindexObjectType_REINDEX_OBJECT_SCHEMA: ReindexObjectType = 2;
pub const ReindexObjectType_REINDEX_OBJECT_SYSTEM: ReindexObjectType = 3;
pub const ReindexObjectType_REINDEX_OBJECT_DATABASE: ReindexObjectType = 4;
pub type ReindexObjectType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReindexStmt {
    pub type_: NodeTag,
    pub kind: ReindexObjectType,
    pub relation: *mut RangeVar,
    pub name: *const ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ReindexStmt() {
    assert_eq!(
        ::std::mem::size_of::<ReindexStmt>(),
        32usize,
        concat!("Size of: ", stringify!(ReindexStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<ReindexStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(ReindexStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReindexStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ReindexStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReindexStmt>())).kind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ReindexStmt),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReindexStmt>())).relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ReindexStmt),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReindexStmt>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ReindexStmt),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReindexStmt>())).options as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ReindexStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateConversionStmt {
    pub type_: NodeTag,
    pub conversion_name: *mut List,
    pub for_encoding_name: *mut ::std::os::raw::c_char,
    pub to_encoding_name: *mut ::std::os::raw::c_char,
    pub func_name: *mut List,
    pub def: bool,
}
#[test]
fn bindgen_test_layout_CreateConversionStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateConversionStmt>(),
        48usize,
        concat!("Size of: ", stringify!(CreateConversionStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateConversionStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateConversionStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateConversionStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateConversionStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateConversionStmt>())).conversion_name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateConversionStmt),
            "::",
            stringify!(conversion_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateConversionStmt>())).for_encoding_name as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateConversionStmt),
            "::",
            stringify!(for_encoding_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateConversionStmt>())).to_encoding_name as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateConversionStmt),
            "::",
            stringify!(to_encoding_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateConversionStmt>())).func_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateConversionStmt),
            "::",
            stringify!(func_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateConversionStmt>())).def as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateConversionStmt),
            "::",
            stringify!(def)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateCastStmt {
    pub type_: NodeTag,
    pub sourcetype: *mut TypeName,
    pub targettype: *mut TypeName,
    pub func: *mut ObjectWithArgs,
    pub context: CoercionContext,
    pub inout: bool,
}
#[test]
fn bindgen_test_layout_CreateCastStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateCastStmt>(),
        40usize,
        concat!("Size of: ", stringify!(CreateCastStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateCastStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateCastStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateCastStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateCastStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateCastStmt>())).sourcetype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateCastStmt),
            "::",
            stringify!(sourcetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateCastStmt>())).targettype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateCastStmt),
            "::",
            stringify!(targettype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateCastStmt>())).func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateCastStmt),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateCastStmt>())).context as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateCastStmt),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateCastStmt>())).inout as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateCastStmt),
            "::",
            stringify!(inout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTransformStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub type_name: *mut TypeName,
    pub lang: *mut ::std::os::raw::c_char,
    pub fromsql: *mut ObjectWithArgs,
    pub tosql: *mut ObjectWithArgs,
}
#[test]
fn bindgen_test_layout_CreateTransformStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateTransformStmt>(),
        40usize,
        concat!("Size of: ", stringify!(CreateTransformStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateTransformStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateTransformStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTransformStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTransformStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTransformStmt>())).replace as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTransformStmt),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTransformStmt>())).type_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTransformStmt),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTransformStmt>())).lang as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTransformStmt),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTransformStmt>())).fromsql as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTransformStmt),
            "::",
            stringify!(fromsql)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateTransformStmt>())).tosql as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateTransformStmt),
            "::",
            stringify!(tosql)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrepareStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argtypes: *mut List,
    pub query: *mut Node,
}
#[test]
fn bindgen_test_layout_PrepareStmt() {
    assert_eq!(
        ::std::mem::size_of::<PrepareStmt>(),
        32usize,
        concat!("Size of: ", stringify!(PrepareStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<PrepareStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(PrepareStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PrepareStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PrepareStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PrepareStmt>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PrepareStmt),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PrepareStmt>())).argtypes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PrepareStmt),
            "::",
            stringify!(argtypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PrepareStmt>())).query as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PrepareStmt),
            "::",
            stringify!(query)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecuteStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub params: *mut List,
}
#[test]
fn bindgen_test_layout_ExecuteStmt() {
    assert_eq!(
        ::std::mem::size_of::<ExecuteStmt>(),
        24usize,
        concat!("Size of: ", stringify!(ExecuteStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<ExecuteStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(ExecuteStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecuteStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecuteStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecuteStmt>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecuteStmt),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecuteStmt>())).params as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecuteStmt),
            "::",
            stringify!(params)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeallocateStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_DeallocateStmt() {
    assert_eq!(
        ::std::mem::size_of::<DeallocateStmt>(),
        16usize,
        concat!("Size of: ", stringify!(DeallocateStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DeallocateStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DeallocateStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeallocateStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeallocateStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DeallocateStmt>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DeallocateStmt),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_DropOwnedStmt() {
    assert_eq!(
        ::std::mem::size_of::<DropOwnedStmt>(),
        24usize,
        concat!("Size of: ", stringify!(DropOwnedStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DropOwnedStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DropOwnedStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropOwnedStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DropOwnedStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropOwnedStmt>())).roles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DropOwnedStmt),
            "::",
            stringify!(roles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropOwnedStmt>())).behavior as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DropOwnedStmt),
            "::",
            stringify!(behavior)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReassignOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub newrole: *mut RoleSpec,
}
#[test]
fn bindgen_test_layout_ReassignOwnedStmt() {
    assert_eq!(
        ::std::mem::size_of::<ReassignOwnedStmt>(),
        24usize,
        concat!("Size of: ", stringify!(ReassignOwnedStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<ReassignOwnedStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(ReassignOwnedStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReassignOwnedStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ReassignOwnedStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReassignOwnedStmt>())).roles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ReassignOwnedStmt),
            "::",
            stringify!(roles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReassignOwnedStmt>())).newrole as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ReassignOwnedStmt),
            "::",
            stringify!(newrole)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTSDictionaryStmt {
    pub type_: NodeTag,
    pub dictname: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterTSDictionaryStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterTSDictionaryStmt>(),
        24usize,
        concat!("Size of: ", stringify!(AlterTSDictionaryStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterTSDictionaryStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterTSDictionaryStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTSDictionaryStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTSDictionaryStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTSDictionaryStmt>())).dictname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTSDictionaryStmt),
            "::",
            stringify!(dictname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTSDictionaryStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTSDictionaryStmt),
            "::",
            stringify!(options)
        )
    );
}
pub const AlterTSConfigType_ALTER_TSCONFIG_ADD_MAPPING: AlterTSConfigType = 0;
pub const AlterTSConfigType_ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN: AlterTSConfigType = 1;
pub const AlterTSConfigType_ALTER_TSCONFIG_REPLACE_DICT: AlterTSConfigType = 2;
pub const AlterTSConfigType_ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN: AlterTSConfigType = 3;
pub const AlterTSConfigType_ALTER_TSCONFIG_DROP_MAPPING: AlterTSConfigType = 4;
pub type AlterTSConfigType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTSConfigurationStmt {
    pub type_: NodeTag,
    pub kind: AlterTSConfigType,
    pub cfgname: *mut List,
    pub tokentype: *mut List,
    pub dicts: *mut List,
    pub override_: bool,
    pub replace: bool,
    pub missing_ok: bool,
}
#[test]
fn bindgen_test_layout_AlterTSConfigurationStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterTSConfigurationStmt>(),
        40usize,
        concat!("Size of: ", stringify!(AlterTSConfigurationStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterTSConfigurationStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterTSConfigurationStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTSConfigurationStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTSConfigurationStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTSConfigurationStmt>())).kind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTSConfigurationStmt),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterTSConfigurationStmt>())).cfgname as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTSConfigurationStmt),
            "::",
            stringify!(cfgname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterTSConfigurationStmt>())).tokentype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTSConfigurationStmt),
            "::",
            stringify!(tokentype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterTSConfigurationStmt>())).dicts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTSConfigurationStmt),
            "::",
            stringify!(dicts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterTSConfigurationStmt>())).override_ as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTSConfigurationStmt),
            "::",
            stringify!(override_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterTSConfigurationStmt>())).replace as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTSConfigurationStmt),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterTSConfigurationStmt>())).missing_ok as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterTSConfigurationStmt),
            "::",
            stringify!(missing_ok)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePublicationStmt {
    pub type_: NodeTag,
    pub pubname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub tables: *mut List,
    pub for_all_tables: bool,
}
#[test]
fn bindgen_test_layout_CreatePublicationStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreatePublicationStmt>(),
        40usize,
        concat!("Size of: ", stringify!(CreatePublicationStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreatePublicationStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreatePublicationStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePublicationStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePublicationStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePublicationStmt>())).pubname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePublicationStmt),
            "::",
            stringify!(pubname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePublicationStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePublicationStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreatePublicationStmt>())).tables as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePublicationStmt),
            "::",
            stringify!(tables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreatePublicationStmt>())).for_all_tables as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreatePublicationStmt),
            "::",
            stringify!(for_all_tables)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterPublicationStmt {
    pub type_: NodeTag,
    pub pubname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub tables: *mut List,
    pub for_all_tables: bool,
    pub tableAction: DefElemAction,
}
#[test]
fn bindgen_test_layout_AlterPublicationStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterPublicationStmt>(),
        40usize,
        concat!("Size of: ", stringify!(AlterPublicationStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterPublicationStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterPublicationStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterPublicationStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPublicationStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterPublicationStmt>())).pubname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPublicationStmt),
            "::",
            stringify!(pubname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterPublicationStmt>())).options as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPublicationStmt),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterPublicationStmt>())).tables as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPublicationStmt),
            "::",
            stringify!(tables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterPublicationStmt>())).for_all_tables as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPublicationStmt),
            "::",
            stringify!(for_all_tables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterPublicationStmt>())).tableAction as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterPublicationStmt),
            "::",
            stringify!(tableAction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: *mut ::std::os::raw::c_char,
    pub conninfo: *mut ::std::os::raw::c_char,
    pub publication: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateSubscriptionStmt() {
    assert_eq!(
        ::std::mem::size_of::<CreateSubscriptionStmt>(),
        40usize,
        concat!("Size of: ", stringify!(CreateSubscriptionStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<CreateSubscriptionStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(CreateSubscriptionStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSubscriptionStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSubscriptionStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSubscriptionStmt>())).subname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSubscriptionStmt),
            "::",
            stringify!(subname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSubscriptionStmt>())).conninfo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSubscriptionStmt),
            "::",
            stringify!(conninfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CreateSubscriptionStmt>())).publication as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSubscriptionStmt),
            "::",
            stringify!(publication)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CreateSubscriptionStmt>())).options as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CreateSubscriptionStmt),
            "::",
            stringify!(options)
        )
    );
}
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_OPTIONS: AlterSubscriptionType = 0;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_CONNECTION: AlterSubscriptionType = 1;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_PUBLICATION: AlterSubscriptionType = 2;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_REFRESH: AlterSubscriptionType = 3;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_ENABLED: AlterSubscriptionType = 4;
pub type AlterSubscriptionType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSubscriptionStmt {
    pub type_: NodeTag,
    pub kind: AlterSubscriptionType,
    pub subname: *mut ::std::os::raw::c_char,
    pub conninfo: *mut ::std::os::raw::c_char,
    pub publication: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterSubscriptionStmt() {
    assert_eq!(
        ::std::mem::size_of::<AlterSubscriptionStmt>(),
        40usize,
        concat!("Size of: ", stringify!(AlterSubscriptionStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<AlterSubscriptionStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(AlterSubscriptionStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSubscriptionStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSubscriptionStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSubscriptionStmt>())).kind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSubscriptionStmt),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSubscriptionStmt>())).subname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSubscriptionStmt),
            "::",
            stringify!(subname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSubscriptionStmt>())).conninfo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSubscriptionStmt),
            "::",
            stringify!(conninfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlterSubscriptionStmt>())).publication as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSubscriptionStmt),
            "::",
            stringify!(publication)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlterSubscriptionStmt>())).options as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AlterSubscriptionStmt),
            "::",
            stringify!(options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_DropSubscriptionStmt() {
    assert_eq!(
        ::std::mem::size_of::<DropSubscriptionStmt>(),
        24usize,
        concat!("Size of: ", stringify!(DropSubscriptionStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<DropSubscriptionStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(DropSubscriptionStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropSubscriptionStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DropSubscriptionStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropSubscriptionStmt>())).subname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DropSubscriptionStmt),
            "::",
            stringify!(subname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropSubscriptionStmt>())).missing_ok as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DropSubscriptionStmt),
            "::",
            stringify!(missing_ok)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DropSubscriptionStmt>())).behavior as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DropSubscriptionStmt),
            "::",
            stringify!(behavior)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attstattarget: int32,
    pub attlen: int16,
    pub attnum: int16,
    pub attndims: int32,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attbyval: bool,
    pub attstorage: ::std::os::raw::c_char,
    pub attalign: ::std::os::raw::c_char,
    pub attnotnull: bool,
    pub atthasdef: bool,
    pub atthasmissing: bool,
    pub attidentity: ::std::os::raw::c_char,
    pub attisdropped: bool,
    pub attislocal: bool,
    pub attinhcount: int32,
    pub attcollation: Oid,
}
#[test]
fn bindgen_test_layout_FormData_pg_attribute() {
    assert_eq!(
        ::std::mem::size_of::<FormData_pg_attribute>(),
        112usize,
        concat!("Size of: ", stringify!(FormData_pg_attribute))
    );
    assert_eq!(
        ::std::mem::align_of::<FormData_pg_attribute>(),
        4usize,
        concat!("Alignment of ", stringify!(FormData_pg_attribute))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FormData_pg_attribute>())).attrelid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attrelid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FormData_pg_attribute>())).attname as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FormData_pg_attribute>())).atttypid as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(atttypid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FormData_pg_attribute>())).attstattarget as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attstattarget)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FormData_pg_attribute>())).attlen as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FormData_pg_attribute>())).attnum as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FormData_pg_attribute>())).attndims as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attndims)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FormData_pg_attribute>())).attcacheoff as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attcacheoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FormData_pg_attribute>())).atttypmod as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(atttypmod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FormData_pg_attribute>())).attbyval as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attbyval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FormData_pg_attribute>())).attstorage as *const _ as usize
        },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attstorage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FormData_pg_attribute>())).attalign as *const _ as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attalign)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FormData_pg_attribute>())).attnotnull as *const _ as usize
        },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attnotnull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FormData_pg_attribute>())).atthasdef as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(atthasdef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FormData_pg_attribute>())).atthasmissing as *const _ as usize
        },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(atthasmissing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FormData_pg_attribute>())).attidentity as *const _ as usize
        },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attidentity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FormData_pg_attribute>())).attisdropped as *const _ as usize
        },
        99usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attisdropped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FormData_pg_attribute>())).attislocal as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attislocal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FormData_pg_attribute>())).attinhcount as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attinhcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FormData_pg_attribute>())).attcollation as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(FormData_pg_attribute),
            "::",
            stringify!(attcollation)
        )
    );
}
pub type Form_pg_attribute = *mut FormData_pg_attribute;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attrDefault {
    pub adnum: AttrNumber,
    pub adbin: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_attrDefault() {
    assert_eq!(
        ::std::mem::size_of::<attrDefault>(),
        16usize,
        concat!("Size of: ", stringify!(attrDefault))
    );
    assert_eq!(
        ::std::mem::align_of::<attrDefault>(),
        8usize,
        concat!("Alignment of ", stringify!(attrDefault))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<attrDefault>())).adnum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attrDefault),
            "::",
            stringify!(adnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<attrDefault>())).adbin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attrDefault),
            "::",
            stringify!(adbin)
        )
    );
}
pub type AttrDefault = attrDefault;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attrMissing {
    _unused: [u8; 0],
}
pub type MissingPtr = *mut attrMissing;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct constrCheck {
    pub ccname: *mut ::std::os::raw::c_char,
    pub ccbin: *mut ::std::os::raw::c_char,
    pub ccvalid: bool,
    pub ccnoinherit: bool,
}
#[test]
fn bindgen_test_layout_constrCheck() {
    assert_eq!(
        ::std::mem::size_of::<constrCheck>(),
        24usize,
        concat!("Size of: ", stringify!(constrCheck))
    );
    assert_eq!(
        ::std::mem::align_of::<constrCheck>(),
        8usize,
        concat!("Alignment of ", stringify!(constrCheck))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<constrCheck>())).ccname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(constrCheck),
            "::",
            stringify!(ccname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<constrCheck>())).ccbin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(constrCheck),
            "::",
            stringify!(ccbin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<constrCheck>())).ccvalid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(constrCheck),
            "::",
            stringify!(ccvalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<constrCheck>())).ccnoinherit as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(constrCheck),
            "::",
            stringify!(ccnoinherit)
        )
    );
}
pub type ConstrCheck = constrCheck;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tupleConstr {
    pub defval: *mut AttrDefault,
    pub check: *mut ConstrCheck,
    pub missing: MissingPtr,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: bool,
}
#[test]
fn bindgen_test_layout_tupleConstr() {
    assert_eq!(
        ::std::mem::size_of::<tupleConstr>(),
        32usize,
        concat!("Size of: ", stringify!(tupleConstr))
    );
    assert_eq!(
        ::std::mem::align_of::<tupleConstr>(),
        8usize,
        concat!("Alignment of ", stringify!(tupleConstr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tupleConstr>())).defval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tupleConstr),
            "::",
            stringify!(defval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tupleConstr>())).check as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tupleConstr),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tupleConstr>())).missing as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tupleConstr),
            "::",
            stringify!(missing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tupleConstr>())).num_defval as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tupleConstr),
            "::",
            stringify!(num_defval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tupleConstr>())).num_check as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(tupleConstr),
            "::",
            stringify!(num_check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tupleConstr>())).has_not_null as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tupleConstr),
            "::",
            stringify!(has_not_null)
        )
    );
}
pub type TupleConstr = tupleConstr;
#[repr(C)]
pub struct tupleDesc {
    pub natts: ::std::os::raw::c_int,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdhasoid: bool,
    pub tdrefcount: ::std::os::raw::c_int,
    pub constr: *mut TupleConstr,
    pub attrs: __IncompleteArrayField<FormData_pg_attribute>,
}
#[test]
fn bindgen_test_layout_tupleDesc() {
    assert_eq!(
        ::std::mem::size_of::<tupleDesc>(),
        32usize,
        concat!("Size of: ", stringify!(tupleDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<tupleDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(tupleDesc))
    );
}
pub type TupleDesc = *mut tupleDesc;
extern "C" {
    #[link_name = "\u{1}_CreateTemplateTupleDesc"]
    pub fn CreateTemplateTupleDesc(natts: ::std::os::raw::c_int, hasoid: bool) -> TupleDesc;
}
extern "C" {
    #[link_name = "\u{1}_CreateTupleDesc"]
    pub fn CreateTupleDesc(
        natts: ::std::os::raw::c_int,
        hasoid: bool,
        attrs: *mut Form_pg_attribute,
    ) -> TupleDesc;
}
extern "C" {
    #[link_name = "\u{1}_CreateTupleDescCopy"]
    pub fn CreateTupleDescCopy(tupdesc: TupleDesc) -> TupleDesc;
}
extern "C" {
    #[link_name = "\u{1}_CreateTupleDescCopyConstr"]
    pub fn CreateTupleDescCopyConstr(tupdesc: TupleDesc) -> TupleDesc;
}
extern "C" {
    #[link_name = "\u{1}_TupleDescCopy"]
    pub fn TupleDescCopy(dst: TupleDesc, src: TupleDesc);
}
extern "C" {
    #[link_name = "\u{1}_TupleDescCopyEntry"]
    pub fn TupleDescCopyEntry(
        dst: TupleDesc,
        dstAttno: AttrNumber,
        src: TupleDesc,
        srcAttno: AttrNumber,
    );
}
extern "C" {
    #[link_name = "\u{1}_FreeTupleDesc"]
    pub fn FreeTupleDesc(tupdesc: TupleDesc);
}
extern "C" {
    #[link_name = "\u{1}_IncrTupleDescRefCount"]
    pub fn IncrTupleDescRefCount(tupdesc: TupleDesc);
}
extern "C" {
    #[link_name = "\u{1}_DecrTupleDescRefCount"]
    pub fn DecrTupleDescRefCount(tupdesc: TupleDesc);
}
extern "C" {
    #[link_name = "\u{1}_equalTupleDescs"]
    pub fn equalTupleDescs(tupdesc1: TupleDesc, tupdesc2: TupleDesc) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_hashTupleDesc"]
    pub fn hashTupleDesc(tupdesc: TupleDesc) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}_TupleDescInitEntry"]
    pub fn TupleDescInitEntry(
        desc: TupleDesc,
        attributeNumber: AttrNumber,
        attributeName: *const ::std::os::raw::c_char,
        oidtypeid: Oid,
        typmod: int32,
        attdim: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_TupleDescInitBuiltinEntry"]
    pub fn TupleDescInitBuiltinEntry(
        desc: TupleDesc,
        attributeNumber: AttrNumber,
        attributeName: *const ::std::os::raw::c_char,
        oidtypeid: Oid,
        typmod: int32,
        attdim: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_TupleDescInitEntryCollation"]
    pub fn TupleDescInitEntryCollation(
        desc: TupleDesc,
        attributeNumber: AttrNumber,
        collationid: Oid,
    );
}
extern "C" {
    #[link_name = "\u{1}_BuildDescForRelation"]
    pub fn BuildDescForRelation(schema: *mut List) -> TupleDesc;
}
extern "C" {
    #[link_name = "\u{1}_BuildDescFromLists"]
    pub fn BuildDescFromLists(
        names: *mut List,
        types: *mut List,
        typmods: *mut List,
        collations: *mut List,
    ) -> TupleDesc;
}
pub const EphemeralNameRelationType_ENR_NAMED_TUPLESTORE: EphemeralNameRelationType = 0;
pub type EphemeralNameRelationType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EphemeralNamedRelationMetadataData {
    pub name: *mut ::std::os::raw::c_char,
    pub reliddesc: Oid,
    pub tupdesc: TupleDesc,
    pub enrtype: EphemeralNameRelationType,
    pub enrtuples: f64,
}
#[test]
fn bindgen_test_layout_EphemeralNamedRelationMetadataData() {
    assert_eq!(
        ::std::mem::size_of::<EphemeralNamedRelationMetadataData>(),
        40usize,
        concat!("Size of: ", stringify!(EphemeralNamedRelationMetadataData))
    );
    assert_eq!(
        ::std::mem::align_of::<EphemeralNamedRelationMetadataData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(EphemeralNamedRelationMetadataData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EphemeralNamedRelationMetadataData>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralNamedRelationMetadataData),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EphemeralNamedRelationMetadataData>())).reliddesc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralNamedRelationMetadataData),
            "::",
            stringify!(reliddesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EphemeralNamedRelationMetadataData>())).tupdesc as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralNamedRelationMetadataData),
            "::",
            stringify!(tupdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EphemeralNamedRelationMetadataData>())).enrtype as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralNamedRelationMetadataData),
            "::",
            stringify!(enrtype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EphemeralNamedRelationMetadataData>())).enrtuples as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralNamedRelationMetadataData),
            "::",
            stringify!(enrtuples)
        )
    );
}
pub type EphemeralNamedRelationMetadata = *mut EphemeralNamedRelationMetadataData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EphemeralNamedRelationData {
    pub md: EphemeralNamedRelationMetadataData,
    pub reldata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_EphemeralNamedRelationData() {
    assert_eq!(
        ::std::mem::size_of::<EphemeralNamedRelationData>(),
        48usize,
        concat!("Size of: ", stringify!(EphemeralNamedRelationData))
    );
    assert_eq!(
        ::std::mem::align_of::<EphemeralNamedRelationData>(),
        8usize,
        concat!("Alignment of ", stringify!(EphemeralNamedRelationData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EphemeralNamedRelationData>())).md as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralNamedRelationData),
            "::",
            stringify!(md)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EphemeralNamedRelationData>())).reldata as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralNamedRelationData),
            "::",
            stringify!(reldata)
        )
    );
}
pub type EphemeralNamedRelation = *mut EphemeralNamedRelationData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryEnvironment {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_create_queryEnv"]
    pub fn create_queryEnv() -> *mut QueryEnvironment;
}
extern "C" {
    #[link_name = "\u{1}_get_visible_ENR_metadata"]
    pub fn get_visible_ENR_metadata(
        queryEnv: *mut QueryEnvironment,
        refname: *const ::std::os::raw::c_char,
    ) -> EphemeralNamedRelationMetadata;
}
extern "C" {
    #[link_name = "\u{1}_register_ENR"]
    pub fn register_ENR(queryEnv: *mut QueryEnvironment, enr: EphemeralNamedRelation);
}
extern "C" {
    #[link_name = "\u{1}_unregister_ENR"]
    pub fn unregister_ENR(queryEnv: *mut QueryEnvironment, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_get_ENR"]
    pub fn get_ENR(
        queryEnv: *mut QueryEnvironment,
        name: *const ::std::os::raw::c_char,
    ) -> EphemeralNamedRelation;
}
extern "C" {
    #[link_name = "\u{1}_ENRMetadataGetTupDesc"]
    pub fn ENRMetadataGetTupDesc(enrmd: EphemeralNamedRelationMetadata) -> TupleDesc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelationData {
    _unused: [u8; 0],
}
pub type Relation = *mut RelationData;
pub type RelationPtr = *mut Relation;
extern "C" {
    #[link_name = "\u{1}_RelationIdGetRelation"]
    pub fn RelationIdGetRelation(relationId: Oid) -> Relation;
}
extern "C" {
    #[link_name = "\u{1}_RelationClose"]
    pub fn RelationClose(relation: Relation);
}
extern "C" {
    #[link_name = "\u{1}_RelationGetFKeyList"]
    pub fn RelationGetFKeyList(relation: Relation) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_RelationGetIndexList"]
    pub fn RelationGetIndexList(relation: Relation) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_RelationGetStatExtList"]
    pub fn RelationGetStatExtList(relation: Relation) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_RelationGetOidIndex"]
    pub fn RelationGetOidIndex(relation: Relation) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_RelationGetPrimaryKeyIndex"]
    pub fn RelationGetPrimaryKeyIndex(relation: Relation) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_RelationGetReplicaIndex"]
    pub fn RelationGetReplicaIndex(relation: Relation) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_RelationGetIndexExpressions"]
    pub fn RelationGetIndexExpressions(relation: Relation) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_RelationGetIndexPredicate"]
    pub fn RelationGetIndexPredicate(relation: Relation) -> *mut List;
}
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_HOT: IndexAttrBitmapKind = 0;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_PROJ: IndexAttrBitmapKind = 1;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_KEY: IndexAttrBitmapKind = 2;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_PRIMARY_KEY: IndexAttrBitmapKind = 3;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_IDENTITY_KEY: IndexAttrBitmapKind = 4;
pub type IndexAttrBitmapKind = u32;
extern "C" {
    #[link_name = "\u{1}_RelationGetIndexAttrBitmap"]
    pub fn RelationGetIndexAttrBitmap(
        relation: Relation,
        keyAttrs: IndexAttrBitmapKind,
    ) -> *mut Bitmapset;
}
extern "C" {
    #[link_name = "\u{1}_RelationGetExclusionInfo"]
    pub fn RelationGetExclusionInfo(
        indexRelation: Relation,
        operators: *mut *mut Oid,
        procs: *mut *mut Oid,
        strategies: *mut *mut uint16,
    );
}
extern "C" {
    #[link_name = "\u{1}_RelationSetIndexList"]
    pub fn RelationSetIndexList(relation: Relation, indexIds: *mut List, oidIndex: Oid);
}
extern "C" {
    #[link_name = "\u{1}_RelationInitIndexAccessInfo"]
    pub fn RelationInitIndexAccessInfo(relation: Relation);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PublicationActions {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_GetRelationPublicationActions"]
    pub fn GetRelationPublicationActions(relation: Relation) -> *mut PublicationActions;
}
extern "C" {
    #[link_name = "\u{1}_errtable"]
    pub fn errtable(rel: Relation) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errtablecol"]
    pub fn errtablecol(rel: Relation, attnum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errtablecolname"]
    pub fn errtablecolname(
        rel: Relation,
        colname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errtableconstraint"]
    pub fn errtableconstraint(
        rel: Relation,
        conname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_RelationCacheInitialize"]
    pub fn RelationCacheInitialize();
}
extern "C" {
    #[link_name = "\u{1}_RelationCacheInitializePhase2"]
    pub fn RelationCacheInitializePhase2();
}
extern "C" {
    #[link_name = "\u{1}_RelationCacheInitializePhase3"]
    pub fn RelationCacheInitializePhase3();
}
extern "C" {
    #[link_name = "\u{1}_RelationBuildLocalRelation"]
    pub fn RelationBuildLocalRelation(
        relname: *const ::std::os::raw::c_char,
        relnamespace: Oid,
        tupDesc: TupleDesc,
        relid: Oid,
        relfilenode: Oid,
        reltablespace: Oid,
        shared_relation: bool,
        mapped_relation: bool,
        relpersistence: ::std::os::raw::c_char,
        relkind: ::std::os::raw::c_char,
    ) -> Relation;
}
extern "C" {
    #[link_name = "\u{1}_RelationSetNewRelfilenode"]
    pub fn RelationSetNewRelfilenode(
        relation: Relation,
        persistence: ::std::os::raw::c_char,
        freezeXid: TransactionId,
        minmulti: MultiXactId,
    );
}
extern "C" {
    #[link_name = "\u{1}_RelationForgetRelation"]
    pub fn RelationForgetRelation(rid: Oid);
}
extern "C" {
    #[link_name = "\u{1}_RelationCacheInvalidateEntry"]
    pub fn RelationCacheInvalidateEntry(relationId: Oid);
}
extern "C" {
    #[link_name = "\u{1}_RelationCacheInvalidate"]
    pub fn RelationCacheInvalidate();
}
extern "C" {
    #[link_name = "\u{1}_RelationCloseSmgrByOid"]
    pub fn RelationCloseSmgrByOid(relationId: Oid);
}
extern "C" {
    #[link_name = "\u{1}_AtEOXact_RelationCache"]
    pub fn AtEOXact_RelationCache(isCommit: bool);
}
extern "C" {
    #[link_name = "\u{1}_AtEOSubXact_RelationCache"]
    pub fn AtEOSubXact_RelationCache(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
}
extern "C" {
    #[link_name = "\u{1}_RelationIdIsInInitFile"]
    pub fn RelationIdIsInInitFile(relationId: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_RelationCacheInitFilePreInvalidate"]
    pub fn RelationCacheInitFilePreInvalidate();
}
extern "C" {
    #[link_name = "\u{1}_RelationCacheInitFilePostInvalidate"]
    pub fn RelationCacheInitFilePostInvalidate();
}
extern "C" {
    #[link_name = "\u{1}_RelationCacheInitFileRemove"]
    pub fn RelationCacheInitFileRemove();
}
extern "C" {
    #[link_name = "\u{1}_criticalRelcachesBuilt"]
    pub static mut criticalRelcachesBuilt: bool;
}
extern "C" {
    #[link_name = "\u{1}_criticalSharedRelcachesBuilt"]
    pub static mut criticalSharedRelcachesBuilt: bool;
}
pub const ParseExprKind_EXPR_KIND_NONE: ParseExprKind = 0;
pub const ParseExprKind_EXPR_KIND_OTHER: ParseExprKind = 1;
pub const ParseExprKind_EXPR_KIND_JOIN_ON: ParseExprKind = 2;
pub const ParseExprKind_EXPR_KIND_JOIN_USING: ParseExprKind = 3;
pub const ParseExprKind_EXPR_KIND_FROM_SUBSELECT: ParseExprKind = 4;
pub const ParseExprKind_EXPR_KIND_FROM_FUNCTION: ParseExprKind = 5;
pub const ParseExprKind_EXPR_KIND_WHERE: ParseExprKind = 6;
pub const ParseExprKind_EXPR_KIND_HAVING: ParseExprKind = 7;
pub const ParseExprKind_EXPR_KIND_FILTER: ParseExprKind = 8;
pub const ParseExprKind_EXPR_KIND_WINDOW_PARTITION: ParseExprKind = 9;
pub const ParseExprKind_EXPR_KIND_WINDOW_ORDER: ParseExprKind = 10;
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_RANGE: ParseExprKind = 11;
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_ROWS: ParseExprKind = 12;
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_GROUPS: ParseExprKind = 13;
pub const ParseExprKind_EXPR_KIND_SELECT_TARGET: ParseExprKind = 14;
pub const ParseExprKind_EXPR_KIND_INSERT_TARGET: ParseExprKind = 15;
pub const ParseExprKind_EXPR_KIND_UPDATE_SOURCE: ParseExprKind = 16;
pub const ParseExprKind_EXPR_KIND_UPDATE_TARGET: ParseExprKind = 17;
pub const ParseExprKind_EXPR_KIND_GROUP_BY: ParseExprKind = 18;
pub const ParseExprKind_EXPR_KIND_ORDER_BY: ParseExprKind = 19;
pub const ParseExprKind_EXPR_KIND_DISTINCT_ON: ParseExprKind = 20;
pub const ParseExprKind_EXPR_KIND_LIMIT: ParseExprKind = 21;
pub const ParseExprKind_EXPR_KIND_OFFSET: ParseExprKind = 22;
pub const ParseExprKind_EXPR_KIND_RETURNING: ParseExprKind = 23;
pub const ParseExprKind_EXPR_KIND_VALUES: ParseExprKind = 24;
pub const ParseExprKind_EXPR_KIND_VALUES_SINGLE: ParseExprKind = 25;
pub const ParseExprKind_EXPR_KIND_CHECK_CONSTRAINT: ParseExprKind = 26;
pub const ParseExprKind_EXPR_KIND_DOMAIN_CHECK: ParseExprKind = 27;
pub const ParseExprKind_EXPR_KIND_COLUMN_DEFAULT: ParseExprKind = 28;
pub const ParseExprKind_EXPR_KIND_FUNCTION_DEFAULT: ParseExprKind = 29;
pub const ParseExprKind_EXPR_KIND_INDEX_EXPRESSION: ParseExprKind = 30;
pub const ParseExprKind_EXPR_KIND_INDEX_PREDICATE: ParseExprKind = 31;
pub const ParseExprKind_EXPR_KIND_ALTER_COL_TRANSFORM: ParseExprKind = 32;
pub const ParseExprKind_EXPR_KIND_EXECUTE_PARAMETER: ParseExprKind = 33;
pub const ParseExprKind_EXPR_KIND_TRIGGER_WHEN: ParseExprKind = 34;
pub const ParseExprKind_EXPR_KIND_POLICY: ParseExprKind = 35;
pub const ParseExprKind_EXPR_KIND_PARTITION_EXPRESSION: ParseExprKind = 36;
pub const ParseExprKind_EXPR_KIND_CALL_ARGUMENT: ParseExprKind = 37;
pub type ParseExprKind = u32;
pub type PreParseColumnRefHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: *mut ParseState, cref: *mut ColumnRef) -> *mut Node,
>;
pub type PostParseColumnRefHook = ::std::option::Option<
    unsafe extern "C" fn(
        pstate: *mut ParseState,
        cref: *mut ColumnRef,
        var: *mut Node,
    ) -> *mut Node,
>;
pub type ParseParamRefHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: *mut ParseState, pref: *mut ParamRef) -> *mut Node,
>;
pub type CoerceParamHook = ::std::option::Option<
    unsafe extern "C" fn(
        pstate: *mut ParseState,
        param: *mut Param,
        targetTypeId: Oid,
        targetTypeMod: int32,
        location: ::std::os::raw::c_int,
    ) -> *mut Node,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseState {
    pub parentParseState: *mut ParseState,
    pub p_sourcetext: *const ::std::os::raw::c_char,
    pub p_rtable: *mut List,
    pub p_joinexprs: *mut List,
    pub p_joinlist: *mut List,
    pub p_namespace: *mut List,
    pub p_lateral_active: bool,
    pub p_ctenamespace: *mut List,
    pub p_future_ctes: *mut List,
    pub p_parent_cte: *mut CommonTableExpr,
    pub p_target_relation: Relation,
    pub p_target_rangetblentry: *mut RangeTblEntry,
    pub p_is_insert: bool,
    pub p_windowdefs: *mut List,
    pub p_expr_kind: ParseExprKind,
    pub p_next_resno: ::std::os::raw::c_int,
    pub p_multiassign_exprs: *mut List,
    pub p_locking_clause: *mut List,
    pub p_locked_from_parent: bool,
    pub p_resolve_unknowns: bool,
    pub p_queryEnv: *mut QueryEnvironment,
    pub p_hasAggs: bool,
    pub p_hasWindowFuncs: bool,
    pub p_hasTargetSRFs: bool,
    pub p_hasSubLinks: bool,
    pub p_hasModifyingCTE: bool,
    pub p_last_srf: *mut Node,
    pub p_pre_columnref_hook: PreParseColumnRefHook,
    pub p_post_columnref_hook: PostParseColumnRefHook,
    pub p_paramref_hook: ParseParamRefHook,
    pub p_coerce_param_hook: CoerceParamHook,
    pub p_ref_hook_state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ParseState() {
    assert_eq!(
        ::std::mem::size_of::<ParseState>(),
        208usize,
        concat!("Size of: ", stringify!(ParseState))
    );
    assert_eq!(
        ::std::mem::align_of::<ParseState>(),
        8usize,
        concat!("Alignment of ", stringify!(ParseState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).parentParseState as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(parentParseState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_sourcetext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_sourcetext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_rtable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_rtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_joinexprs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_joinexprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_joinlist as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_joinlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_namespace as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_namespace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_lateral_active as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_lateral_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_ctenamespace as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_ctenamespace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_future_ctes as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_future_ctes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_parent_cte as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_parent_cte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_target_relation as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_target_relation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ParseState>())).p_target_rangetblentry as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_target_rangetblentry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_is_insert as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_is_insert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_windowdefs as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_windowdefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_expr_kind as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_expr_kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_next_resno as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_next_resno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_multiassign_exprs as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_multiassign_exprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_locking_clause as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_locking_clause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_locked_from_parent as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_locked_from_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_resolve_unknowns as *const _ as usize },
        137usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_resolve_unknowns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_queryEnv as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_queryEnv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_hasAggs as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_hasAggs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_hasWindowFuncs as *const _ as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_hasWindowFuncs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_hasTargetSRFs as *const _ as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_hasTargetSRFs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_hasSubLinks as *const _ as usize },
        155usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_hasSubLinks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_hasModifyingCTE as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_hasModifyingCTE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_last_srf as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_last_srf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_pre_columnref_hook as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_pre_columnref_hook)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ParseState>())).p_post_columnref_hook as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_post_columnref_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_paramref_hook as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_paramref_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_coerce_param_hook as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_coerce_param_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseState>())).p_ref_hook_state as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseState),
            "::",
            stringify!(p_ref_hook_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseNamespaceItem {
    pub p_rte: *mut RangeTblEntry,
    pub p_rel_visible: bool,
    pub p_cols_visible: bool,
    pub p_lateral_only: bool,
    pub p_lateral_ok: bool,
}
#[test]
fn bindgen_test_layout_ParseNamespaceItem() {
    assert_eq!(
        ::std::mem::size_of::<ParseNamespaceItem>(),
        16usize,
        concat!("Size of: ", stringify!(ParseNamespaceItem))
    );
    assert_eq!(
        ::std::mem::align_of::<ParseNamespaceItem>(),
        8usize,
        concat!("Alignment of ", stringify!(ParseNamespaceItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseNamespaceItem>())).p_rte as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseNamespaceItem),
            "::",
            stringify!(p_rte)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ParseNamespaceItem>())).p_rel_visible as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseNamespaceItem),
            "::",
            stringify!(p_rel_visible)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ParseNamespaceItem>())).p_cols_visible as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseNamespaceItem),
            "::",
            stringify!(p_cols_visible)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ParseNamespaceItem>())).p_lateral_only as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseNamespaceItem),
            "::",
            stringify!(p_lateral_only)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseNamespaceItem>())).p_lateral_ok as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseNamespaceItem),
            "::",
            stringify!(p_lateral_ok)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseCallbackState {
    pub pstate: *mut ParseState,
    pub location: ::std::os::raw::c_int,
    pub errcallback: ErrorContextCallback,
}
#[test]
fn bindgen_test_layout_ParseCallbackState() {
    assert_eq!(
        ::std::mem::size_of::<ParseCallbackState>(),
        40usize,
        concat!("Size of: ", stringify!(ParseCallbackState))
    );
    assert_eq!(
        ::std::mem::align_of::<ParseCallbackState>(),
        8usize,
        concat!("Alignment of ", stringify!(ParseCallbackState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseCallbackState>())).pstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseCallbackState),
            "::",
            stringify!(pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseCallbackState>())).location as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseCallbackState),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParseCallbackState>())).errcallback as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ParseCallbackState),
            "::",
            stringify!(errcallback)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_make_parsestate"]
    pub fn make_parsestate(parentParseState: *mut ParseState) -> *mut ParseState;
}
extern "C" {
    #[link_name = "\u{1}_free_parsestate"]
    pub fn free_parsestate(pstate: *mut ParseState);
}
extern "C" {
    #[link_name = "\u{1}_parser_errposition"]
    pub fn parser_errposition(
        pstate: *mut ParseState,
        location: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setup_parser_errposition_callback"]
    pub fn setup_parser_errposition_callback(
        pcbstate: *mut ParseCallbackState,
        pstate: *mut ParseState,
        location: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_cancel_parser_errposition_callback"]
    pub fn cancel_parser_errposition_callback(pcbstate: *mut ParseCallbackState);
}
extern "C" {
    #[link_name = "\u{1}_make_var"]
    pub fn make_var(
        pstate: *mut ParseState,
        rte: *mut RangeTblEntry,
        attrno: ::std::os::raw::c_int,
        location: ::std::os::raw::c_int,
    ) -> *mut Var;
}
extern "C" {
    #[link_name = "\u{1}_transformArrayType"]
    pub fn transformArrayType(arrayType: *mut Oid, arrayTypmod: *mut int32) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_transformArraySubscripts"]
    pub fn transformArraySubscripts(
        pstate: *mut ParseState,
        arrayBase: *mut Node,
        arrayType: Oid,
        elementType: Oid,
        arrayTypMod: int32,
        indirection: *mut List,
        assignFrom: *mut Node,
    ) -> *mut ArrayRef;
}
extern "C" {
    #[link_name = "\u{1}_make_const"]
    pub fn make_const(
        pstate: *mut ParseState,
        value: *mut Value,
        location: ::std::os::raw::c_int,
    ) -> *mut Const;
}
pub type EOM_get_flat_size_method =
    ::std::option::Option<unsafe extern "C" fn(eohptr: *mut ExpandedObjectHeader) -> Size>;
pub type EOM_flatten_into_method = ::std::option::Option<
    unsafe extern "C" fn(
        eohptr: *mut ExpandedObjectHeader,
        result: *mut ::std::os::raw::c_void,
        allocated_size: Size,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedObjectMethods {
    pub get_flat_size: EOM_get_flat_size_method,
    pub flatten_into: EOM_flatten_into_method,
}
#[test]
fn bindgen_test_layout_ExpandedObjectMethods() {
    assert_eq!(
        ::std::mem::size_of::<ExpandedObjectMethods>(),
        16usize,
        concat!("Size of: ", stringify!(ExpandedObjectMethods))
    );
    assert_eq!(
        ::std::mem::align_of::<ExpandedObjectMethods>(),
        8usize,
        concat!("Alignment of ", stringify!(ExpandedObjectMethods))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ExpandedObjectMethods>())).get_flat_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedObjectMethods),
            "::",
            stringify!(get_flat_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ExpandedObjectMethods>())).flatten_into as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedObjectMethods),
            "::",
            stringify!(flatten_into)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedObjectHeader {
    pub vl_len_: int32,
    pub eoh_methods: *const ExpandedObjectMethods,
    pub eoh_context: MemoryContext,
    pub eoh_rw_ptr: [::std::os::raw::c_char; 10usize],
    pub eoh_ro_ptr: [::std::os::raw::c_char; 10usize],
}
#[test]
fn bindgen_test_layout_ExpandedObjectHeader() {
    assert_eq!(
        ::std::mem::size_of::<ExpandedObjectHeader>(),
        48usize,
        concat!("Size of: ", stringify!(ExpandedObjectHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<ExpandedObjectHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(ExpandedObjectHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedObjectHeader>())).vl_len_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedObjectHeader),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ExpandedObjectHeader>())).eoh_methods as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedObjectHeader),
            "::",
            stringify!(eoh_methods)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ExpandedObjectHeader>())).eoh_context as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedObjectHeader),
            "::",
            stringify!(eoh_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedObjectHeader>())).eoh_rw_ptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedObjectHeader),
            "::",
            stringify!(eoh_rw_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedObjectHeader>())).eoh_ro_ptr as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedObjectHeader),
            "::",
            stringify!(eoh_ro_ptr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_DatumGetEOHP"]
    pub fn DatumGetEOHP(d: Datum) -> *mut ExpandedObjectHeader;
}
extern "C" {
    #[link_name = "\u{1}_EOH_init_header"]
    pub fn EOH_init_header(
        eohptr: *mut ExpandedObjectHeader,
        methods: *const ExpandedObjectMethods,
        obj_context: MemoryContext,
    );
}
extern "C" {
    #[link_name = "\u{1}_EOH_get_flat_size"]
    pub fn EOH_get_flat_size(eohptr: *mut ExpandedObjectHeader) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_EOH_flatten_into"]
    pub fn EOH_flatten_into(
        eohptr: *mut ExpandedObjectHeader,
        result: *mut ::std::os::raw::c_void,
        allocated_size: Size,
    );
}
extern "C" {
    #[link_name = "\u{1}_MakeExpandedObjectReadOnlyInternal"]
    pub fn MakeExpandedObjectReadOnlyInternal(d: Datum) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_TransferExpandedObject"]
    pub fn TransferExpandedObject(d: Datum, new_parent: MemoryContext) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_DeleteExpandedObject"]
    pub fn DeleteExpandedObject(d: Datum);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayType {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
}
#[test]
fn bindgen_test_layout_ArrayType() {
    assert_eq!(
        ::std::mem::size_of::<ArrayType>(),
        16usize,
        concat!("Size of: ", stringify!(ArrayType))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrayType>(),
        4usize,
        concat!("Alignment of ", stringify!(ArrayType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayType>())).vl_len_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayType),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayType>())).ndim as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayType),
            "::",
            stringify!(ndim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayType>())).dataoffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayType),
            "::",
            stringify!(dataoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayType>())).elemtype as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayType),
            "::",
            stringify!(elemtype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedArrayHeader {
    pub hdr: ExpandedObjectHeader,
    pub ea_magic: ::std::os::raw::c_int,
    pub ndims: ::std::os::raw::c_int,
    pub dims: *mut ::std::os::raw::c_int,
    pub lbound: *mut ::std::os::raw::c_int,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool,
    pub dvalueslen: ::std::os::raw::c_int,
    pub nelems: ::std::os::raw::c_int,
    pub flat_size: Size,
    pub fvalue: *mut ArrayType,
    pub fstartptr: *mut ::std::os::raw::c_char,
    pub fendptr: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ExpandedArrayHeader() {
    assert_eq!(
        ::std::mem::size_of::<ExpandedArrayHeader>(),
        136usize,
        concat!("Size of: ", stringify!(ExpandedArrayHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<ExpandedArrayHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(ExpandedArrayHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).ea_magic as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(ea_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).ndims as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(ndims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).dims as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).lbound as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(lbound)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ExpandedArrayHeader>())).element_type as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(element_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).typlen as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(typlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).typbyval as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(typbyval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).typalign as *const _ as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(typalign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).dvalues as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(dvalues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).dnulls as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(dnulls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).dvalueslen as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(dvalueslen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).nelems as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(nelems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).flat_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(flat_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).fvalue as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(fvalue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).fstartptr as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(fstartptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExpandedArrayHeader>())).fendptr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ExpandedArrayHeader),
            "::",
            stringify!(fendptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AnyArrayType {
    pub flt: ArrayType,
    pub xpn: ExpandedArrayHeader,
    _bindgen_union_align: [u64; 17usize],
}
#[test]
fn bindgen_test_layout_AnyArrayType() {
    assert_eq!(
        ::std::mem::size_of::<AnyArrayType>(),
        136usize,
        concat!("Size of: ", stringify!(AnyArrayType))
    );
    assert_eq!(
        ::std::mem::align_of::<AnyArrayType>(),
        8usize,
        concat!("Alignment of ", stringify!(AnyArrayType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyArrayType>())).flt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyArrayType),
            "::",
            stringify!(flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AnyArrayType>())).xpn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AnyArrayType),
            "::",
            stringify!(xpn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildState {
    pub mcontext: MemoryContext,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool,
    pub alen: ::std::os::raw::c_int,
    pub nelems: ::std::os::raw::c_int,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub private_cxt: bool,
}
#[test]
fn bindgen_test_layout_ArrayBuildState() {
    assert_eq!(
        ::std::mem::size_of::<ArrayBuildState>(),
        48usize,
        concat!("Size of: ", stringify!(ArrayBuildState))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrayBuildState>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrayBuildState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildState>())).mcontext as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildState),
            "::",
            stringify!(mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildState>())).dvalues as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildState),
            "::",
            stringify!(dvalues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildState>())).dnulls as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildState),
            "::",
            stringify!(dnulls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildState>())).alen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildState),
            "::",
            stringify!(alen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildState>())).nelems as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildState),
            "::",
            stringify!(nelems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildState>())).element_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildState),
            "::",
            stringify!(element_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildState>())).typlen as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildState),
            "::",
            stringify!(typlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildState>())).typbyval as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildState),
            "::",
            stringify!(typbyval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildState>())).typalign as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildState),
            "::",
            stringify!(typalign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildState>())).private_cxt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildState),
            "::",
            stringify!(private_cxt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildStateArr {
    pub mcontext: MemoryContext,
    pub data: *mut ::std::os::raw::c_char,
    pub nullbitmap: *mut bits8,
    pub abytes: ::std::os::raw::c_int,
    pub nbytes: ::std::os::raw::c_int,
    pub aitems: ::std::os::raw::c_int,
    pub nitems: ::std::os::raw::c_int,
    pub ndims: ::std::os::raw::c_int,
    pub dims: [::std::os::raw::c_int; 6usize],
    pub lbs: [::std::os::raw::c_int; 6usize],
    pub array_type: Oid,
    pub element_type: Oid,
    pub private_cxt: bool,
}
#[test]
fn bindgen_test_layout_ArrayBuildStateArr() {
    assert_eq!(
        ::std::mem::size_of::<ArrayBuildStateArr>(),
        104usize,
        concat!("Size of: ", stringify!(ArrayBuildStateArr))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrayBuildStateArr>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrayBuildStateArr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).mcontext as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).nullbitmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(nullbitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).abytes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(abytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).nbytes as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(nbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).aitems as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(aitems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).nitems as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(nitems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).ndims as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(ndims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).dims as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).lbs as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(lbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).array_type as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(array_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).element_type as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(element_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateArr>())).private_cxt as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateArr),
            "::",
            stringify!(private_cxt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildStateAny {
    pub scalarstate: *mut ArrayBuildState,
    pub arraystate: *mut ArrayBuildStateArr,
}
#[test]
fn bindgen_test_layout_ArrayBuildStateAny() {
    assert_eq!(
        ::std::mem::size_of::<ArrayBuildStateAny>(),
        16usize,
        concat!("Size of: ", stringify!(ArrayBuildStateAny))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrayBuildStateAny>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrayBuildStateAny))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateAny>())).scalarstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateAny),
            "::",
            stringify!(scalarstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayBuildStateAny>())).arraystate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayBuildStateAny),
            "::",
            stringify!(arraystate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayMetaState {
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub typdelim: ::std::os::raw::c_char,
    pub typioparam: Oid,
    pub typiofunc: Oid,
    pub proc_: FmgrInfo,
}
#[test]
fn bindgen_test_layout_ArrayMetaState() {
    assert_eq!(
        ::std::mem::size_of::<ArrayMetaState>(),
        72usize,
        concat!("Size of: ", stringify!(ArrayMetaState))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrayMetaState>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrayMetaState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayMetaState>())).element_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayMetaState),
            "::",
            stringify!(element_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayMetaState>())).typlen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayMetaState),
            "::",
            stringify!(typlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayMetaState>())).typbyval as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayMetaState),
            "::",
            stringify!(typbyval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayMetaState>())).typalign as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayMetaState),
            "::",
            stringify!(typalign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayMetaState>())).typdelim as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayMetaState),
            "::",
            stringify!(typdelim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayMetaState>())).typioparam as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayMetaState),
            "::",
            stringify!(typioparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayMetaState>())).typiofunc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayMetaState),
            "::",
            stringify!(typiofunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayMetaState>())).proc_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayMetaState),
            "::",
            stringify!(proc_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayMapState {
    pub inp_extra: ArrayMetaState,
    pub ret_extra: ArrayMetaState,
}
#[test]
fn bindgen_test_layout_ArrayMapState() {
    assert_eq!(
        ::std::mem::size_of::<ArrayMapState>(),
        144usize,
        concat!("Size of: ", stringify!(ArrayMapState))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrayMapState>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrayMapState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayMapState>())).inp_extra as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayMapState),
            "::",
            stringify!(inp_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ArrayMapState>())).ret_extra as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrayMapState),
            "::",
            stringify!(ret_extra)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayIteratorData {
    _unused: [u8; 0],
}
pub type ArrayIterator = *mut ArrayIteratorData;
extern "C" {
    #[link_name = "\u{1}_Array_nulls"]
    pub static mut Array_nulls: bool;
}
extern "C" {
    #[link_name = "\u{1}_CopyArrayEls"]
    pub fn CopyArrayEls(
        array: *mut ArrayType,
        values: *mut Datum,
        nulls: *mut bool,
        nitems: ::std::os::raw::c_int,
        typlen: ::std::os::raw::c_int,
        typbyval: bool,
        typalign: ::std::os::raw::c_char,
        freedata: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_array_get_element"]
    pub fn array_get_element(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        indx: *mut ::std::os::raw::c_int,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
        isNull: *mut bool,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_set_element"]
    pub fn array_set_element(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        indx: *mut ::std::os::raw::c_int,
        dataValue: Datum,
        isNull: bool,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_get_slice"]
    pub fn array_get_slice(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        upperIndx: *mut ::std::os::raw::c_int,
        lowerIndx: *mut ::std::os::raw::c_int,
        upperProvided: *mut bool,
        lowerProvided: *mut bool,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_set_slice"]
    pub fn array_set_slice(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        upperIndx: *mut ::std::os::raw::c_int,
        lowerIndx: *mut ::std::os::raw::c_int,
        upperProvided: *mut bool,
        lowerProvided: *mut bool,
        srcArrayDatum: Datum,
        isNull: bool,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_ref"]
    pub fn array_ref(
        array: *mut ArrayType,
        nSubscripts: ::std::os::raw::c_int,
        indx: *mut ::std::os::raw::c_int,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
        isNull: *mut bool,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_set"]
    pub fn array_set(
        array: *mut ArrayType,
        nSubscripts: ::std::os::raw::c_int,
        indx: *mut ::std::os::raw::c_int,
        dataValue: Datum,
        isNull: bool,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> *mut ArrayType;
}
extern "C" {
    #[link_name = "\u{1}_array_map"]
    pub fn array_map(
        arrayd: Datum,
        exprstate: *mut ExprState,
        econtext: *mut ExprContext,
        retType: Oid,
        amstate: *mut ArrayMapState,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_bitmap_copy"]
    pub fn array_bitmap_copy(
        destbitmap: *mut bits8,
        destoffset: ::std::os::raw::c_int,
        srcbitmap: *const bits8,
        srcoffset: ::std::os::raw::c_int,
        nitems: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_construct_array"]
    pub fn construct_array(
        elems: *mut Datum,
        nelems: ::std::os::raw::c_int,
        elmtype: Oid,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> *mut ArrayType;
}
extern "C" {
    #[link_name = "\u{1}_construct_md_array"]
    pub fn construct_md_array(
        elems: *mut Datum,
        nulls: *mut bool,
        ndims: ::std::os::raw::c_int,
        dims: *mut ::std::os::raw::c_int,
        lbs: *mut ::std::os::raw::c_int,
        elmtype: Oid,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> *mut ArrayType;
}
extern "C" {
    #[link_name = "\u{1}_construct_empty_array"]
    pub fn construct_empty_array(elmtype: Oid) -> *mut ArrayType;
}
extern "C" {
    #[link_name = "\u{1}_construct_empty_expanded_array"]
    pub fn construct_empty_expanded_array(
        element_type: Oid,
        parentcontext: MemoryContext,
        metacache: *mut ArrayMetaState,
    ) -> *mut ExpandedArrayHeader;
}
extern "C" {
    #[link_name = "\u{1}_deconstruct_array"]
    pub fn deconstruct_array(
        array: *mut ArrayType,
        elmtype: Oid,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
        elemsp: *mut *mut Datum,
        nullsp: *mut *mut bool,
        nelemsp: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_array_contains_nulls"]
    pub fn array_contains_nulls(array: *mut ArrayType) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_initArrayResult"]
    pub fn initArrayResult(
        element_type: Oid,
        rcontext: MemoryContext,
        subcontext: bool,
    ) -> *mut ArrayBuildState;
}
extern "C" {
    #[link_name = "\u{1}_accumArrayResult"]
    pub fn accumArrayResult(
        astate: *mut ArrayBuildState,
        dvalue: Datum,
        disnull: bool,
        element_type: Oid,
        rcontext: MemoryContext,
    ) -> *mut ArrayBuildState;
}
extern "C" {
    #[link_name = "\u{1}_makeArrayResult"]
    pub fn makeArrayResult(astate: *mut ArrayBuildState, rcontext: MemoryContext) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_makeMdArrayResult"]
    pub fn makeMdArrayResult(
        astate: *mut ArrayBuildState,
        ndims: ::std::os::raw::c_int,
        dims: *mut ::std::os::raw::c_int,
        lbs: *mut ::std::os::raw::c_int,
        rcontext: MemoryContext,
        release: bool,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_initArrayResultArr"]
    pub fn initArrayResultArr(
        array_type: Oid,
        element_type: Oid,
        rcontext: MemoryContext,
        subcontext: bool,
    ) -> *mut ArrayBuildStateArr;
}
extern "C" {
    #[link_name = "\u{1}_accumArrayResultArr"]
    pub fn accumArrayResultArr(
        astate: *mut ArrayBuildStateArr,
        dvalue: Datum,
        disnull: bool,
        array_type: Oid,
        rcontext: MemoryContext,
    ) -> *mut ArrayBuildStateArr;
}
extern "C" {
    #[link_name = "\u{1}_makeArrayResultArr"]
    pub fn makeArrayResultArr(
        astate: *mut ArrayBuildStateArr,
        rcontext: MemoryContext,
        release: bool,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_initArrayResultAny"]
    pub fn initArrayResultAny(
        input_type: Oid,
        rcontext: MemoryContext,
        subcontext: bool,
    ) -> *mut ArrayBuildStateAny;
}
extern "C" {
    #[link_name = "\u{1}_accumArrayResultAny"]
    pub fn accumArrayResultAny(
        astate: *mut ArrayBuildStateAny,
        dvalue: Datum,
        disnull: bool,
        input_type: Oid,
        rcontext: MemoryContext,
    ) -> *mut ArrayBuildStateAny;
}
extern "C" {
    #[link_name = "\u{1}_makeArrayResultAny"]
    pub fn makeArrayResultAny(
        astate: *mut ArrayBuildStateAny,
        rcontext: MemoryContext,
        release: bool,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_create_iterator"]
    pub fn array_create_iterator(
        arr: *mut ArrayType,
        slice_ndim: ::std::os::raw::c_int,
        mstate: *mut ArrayMetaState,
    ) -> ArrayIterator;
}
extern "C" {
    #[link_name = "\u{1}_array_iterate"]
    pub fn array_iterate(iterator: ArrayIterator, value: *mut Datum, isnull: *mut bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_array_free_iterator"]
    pub fn array_free_iterator(iterator: ArrayIterator);
}
extern "C" {
    #[link_name = "\u{1}_ArrayGetOffset"]
    pub fn ArrayGetOffset(
        n: ::std::os::raw::c_int,
        dim: *const ::std::os::raw::c_int,
        lb: *const ::std::os::raw::c_int,
        indx: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ArrayGetOffset0"]
    pub fn ArrayGetOffset0(
        n: ::std::os::raw::c_int,
        tup: *const ::std::os::raw::c_int,
        scale: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ArrayGetNItems"]
    pub fn ArrayGetNItems(
        ndim: ::std::os::raw::c_int,
        dims: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mda_get_range"]
    pub fn mda_get_range(
        n: ::std::os::raw::c_int,
        span: *mut ::std::os::raw::c_int,
        st: *const ::std::os::raw::c_int,
        endp: *const ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_mda_get_prod"]
    pub fn mda_get_prod(
        n: ::std::os::raw::c_int,
        range: *const ::std::os::raw::c_int,
        prod: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_mda_get_offset_values"]
    pub fn mda_get_offset_values(
        n: ::std::os::raw::c_int,
        dist: *mut ::std::os::raw::c_int,
        prod: *const ::std::os::raw::c_int,
        span: *const ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_mda_next_tuple"]
    pub fn mda_next_tuple(
        n: ::std::os::raw::c_int,
        curr: *mut ::std::os::raw::c_int,
        span: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ArrayGetIntegerTypmods"]
    pub fn ArrayGetIntegerTypmods(arr: *mut ArrayType, n: *mut ::std::os::raw::c_int)
        -> *mut int32;
}
extern "C" {
    #[link_name = "\u{1}_expand_array"]
    pub fn expand_array(
        arraydatum: Datum,
        parentcontext: MemoryContext,
        metacache: *mut ArrayMetaState,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_DatumGetExpandedArray"]
    pub fn DatumGetExpandedArray(d: Datum) -> *mut ExpandedArrayHeader;
}
extern "C" {
    #[link_name = "\u{1}_DatumGetExpandedArrayX"]
    pub fn DatumGetExpandedArrayX(
        d: Datum,
        metacache: *mut ArrayMetaState,
    ) -> *mut ExpandedArrayHeader;
}
extern "C" {
    #[link_name = "\u{1}_DatumGetAnyArrayP"]
    pub fn DatumGetAnyArrayP(d: Datum) -> *mut AnyArrayType;
}
extern "C" {
    #[link_name = "\u{1}_deconstruct_expanded_array"]
    pub fn deconstruct_expanded_array(eah: *mut ExpandedArrayHeader);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        24usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_pid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_type as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_whence as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flocktimeout {
    pub fl: flock,
    pub timeout: timespec,
}
#[test]
fn bindgen_test_layout_flocktimeout() {
    assert_eq!(
        ::std::mem::size_of::<flocktimeout>(),
        40usize,
        concat!("Size of: ", stringify!(flocktimeout))
    );
    assert_eq!(
        ::std::mem::align_of::<flocktimeout>(),
        8usize,
        concat!("Alignment of ", stringify!(flocktimeout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flocktimeout>())).fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flocktimeout),
            "::",
            stringify!(fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flocktimeout>())).timeout as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flocktimeout),
            "::",
            stringify!(timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct radvisory {
    pub ra_offset: off_t,
    pub ra_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_radvisory() {
    assert_eq!(
        ::std::mem::size_of::<radvisory>(),
        16usize,
        concat!("Size of: ", stringify!(radvisory))
    );
    assert_eq!(
        ::std::mem::align_of::<radvisory>(),
        8usize,
        concat!("Alignment of ", stringify!(radvisory))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<radvisory>())).ra_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radvisory),
            "::",
            stringify!(ra_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<radvisory>())).ra_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(radvisory),
            "::",
            stringify!(ra_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fcodeblobs {
    pub f_cd_hash: *mut ::std::os::raw::c_void,
    pub f_hash_size: usize,
    pub f_cd_buffer: *mut ::std::os::raw::c_void,
    pub f_cd_size: usize,
    pub f_out_size: *mut ::std::os::raw::c_uint,
    pub f_arch: ::std::os::raw::c_int,
    pub __padding: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fcodeblobs() {
    assert_eq!(
        ::std::mem::size_of::<fcodeblobs>(),
        48usize,
        concat!("Size of: ", stringify!(fcodeblobs))
    );
    assert_eq!(
        ::std::mem::align_of::<fcodeblobs>(),
        8usize,
        concat!("Alignment of ", stringify!(fcodeblobs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_cd_hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_cd_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_hash_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_hash_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_cd_buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_cd_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_cd_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_cd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_out_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_out_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).f_arch as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(f_arch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fcodeblobs>())).__padding as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(fcodeblobs),
            "::",
            stringify!(__padding)
        )
    );
}
pub type fcodeblobs_t = fcodeblobs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsignatures {
    pub fs_file_start: off_t,
    pub fs_blob_start: *mut ::std::os::raw::c_void,
    pub fs_blob_size: usize,
}
#[test]
fn bindgen_test_layout_fsignatures() {
    assert_eq!(
        ::std::mem::size_of::<fsignatures>(),
        24usize,
        concat!("Size of: ", stringify!(fsignatures))
    );
    assert_eq!(
        ::std::mem::align_of::<fsignatures>(),
        8usize,
        concat!("Alignment of ", stringify!(fsignatures))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsignatures>())).fs_file_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_file_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsignatures>())).fs_blob_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_blob_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsignatures>())).fs_blob_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fsignatures),
            "::",
            stringify!(fs_blob_size)
        )
    );
}
pub type fsignatures_t = fsignatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fchecklv {
    pub lv_file_start: off_t,
    pub lv_error_message_size: usize,
    pub lv_error_message: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_fchecklv() {
    assert_eq!(
        ::std::mem::size_of::<fchecklv>(),
        24usize,
        concat!("Size of: ", stringify!(fchecklv))
    );
    assert_eq!(
        ::std::mem::align_of::<fchecklv>(),
        8usize,
        concat!("Alignment of ", stringify!(fchecklv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fchecklv>())).lv_file_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fchecklv),
            "::",
            stringify!(lv_file_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fchecklv>())).lv_error_message_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fchecklv),
            "::",
            stringify!(lv_error_message_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fchecklv>())).lv_error_message as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fchecklv),
            "::",
            stringify!(lv_error_message)
        )
    );
}
pub type fchecklv_t = fchecklv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fstore {
    pub fst_flags: ::std::os::raw::c_uint,
    pub fst_posmode: ::std::os::raw::c_int,
    pub fst_offset: off_t,
    pub fst_length: off_t,
    pub fst_bytesalloc: off_t,
}
#[test]
fn bindgen_test_layout_fstore() {
    assert_eq!(
        ::std::mem::size_of::<fstore>(),
        32usize,
        concat!("Size of: ", stringify!(fstore))
    );
    assert_eq!(
        ::std::mem::align_of::<fstore>(),
        8usize,
        concat!("Alignment of ", stringify!(fstore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstore>())).fst_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstore>())).fst_posmode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_posmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstore>())).fst_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstore>())).fst_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstore>())).fst_bytesalloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fstore),
            "::",
            stringify!(fst_bytesalloc)
        )
    );
}
pub type fstore_t = fstore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpunchhole {
    pub fp_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fp_offset: off_t,
    pub fp_length: off_t,
}
#[test]
fn bindgen_test_layout_fpunchhole() {
    assert_eq!(
        ::std::mem::size_of::<fpunchhole>(),
        24usize,
        concat!("Size of: ", stringify!(fpunchhole))
    );
    assert_eq!(
        ::std::mem::align_of::<fpunchhole>(),
        8usize,
        concat!("Alignment of ", stringify!(fpunchhole))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpunchhole>())).fp_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(fp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpunchhole>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpunchhole>())).fp_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpunchhole>())).fp_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpunchhole),
            "::",
            stringify!(fp_length)
        )
    );
}
pub type fpunchhole_t = fpunchhole;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrimactivefile {
    pub fta_offset: off_t,
    pub fta_length: off_t,
}
#[test]
fn bindgen_test_layout_ftrimactivefile() {
    assert_eq!(
        ::std::mem::size_of::<ftrimactivefile>(),
        16usize,
        concat!("Size of: ", stringify!(ftrimactivefile))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrimactivefile>(),
        8usize,
        concat!("Alignment of ", stringify!(ftrimactivefile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrimactivefile>())).fta_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrimactivefile),
            "::",
            stringify!(fta_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrimactivefile>())).fta_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrimactivefile),
            "::",
            stringify!(fta_length)
        )
    );
}
pub type ftrimactivefile_t = ftrimactivefile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fbootstraptransfer {
    pub fbt_offset: off_t,
    pub fbt_length: usize,
    pub fbt_buffer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_fbootstraptransfer() {
    assert_eq!(
        ::std::mem::size_of::<fbootstraptransfer>(),
        24usize,
        concat!("Size of: ", stringify!(fbootstraptransfer))
    );
    assert_eq!(
        ::std::mem::align_of::<fbootstraptransfer>(),
        8usize,
        concat!("Alignment of ", stringify!(fbootstraptransfer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fbootstraptransfer>())).fbt_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fbootstraptransfer),
            "::",
            stringify!(fbt_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fbootstraptransfer>())).fbt_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fbootstraptransfer),
            "::",
            stringify!(fbt_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fbootstraptransfer>())).fbt_buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fbootstraptransfer),
            "::",
            stringify!(fbt_buffer)
        )
    );
}
pub type fbootstraptransfer_t = fbootstraptransfer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct log2phys {
    pub _bindgen_opaque_blob: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_log2phys() {
    assert_eq!(
        ::std::mem::size_of::<log2phys>(),
        20usize,
        concat!("Size of: ", stringify!(log2phys))
    );
    assert_eq!(
        ::std::mem::align_of::<log2phys>(),
        4usize,
        concat!("Alignment of ", stringify!(log2phys))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = *mut _filesec;
pub const filesec_property_t_FILESEC_OWNER: filesec_property_t = 1;
pub const filesec_property_t_FILESEC_GROUP: filesec_property_t = 2;
pub const filesec_property_t_FILESEC_UUID: filesec_property_t = 3;
pub const filesec_property_t_FILESEC_MODE: filesec_property_t = 4;
pub const filesec_property_t_FILESEC_ACL: filesec_property_t = 5;
pub const filesec_property_t_FILESEC_GRPUUID: filesec_property_t = 6;
pub const filesec_property_t_FILESEC_ACL_RAW: filesec_property_t = 100;
pub const filesec_property_t_FILESEC_ACL_ALLOCSIZE: filesec_property_t = 101;
pub type filesec_property_t = u32;
extern "C" {
    #[link_name = "\u{1}_open"]
    pub fn open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_openat"]
    pub fn openat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_creat"]
    pub fn creat(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fcntl"]
    pub fn fcntl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_openx_np"]
    pub fn openx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_open_dprotected_np"]
    pub fn open_dprotected_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_flock"]
    pub fn flock(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_filesec_init"]
    pub fn filesec_init() -> filesec_t;
}
extern "C" {
    #[link_name = "\u{1}_filesec_dup"]
    pub fn filesec_dup(arg1: filesec_t) -> filesec_t;
}
extern "C" {
    #[link_name = "\u{1}_filesec_free"]
    pub fn filesec_free(arg1: filesec_t);
}
extern "C" {
    #[link_name = "\u{1}_filesec_get_property"]
    pub fn filesec_get_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_filesec_query_property"]
    pub fn filesec_query_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_filesec_set_property"]
    pub fn filesec_set_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_filesec_unset_property"]
    pub fn filesec_unset_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
    ) -> ::std::os::raw::c_int;
}
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
pub type RepOriginId = uint16;
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Interval {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
#[test]
fn bindgen_test_layout_Interval() {
    assert_eq!(
        ::std::mem::size_of::<Interval>(),
        16usize,
        concat!("Size of: ", stringify!(Interval))
    );
    assert_eq!(
        ::std::mem::align_of::<Interval>(),
        8usize,
        concat!("Alignment of ", stringify!(Interval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Interval>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Interval),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Interval>())).day as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Interval),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Interval>())).month as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Interval),
            "::",
            stringify!(month)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StringInfoData {
    pub data: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
    pub maxlen: ::std::os::raw::c_int,
    pub cursor: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_StringInfoData() {
    assert_eq!(
        ::std::mem::size_of::<StringInfoData>(),
        24usize,
        concat!("Size of: ", stringify!(StringInfoData))
    );
    assert_eq!(
        ::std::mem::align_of::<StringInfoData>(),
        8usize,
        concat!("Alignment of ", stringify!(StringInfoData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StringInfoData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StringInfoData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StringInfoData>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StringInfoData),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StringInfoData>())).maxlen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(StringInfoData),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StringInfoData>())).cursor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(StringInfoData),
            "::",
            stringify!(cursor)
        )
    );
}
pub type StringInfo = *mut StringInfoData;
extern "C" {
    #[link_name = "\u{1}_makeStringInfo"]
    pub fn makeStringInfo() -> StringInfo;
}
extern "C" {
    #[link_name = "\u{1}_initStringInfo"]
    pub fn initStringInfo(str: StringInfo);
}
extern "C" {
    #[link_name = "\u{1}_resetStringInfo"]
    pub fn resetStringInfo(str: StringInfo);
}
extern "C" {
    #[link_name = "\u{1}_appendStringInfo"]
    pub fn appendStringInfo(str: StringInfo, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_appendStringInfoVA"]
    pub fn appendStringInfoVA(
        str: StringInfo,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_appendStringInfoString"]
    pub fn appendStringInfoString(str: StringInfo, s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_appendStringInfoChar"]
    pub fn appendStringInfoChar(str: StringInfo, ch: ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_appendStringInfoSpaces"]
    pub fn appendStringInfoSpaces(str: StringInfo, count: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_appendBinaryStringInfo"]
    pub fn appendBinaryStringInfo(
        str: StringInfo,
        data: *const ::std::os::raw::c_char,
        datalen: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_appendBinaryStringInfoNT"]
    pub fn appendBinaryStringInfoNT(
        str: StringInfo,
        data: *const ::std::os::raw::c_char,
        datalen: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_enlargeStringInfo"]
    pub fn enlargeStringInfo(str: StringInfo, needed: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pairingheap_node {
    pub first_child: *mut pairingheap_node,
    pub next_sibling: *mut pairingheap_node,
    pub prev_or_parent: *mut pairingheap_node,
}
#[test]
fn bindgen_test_layout_pairingheap_node() {
    assert_eq!(
        ::std::mem::size_of::<pairingheap_node>(),
        24usize,
        concat!("Size of: ", stringify!(pairingheap_node))
    );
    assert_eq!(
        ::std::mem::align_of::<pairingheap_node>(),
        8usize,
        concat!("Alignment of ", stringify!(pairingheap_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pairingheap_node>())).first_child as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pairingheap_node),
            "::",
            stringify!(first_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pairingheap_node>())).next_sibling as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pairingheap_node),
            "::",
            stringify!(next_sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pairingheap_node>())).prev_or_parent as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pairingheap_node),
            "::",
            stringify!(prev_or_parent)
        )
    );
}
pub type pairingheap_comparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const pairingheap_node,
        b: *const pairingheap_node,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pairingheap {
    pub ph_compare: pairingheap_comparator,
    pub ph_arg: *mut ::std::os::raw::c_void,
    pub ph_root: *mut pairingheap_node,
}
#[test]
fn bindgen_test_layout_pairingheap() {
    assert_eq!(
        ::std::mem::size_of::<pairingheap>(),
        24usize,
        concat!("Size of: ", stringify!(pairingheap))
    );
    assert_eq!(
        ::std::mem::align_of::<pairingheap>(),
        8usize,
        concat!("Alignment of ", stringify!(pairingheap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pairingheap>())).ph_compare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pairingheap),
            "::",
            stringify!(ph_compare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pairingheap>())).ph_arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pairingheap),
            "::",
            stringify!(ph_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pairingheap>())).ph_root as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pairingheap),
            "::",
            stringify!(ph_root)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_pairingheap_allocate"]
    pub fn pairingheap_allocate(
        compare: pairingheap_comparator,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut pairingheap;
}
extern "C" {
    #[link_name = "\u{1}_pairingheap_free"]
    pub fn pairingheap_free(heap: *mut pairingheap);
}
extern "C" {
    #[link_name = "\u{1}_pairingheap_add"]
    pub fn pairingheap_add(heap: *mut pairingheap, node: *mut pairingheap_node);
}
extern "C" {
    #[link_name = "\u{1}_pairingheap_first"]
    pub fn pairingheap_first(heap: *mut pairingheap) -> *mut pairingheap_node;
}
extern "C" {
    #[link_name = "\u{1}_pairingheap_remove_first"]
    pub fn pairingheap_remove_first(heap: *mut pairingheap) -> *mut pairingheap_node;
}
extern "C" {
    #[link_name = "\u{1}_pairingheap_remove"]
    pub fn pairingheap_remove(heap: *mut pairingheap, node: *mut pairingheap_node);
}
pub type Buffer = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferAccessStrategyData {
    _unused: [u8; 0],
}
pub type BufferAccessStrategy = *mut BufferAccessStrategyData;
pub type Snapshot = *mut SnapshotData;
pub type SnapshotSatisfiesFunc = ::std::option::Option<
    unsafe extern "C" fn(htup: HeapTuple, snapshot: Snapshot, buffer: Buffer) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SnapshotData {
    pub satisfies: SnapshotSatisfiesFunc,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: *mut TransactionId,
    pub xcnt: uint32,
    pub subxip: *mut TransactionId,
    pub subxcnt: int32,
    pub suboverflowed: bool,
    pub takenDuringRecovery: bool,
    pub copied: bool,
    pub curcid: CommandId,
    pub speculativeToken: uint32,
    pub active_count: uint32,
    pub regd_count: uint32,
    pub ph_node: pairingheap_node,
    pub whenTaken: TimestampTz,
    pub lsn: XLogRecPtr,
}
#[test]
fn bindgen_test_layout_SnapshotData() {
    assert_eq!(
        ::std::mem::size_of::<SnapshotData>(),
        104usize,
        concat!("Size of: ", stringify!(SnapshotData))
    );
    assert_eq!(
        ::std::mem::align_of::<SnapshotData>(),
        8usize,
        concat!("Alignment of ", stringify!(SnapshotData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).satisfies as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(satisfies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).xmin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(xmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).xmax as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).xip as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(xip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).xcnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(xcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).subxip as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(subxip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).subxcnt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(subxcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).suboverflowed as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(suboverflowed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SnapshotData>())).takenDuringRecovery as *const _ as usize
        },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(takenDuringRecovery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).copied as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(copied)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).curcid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(curcid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).speculativeToken as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(speculativeToken)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).active_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(active_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).regd_count as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(regd_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).ph_node as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(ph_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).whenTaken as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(whenTaken)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SnapshotData>())).lsn as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SnapshotData),
            "::",
            stringify!(lsn)
        )
    );
}
pub const HTSU_Result_HeapTupleMayBeUpdated: HTSU_Result = 0;
pub const HTSU_Result_HeapTupleInvisible: HTSU_Result = 1;
pub const HTSU_Result_HeapTupleSelfUpdated: HTSU_Result = 2;
pub const HTSU_Result_HeapTupleUpdated: HTSU_Result = 3;
pub const HTSU_Result_HeapTupleBeingUpdated: HTSU_Result = 4;
pub const HTSU_Result_HeapTupleWouldBlock: HTSU_Result = 5;
pub type HTSU_Result = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AclItem {
    pub ai_grantee: Oid,
    pub ai_grantor: Oid,
    pub ai_privs: AclMode,
}
#[test]
fn bindgen_test_layout_AclItem() {
    assert_eq!(
        ::std::mem::size_of::<AclItem>(),
        12usize,
        concat!("Size of: ", stringify!(AclItem))
    );
    assert_eq!(
        ::std::mem::align_of::<AclItem>(),
        4usize,
        concat!("Alignment of ", stringify!(AclItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AclItem>())).ai_grantee as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AclItem),
            "::",
            stringify!(ai_grantee)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AclItem>())).ai_grantor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AclItem),
            "::",
            stringify!(ai_grantor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AclItem>())).ai_privs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AclItem),
            "::",
            stringify!(ai_privs)
        )
    );
}
pub type Acl = ArrayType;
pub const AclMaskHow_ACLMASK_ALL: AclMaskHow = 0;
pub const AclMaskHow_ACLMASK_ANY: AclMaskHow = 1;
pub type AclMaskHow = u32;
pub const AclResult_ACLCHECK_OK: AclResult = 0;
pub const AclResult_ACLCHECK_NO_PRIV: AclResult = 1;
pub const AclResult_ACLCHECK_NOT_OWNER: AclResult = 2;
pub type AclResult = u32;
extern "C" {
    #[link_name = "\u{1}_acldefault"]
    pub fn acldefault(objtype: ObjectType, ownerId: Oid) -> *mut Acl;
}
extern "C" {
    #[link_name = "\u{1}_get_user_default_acl"]
    pub fn get_user_default_acl(objtype: ObjectType, ownerId: Oid, nsp_oid: Oid) -> *mut Acl;
}
extern "C" {
    #[link_name = "\u{1}_aclupdate"]
    pub fn aclupdate(
        old_acl: *const Acl,
        mod_aip: *const AclItem,
        modechg: ::std::os::raw::c_int,
        ownerId: Oid,
        behavior: DropBehavior,
    ) -> *mut Acl;
}
extern "C" {
    #[link_name = "\u{1}_aclnewowner"]
    pub fn aclnewowner(old_acl: *const Acl, oldOwnerId: Oid, newOwnerId: Oid) -> *mut Acl;
}
extern "C" {
    #[link_name = "\u{1}_make_empty_acl"]
    pub fn make_empty_acl() -> *mut Acl;
}
extern "C" {
    #[link_name = "\u{1}_aclcopy"]
    pub fn aclcopy(orig_acl: *const Acl) -> *mut Acl;
}
extern "C" {
    #[link_name = "\u{1}_aclconcat"]
    pub fn aclconcat(left_acl: *const Acl, right_acl: *const Acl) -> *mut Acl;
}
extern "C" {
    #[link_name = "\u{1}_aclmerge"]
    pub fn aclmerge(left_acl: *const Acl, right_acl: *const Acl, ownerId: Oid) -> *mut Acl;
}
extern "C" {
    #[link_name = "\u{1}_aclitemsort"]
    pub fn aclitemsort(acl: *mut Acl);
}
extern "C" {
    #[link_name = "\u{1}_aclequal"]
    pub fn aclequal(left_acl: *const Acl, right_acl: *const Acl) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_aclmask"]
    pub fn aclmask(
        acl: *const Acl,
        roleid: Oid,
        ownerId: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_aclmembers"]
    pub fn aclmembers(acl: *const Acl, roleids: *mut *mut Oid) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_has_privs_of_role"]
    pub fn has_privs_of_role(member: Oid, role: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_is_member_of_role"]
    pub fn is_member_of_role(member: Oid, role: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_is_member_of_role_nosuper"]
    pub fn is_member_of_role_nosuper(member: Oid, role: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_is_admin_of_role"]
    pub fn is_admin_of_role(member: Oid, role: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_check_is_member_of_role"]
    pub fn check_is_member_of_role(member: Oid, role: Oid);
}
extern "C" {
    #[link_name = "\u{1}_get_role_oid"]
    pub fn get_role_oid(rolename: *const ::std::os::raw::c_char, missing_ok: bool) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_get_role_oid_or_public"]
    pub fn get_role_oid_or_public(rolename: *const ::std::os::raw::c_char) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_get_rolespec_oid"]
    pub fn get_rolespec_oid(role: *const RoleSpec, missing_ok: bool) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_check_rolespec_name"]
    pub fn check_rolespec_name(role: *const RoleSpec, detail_msg: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_get_rolespec_tuple"]
    pub fn get_rolespec_tuple(role: *const RoleSpec) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_get_rolespec_name"]
    pub fn get_rolespec_name(role: *const RoleSpec) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_select_best_grantor"]
    pub fn select_best_grantor(
        roleId: Oid,
        privileges: AclMode,
        acl: *const Acl,
        ownerId: Oid,
        grantorId: *mut Oid,
        grantOptions: *mut AclMode,
    );
}
extern "C" {
    #[link_name = "\u{1}_initialize_acl"]
    pub fn initialize_acl();
}
extern "C" {
    #[link_name = "\u{1}_ExecuteGrantStmt"]
    pub fn ExecuteGrantStmt(stmt: *mut GrantStmt);
}
extern "C" {
    #[link_name = "\u{1}_ExecAlterDefaultPrivilegesStmt"]
    pub fn ExecAlterDefaultPrivilegesStmt(
        pstate: *mut ParseState,
        stmt: *mut AlterDefaultPrivilegesStmt,
    );
}
extern "C" {
    #[link_name = "\u{1}_RemoveRoleFromObjectACL"]
    pub fn RemoveRoleFromObjectACL(roleid: Oid, classid: Oid, objid: Oid);
}
extern "C" {
    #[link_name = "\u{1}_RemoveDefaultACLById"]
    pub fn RemoveDefaultACLById(defaclOid: Oid);
}
extern "C" {
    #[link_name = "\u{1}_pg_attribute_aclmask"]
    pub fn pg_attribute_aclmask(
        table_oid: Oid,
        attnum: AttrNumber,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_pg_class_aclmask"]
    pub fn pg_class_aclmask(table_oid: Oid, roleid: Oid, mask: AclMode, how: AclMaskHow)
        -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_pg_database_aclmask"]
    pub fn pg_database_aclmask(db_oid: Oid, roleid: Oid, mask: AclMode, how: AclMaskHow)
        -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_pg_proc_aclmask"]
    pub fn pg_proc_aclmask(proc_oid: Oid, roleid: Oid, mask: AclMode, how: AclMaskHow) -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_pg_language_aclmask"]
    pub fn pg_language_aclmask(
        lang_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_pg_largeobject_aclmask_snapshot"]
    pub fn pg_largeobject_aclmask_snapshot(
        lobj_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
        snapshot: Snapshot,
    ) -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_pg_namespace_aclmask"]
    pub fn pg_namespace_aclmask(
        nsp_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_pg_tablespace_aclmask"]
    pub fn pg_tablespace_aclmask(
        spc_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_pg_foreign_data_wrapper_aclmask"]
    pub fn pg_foreign_data_wrapper_aclmask(
        fdw_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_pg_foreign_server_aclmask"]
    pub fn pg_foreign_server_aclmask(
        srv_oid: Oid,
        roleid: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_pg_type_aclmask"]
    pub fn pg_type_aclmask(type_oid: Oid, roleid: Oid, mask: AclMode, how: AclMaskHow) -> AclMode;
}
extern "C" {
    #[link_name = "\u{1}_pg_attribute_aclcheck"]
    pub fn pg_attribute_aclcheck(
        table_oid: Oid,
        attnum: AttrNumber,
        roleid: Oid,
        mode: AclMode,
    ) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_pg_attribute_aclcheck_all"]
    pub fn pg_attribute_aclcheck_all(
        table_oid: Oid,
        roleid: Oid,
        mode: AclMode,
        how: AclMaskHow,
    ) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_pg_class_aclcheck"]
    pub fn pg_class_aclcheck(table_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_pg_database_aclcheck"]
    pub fn pg_database_aclcheck(db_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_pg_proc_aclcheck"]
    pub fn pg_proc_aclcheck(proc_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_pg_language_aclcheck"]
    pub fn pg_language_aclcheck(lang_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_pg_largeobject_aclcheck_snapshot"]
    pub fn pg_largeobject_aclcheck_snapshot(
        lang_oid: Oid,
        roleid: Oid,
        mode: AclMode,
        snapshot: Snapshot,
    ) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_pg_namespace_aclcheck"]
    pub fn pg_namespace_aclcheck(nsp_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_pg_tablespace_aclcheck"]
    pub fn pg_tablespace_aclcheck(spc_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_pg_foreign_data_wrapper_aclcheck"]
    pub fn pg_foreign_data_wrapper_aclcheck(fdw_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_pg_foreign_server_aclcheck"]
    pub fn pg_foreign_server_aclcheck(srv_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_pg_type_aclcheck"]
    pub fn pg_type_aclcheck(type_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
}
extern "C" {
    #[link_name = "\u{1}_aclcheck_error"]
    pub fn aclcheck_error(
        aclerr: AclResult,
        objtype: ObjectType,
        objectname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_aclcheck_error_col"]
    pub fn aclcheck_error_col(
        aclerr: AclResult,
        objtype: ObjectType,
        objectname: *const ::std::os::raw::c_char,
        colname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_aclcheck_error_type"]
    pub fn aclcheck_error_type(aclerr: AclResult, typeOid: Oid);
}
extern "C" {
    #[link_name = "\u{1}_recordExtObjInitPriv"]
    pub fn recordExtObjInitPriv(objoid: Oid, classoid: Oid);
}
extern "C" {
    #[link_name = "\u{1}_removeExtObjInitPriv"]
    pub fn removeExtObjInitPriv(objoid: Oid, classoid: Oid);
}
extern "C" {
    #[link_name = "\u{1}_pg_class_ownercheck"]
    pub fn pg_class_ownercheck(class_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_type_ownercheck"]
    pub fn pg_type_ownercheck(type_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_oper_ownercheck"]
    pub fn pg_oper_ownercheck(oper_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_proc_ownercheck"]
    pub fn pg_proc_ownercheck(proc_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_language_ownercheck"]
    pub fn pg_language_ownercheck(lan_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_largeobject_ownercheck"]
    pub fn pg_largeobject_ownercheck(lobj_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_namespace_ownercheck"]
    pub fn pg_namespace_ownercheck(nsp_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_tablespace_ownercheck"]
    pub fn pg_tablespace_ownercheck(spc_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_opclass_ownercheck"]
    pub fn pg_opclass_ownercheck(opc_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_opfamily_ownercheck"]
    pub fn pg_opfamily_ownercheck(opf_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_database_ownercheck"]
    pub fn pg_database_ownercheck(db_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_collation_ownercheck"]
    pub fn pg_collation_ownercheck(coll_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_conversion_ownercheck"]
    pub fn pg_conversion_ownercheck(conv_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_ts_dict_ownercheck"]
    pub fn pg_ts_dict_ownercheck(dict_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_ts_config_ownercheck"]
    pub fn pg_ts_config_ownercheck(cfg_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_foreign_data_wrapper_ownercheck"]
    pub fn pg_foreign_data_wrapper_ownercheck(srv_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_foreign_server_ownercheck"]
    pub fn pg_foreign_server_ownercheck(srv_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_event_trigger_ownercheck"]
    pub fn pg_event_trigger_ownercheck(et_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_extension_ownercheck"]
    pub fn pg_extension_ownercheck(ext_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_publication_ownercheck"]
    pub fn pg_publication_ownercheck(pub_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_subscription_ownercheck"]
    pub fn pg_subscription_ownercheck(sub_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_statistics_object_ownercheck"]
    pub fn pg_statistics_object_ownercheck(stat_oid: Oid, roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_has_createrole_privilege"]
    pub fn has_createrole_privilege(roleid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_has_bypassrls_privilege"]
    pub fn has_bypassrls_privilege(roleid: Oid) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectAddress {
    pub classId: Oid,
    pub objectId: Oid,
    pub objectSubId: int32,
}
#[test]
fn bindgen_test_layout_ObjectAddress() {
    assert_eq!(
        ::std::mem::size_of::<ObjectAddress>(),
        12usize,
        concat!("Size of: ", stringify!(ObjectAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<ObjectAddress>(),
        4usize,
        concat!("Alignment of ", stringify!(ObjectAddress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjectAddress>())).classId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectAddress),
            "::",
            stringify!(classId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjectAddress>())).objectId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectAddress),
            "::",
            stringify!(objectId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ObjectAddress>())).objectSubId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectAddress),
            "::",
            stringify!(objectSubId)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_InvalidObjectAddress"]
    pub static InvalidObjectAddress: ObjectAddress;
}
extern "C" {
    #[link_name = "\u{1}_get_object_address"]
    pub fn get_object_address(
        objtype: ObjectType,
        object: *mut Node,
        relp: *mut Relation,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> ObjectAddress;
}
extern "C" {
    #[link_name = "\u{1}_get_object_address_rv"]
    pub fn get_object_address_rv(
        objtype: ObjectType,
        rel: *mut RangeVar,
        object: *mut List,
        relp: *mut Relation,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> ObjectAddress;
}
extern "C" {
    #[link_name = "\u{1}_check_object_ownership"]
    pub fn check_object_ownership(
        roleid: Oid,
        objtype: ObjectType,
        address: ObjectAddress,
        object: *mut Node,
        relation: Relation,
    );
}
extern "C" {
    #[link_name = "\u{1}_get_object_namespace"]
    pub fn get_object_namespace(address: *const ObjectAddress) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_is_objectclass_supported"]
    pub fn is_objectclass_supported(class_id: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_get_object_oid_index"]
    pub fn get_object_oid_index(class_id: Oid) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_get_object_catcache_oid"]
    pub fn get_object_catcache_oid(class_id: Oid) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_get_object_catcache_name"]
    pub fn get_object_catcache_name(class_id: Oid) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_get_object_attnum_name"]
    pub fn get_object_attnum_name(class_id: Oid) -> AttrNumber;
}
extern "C" {
    #[link_name = "\u{1}_get_object_attnum_namespace"]
    pub fn get_object_attnum_namespace(class_id: Oid) -> AttrNumber;
}
extern "C" {
    #[link_name = "\u{1}_get_object_attnum_owner"]
    pub fn get_object_attnum_owner(class_id: Oid) -> AttrNumber;
}
extern "C" {
    #[link_name = "\u{1}_get_object_attnum_acl"]
    pub fn get_object_attnum_acl(class_id: Oid) -> AttrNumber;
}
extern "C" {
    #[link_name = "\u{1}_get_object_type"]
    pub fn get_object_type(class_id: Oid, object_id: Oid) -> ObjectType;
}
extern "C" {
    #[link_name = "\u{1}_get_object_namensp_unique"]
    pub fn get_object_namensp_unique(class_id: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_get_catalog_object_by_oid"]
    pub fn get_catalog_object_by_oid(catalog: Relation, objectId: Oid) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_getObjectDescription"]
    pub fn getObjectDescription(object: *const ObjectAddress) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getObjectDescriptionOids"]
    pub fn getObjectDescriptionOids(classid: Oid, objid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_read_objtype_from_string"]
    pub fn read_objtype_from_string(
        objtype: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getObjectTypeDescription"]
    pub fn getObjectTypeDescription(object: *const ObjectAddress) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getObjectIdentity"]
    pub fn getObjectIdentity(address: *const ObjectAddress) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getObjectIdentityParts"]
    pub fn getObjectIdentityParts(
        address: *const ObjectAddress,
        objname: *mut *mut List,
        objargs: *mut *mut List,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_strlist_to_textarray"]
    pub fn strlist_to_textarray(list: *mut List) -> *mut ArrayType;
}
extern "C" {
    #[link_name = "\u{1}_get_relkind_objtype"]
    pub fn get_relkind_objtype(relkind: ::std::os::raw::c_char) -> ObjectType;
}
pub const ScanDirection_BackwardScanDirection: ScanDirection = -1;
pub const ScanDirection_NoMovementScanDirection: ScanDirection = 0;
pub const ScanDirection_ForwardScanDirection: ScanDirection = 1;
pub type ScanDirection = i32;
pub type StrategyNumber = uint16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScanKeyData {
    pub sk_flags: ::std::os::raw::c_int,
    pub sk_attno: AttrNumber,
    pub sk_strategy: StrategyNumber,
    pub sk_subtype: Oid,
    pub sk_collation: Oid,
    pub sk_func: FmgrInfo,
    pub sk_argument: Datum,
}
#[test]
fn bindgen_test_layout_ScanKeyData() {
    assert_eq!(
        ::std::mem::size_of::<ScanKeyData>(),
        72usize,
        concat!("Size of: ", stringify!(ScanKeyData))
    );
    assert_eq!(
        ::std::mem::align_of::<ScanKeyData>(),
        8usize,
        concat!("Alignment of ", stringify!(ScanKeyData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScanKeyData>())).sk_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ScanKeyData),
            "::",
            stringify!(sk_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScanKeyData>())).sk_attno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ScanKeyData),
            "::",
            stringify!(sk_attno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScanKeyData>())).sk_strategy as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ScanKeyData),
            "::",
            stringify!(sk_strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScanKeyData>())).sk_subtype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ScanKeyData),
            "::",
            stringify!(sk_subtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScanKeyData>())).sk_collation as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ScanKeyData),
            "::",
            stringify!(sk_collation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScanKeyData>())).sk_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ScanKeyData),
            "::",
            stringify!(sk_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScanKeyData>())).sk_argument as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ScanKeyData),
            "::",
            stringify!(sk_argument)
        )
    );
}
pub type ScanKey = *mut ScanKeyData;
extern "C" {
    #[link_name = "\u{1}_ScanKeyInit"]
    pub fn ScanKeyInit(
        entry: ScanKey,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        procedure: RegProcedure,
        argument: Datum,
    );
}
extern "C" {
    #[link_name = "\u{1}_ScanKeyEntryInitialize"]
    pub fn ScanKeyEntryInitialize(
        entry: ScanKey,
        flags: ::std::os::raw::c_int,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        subtype: Oid,
        collation: Oid,
        procedure: RegProcedure,
        argument: Datum,
    );
}
extern "C" {
    #[link_name = "\u{1}_ScanKeyEntryInitializeWithInfo"]
    pub fn ScanKeyEntryInitializeWithInfo(
        entry: ScanKey,
        flags: ::std::os::raw::c_int,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        subtype: Oid,
        collation: Oid,
        finfo: *mut FmgrInfo,
        argument: Datum,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_atomic_flag {
    pub value: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pg_atomic_flag() {
    assert_eq!(
        ::std::mem::size_of::<pg_atomic_flag>(),
        1usize,
        concat!("Size of: ", stringify!(pg_atomic_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<pg_atomic_flag>(),
        1usize,
        concat!("Alignment of ", stringify!(pg_atomic_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pg_atomic_flag>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_atomic_flag),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_atomic_uint32 {
    pub value: uint32,
}
#[test]
fn bindgen_test_layout_pg_atomic_uint32() {
    assert_eq!(
        ::std::mem::size_of::<pg_atomic_uint32>(),
        4usize,
        concat!("Size of: ", stringify!(pg_atomic_uint32))
    );
    assert_eq!(
        ::std::mem::align_of::<pg_atomic_uint32>(),
        4usize,
        concat!("Alignment of ", stringify!(pg_atomic_uint32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pg_atomic_uint32>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_atomic_uint32),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_atomic_uint64 {
    pub value: uint64,
}
#[test]
fn bindgen_test_layout_pg_atomic_uint64() {
    assert_eq!(
        ::std::mem::size_of::<pg_atomic_uint64>(),
        8usize,
        concat!("Size of: ", stringify!(pg_atomic_uint64))
    );
    assert_eq!(
        ::std::mem::align_of::<pg_atomic_uint64>(),
        8usize,
        concat!("Alignment of ", stringify!(pg_atomic_uint64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pg_atomic_uint64>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_atomic_uint64),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_dynamic_shared_memory_type"]
    pub static mut dynamic_shared_memory_type: ::std::os::raw::c_int;
}
pub type dsm_handle = uint32;
pub const dsm_op_DSM_OP_CREATE: dsm_op = 0;
pub const dsm_op_DSM_OP_ATTACH: dsm_op = 1;
pub const dsm_op_DSM_OP_DETACH: dsm_op = 2;
pub const dsm_op_DSM_OP_RESIZE: dsm_op = 3;
pub const dsm_op_DSM_OP_DESTROY: dsm_op = 4;
pub type dsm_op = u32;
extern "C" {
    #[link_name = "\u{1}_dsm_impl_op"]
    pub fn dsm_impl_op(
        op: dsm_op,
        handle: dsm_handle,
        request_size: Size,
        impl_private: *mut *mut ::std::os::raw::c_void,
        mapped_address: *mut *mut ::std::os::raw::c_void,
        mapped_size: *mut Size,
        elevel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_dsm_impl_can_resize"]
    pub fn dsm_impl_can_resize() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_dsm_impl_pin_segment"]
    pub fn dsm_impl_pin_segment(
        handle: dsm_handle,
        impl_private: *mut ::std::os::raw::c_void,
        impl_private_pm_handle: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_dsm_impl_unpin_segment"]
    pub fn dsm_impl_unpin_segment(
        handle: dsm_handle,
        impl_private: *mut *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsm_segment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGShmemHeader {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_dsm_cleanup_using_control_segment"]
    pub fn dsm_cleanup_using_control_segment(old_control_handle: dsm_handle);
}
extern "C" {
    #[link_name = "\u{1}_dsm_postmaster_startup"]
    pub fn dsm_postmaster_startup(arg1: *mut PGShmemHeader);
}
extern "C" {
    #[link_name = "\u{1}_dsm_backend_shutdown"]
    pub fn dsm_backend_shutdown();
}
extern "C" {
    #[link_name = "\u{1}_dsm_detach_all"]
    pub fn dsm_detach_all();
}
extern "C" {
    #[link_name = "\u{1}_dsm_create"]
    pub fn dsm_create(size: Size, flags: ::std::os::raw::c_int) -> *mut dsm_segment;
}
extern "C" {
    #[link_name = "\u{1}_dsm_attach"]
    pub fn dsm_attach(h: dsm_handle) -> *mut dsm_segment;
}
extern "C" {
    #[link_name = "\u{1}_dsm_resize"]
    pub fn dsm_resize(seg: *mut dsm_segment, size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_dsm_remap"]
    pub fn dsm_remap(seg: *mut dsm_segment) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_dsm_detach"]
    pub fn dsm_detach(seg: *mut dsm_segment);
}
extern "C" {
    #[link_name = "\u{1}_dsm_pin_mapping"]
    pub fn dsm_pin_mapping(seg: *mut dsm_segment);
}
extern "C" {
    #[link_name = "\u{1}_dsm_unpin_mapping"]
    pub fn dsm_unpin_mapping(seg: *mut dsm_segment);
}
extern "C" {
    #[link_name = "\u{1}_dsm_pin_segment"]
    pub fn dsm_pin_segment(seg: *mut dsm_segment);
}
extern "C" {
    #[link_name = "\u{1}_dsm_unpin_segment"]
    pub fn dsm_unpin_segment(h: dsm_handle);
}
extern "C" {
    #[link_name = "\u{1}_dsm_find_mapping"]
    pub fn dsm_find_mapping(h: dsm_handle) -> *mut dsm_segment;
}
extern "C" {
    #[link_name = "\u{1}_dsm_segment_address"]
    pub fn dsm_segment_address(seg: *mut dsm_segment) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_dsm_segment_map_length"]
    pub fn dsm_segment_map_length(seg: *mut dsm_segment) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_dsm_segment_handle"]
    pub fn dsm_segment_handle(seg: *mut dsm_segment) -> dsm_handle;
}
pub type on_dsm_detach_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut dsm_segment, arg: Datum)>;
extern "C" {
    #[link_name = "\u{1}_on_dsm_detach"]
    pub fn on_dsm_detach(seg: *mut dsm_segment, function: on_dsm_detach_callback, arg: Datum);
}
extern "C" {
    #[link_name = "\u{1}_cancel_on_dsm_detach"]
    pub fn cancel_on_dsm_detach(
        seg: *mut dsm_segment,
        function: on_dsm_detach_callback,
        arg: Datum,
    );
}
extern "C" {
    #[link_name = "\u{1}_reset_on_dsm_detach"]
    pub fn reset_on_dsm_detach();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_area {
    _unused: [u8; 0],
}
pub type dsa_pointer = uint64;
pub type dsa_pointer_atomic = pg_atomic_uint64;
pub type dsa_handle = dsm_handle;
extern "C" {
    #[link_name = "\u{1}_dsa_startup"]
    pub fn dsa_startup();
}
extern "C" {
    #[link_name = "\u{1}_dsa_create"]
    pub fn dsa_create(tranche_id: ::std::os::raw::c_int) -> *mut dsa_area;
}
extern "C" {
    #[link_name = "\u{1}_dsa_create_in_place"]
    pub fn dsa_create_in_place(
        place: *mut ::std::os::raw::c_void,
        size: usize,
        tranche_id: ::std::os::raw::c_int,
        segment: *mut dsm_segment,
    ) -> *mut dsa_area;
}
extern "C" {
    #[link_name = "\u{1}_dsa_attach"]
    pub fn dsa_attach(handle: dsa_handle) -> *mut dsa_area;
}
extern "C" {
    #[link_name = "\u{1}_dsa_attach_in_place"]
    pub fn dsa_attach_in_place(
        place: *mut ::std::os::raw::c_void,
        segment: *mut dsm_segment,
    ) -> *mut dsa_area;
}
extern "C" {
    #[link_name = "\u{1}_dsa_release_in_place"]
    pub fn dsa_release_in_place(place: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_dsa_on_dsm_detach_release_in_place"]
    pub fn dsa_on_dsm_detach_release_in_place(arg1: *mut dsm_segment, arg2: Datum);
}
extern "C" {
    #[link_name = "\u{1}_dsa_on_shmem_exit_release_in_place"]
    pub fn dsa_on_shmem_exit_release_in_place(arg1: ::std::os::raw::c_int, arg2: Datum);
}
extern "C" {
    #[link_name = "\u{1}_dsa_pin_mapping"]
    pub fn dsa_pin_mapping(area: *mut dsa_area);
}
extern "C" {
    #[link_name = "\u{1}_dsa_detach"]
    pub fn dsa_detach(area: *mut dsa_area);
}
extern "C" {
    #[link_name = "\u{1}_dsa_pin"]
    pub fn dsa_pin(area: *mut dsa_area);
}
extern "C" {
    #[link_name = "\u{1}_dsa_unpin"]
    pub fn dsa_unpin(area: *mut dsa_area);
}
extern "C" {
    #[link_name = "\u{1}_dsa_set_size_limit"]
    pub fn dsa_set_size_limit(area: *mut dsa_area, limit: usize);
}
extern "C" {
    #[link_name = "\u{1}_dsa_minimum_size"]
    pub fn dsa_minimum_size() -> usize;
}
extern "C" {
    #[link_name = "\u{1}_dsa_get_handle"]
    pub fn dsa_get_handle(area: *mut dsa_area) -> dsa_handle;
}
extern "C" {
    #[link_name = "\u{1}_dsa_allocate_extended"]
    pub fn dsa_allocate_extended(
        area: *mut dsa_area,
        size: usize,
        flags: ::std::os::raw::c_int,
    ) -> dsa_pointer;
}
extern "C" {
    #[link_name = "\u{1}_dsa_free"]
    pub fn dsa_free(area: *mut dsa_area, dp: dsa_pointer);
}
extern "C" {
    #[link_name = "\u{1}_dsa_get_address"]
    pub fn dsa_get_address(area: *mut dsa_area, dp: dsa_pointer) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_dsa_trim"]
    pub fn dsa_trim(area: *mut dsa_area);
}
extern "C" {
    #[link_name = "\u{1}_dsa_dump"]
    pub fn dsa_dump(area: *mut dsa_area);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIDBitmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBMIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBMSharedIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct TBMIterateResult {
    pub blockno: BlockNumber,
    pub ntuples: ::std::os::raw::c_int,
    pub recheck: bool,
    pub offsets: __IncompleteArrayField<OffsetNumber>,
}
#[test]
fn bindgen_test_layout_TBMIterateResult() {
    assert_eq!(
        ::std::mem::size_of::<TBMIterateResult>(),
        12usize,
        concat!("Size of: ", stringify!(TBMIterateResult))
    );
    assert_eq!(
        ::std::mem::align_of::<TBMIterateResult>(),
        4usize,
        concat!("Alignment of ", stringify!(TBMIterateResult))
    );
}
extern "C" {
    #[link_name = "\u{1}_tbm_create"]
    pub fn tbm_create(maxbytes: ::std::os::raw::c_long, dsa: *mut dsa_area) -> *mut TIDBitmap;
}
extern "C" {
    #[link_name = "\u{1}_tbm_free"]
    pub fn tbm_free(tbm: *mut TIDBitmap);
}
extern "C" {
    #[link_name = "\u{1}_tbm_free_shared_area"]
    pub fn tbm_free_shared_area(dsa: *mut dsa_area, dp: dsa_pointer);
}
extern "C" {
    #[link_name = "\u{1}_tbm_add_tuples"]
    pub fn tbm_add_tuples(
        tbm: *mut TIDBitmap,
        tids: ItemPointer,
        ntids: ::std::os::raw::c_int,
        recheck: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_tbm_add_page"]
    pub fn tbm_add_page(tbm: *mut TIDBitmap, pageno: BlockNumber);
}
extern "C" {
    #[link_name = "\u{1}_tbm_union"]
    pub fn tbm_union(a: *mut TIDBitmap, b: *const TIDBitmap);
}
extern "C" {
    #[link_name = "\u{1}_tbm_intersect"]
    pub fn tbm_intersect(a: *mut TIDBitmap, b: *const TIDBitmap);
}
extern "C" {
    #[link_name = "\u{1}_tbm_is_empty"]
    pub fn tbm_is_empty(tbm: *const TIDBitmap) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_tbm_begin_iterate"]
    pub fn tbm_begin_iterate(tbm: *mut TIDBitmap) -> *mut TBMIterator;
}
extern "C" {
    #[link_name = "\u{1}_tbm_prepare_shared_iterate"]
    pub fn tbm_prepare_shared_iterate(tbm: *mut TIDBitmap) -> dsa_pointer;
}
extern "C" {
    #[link_name = "\u{1}_tbm_iterate"]
    pub fn tbm_iterate(iterator: *mut TBMIterator) -> *mut TBMIterateResult;
}
extern "C" {
    #[link_name = "\u{1}_tbm_shared_iterate"]
    pub fn tbm_shared_iterate(iterator: *mut TBMSharedIterator) -> *mut TBMIterateResult;
}
extern "C" {
    #[link_name = "\u{1}_tbm_end_iterate"]
    pub fn tbm_end_iterate(iterator: *mut TBMIterator);
}
extern "C" {
    #[link_name = "\u{1}_tbm_end_shared_iterate"]
    pub fn tbm_end_shared_iterate(iterator: *mut TBMSharedIterator);
}
extern "C" {
    #[link_name = "\u{1}_tbm_attach_shared_iterate"]
    pub fn tbm_attach_shared_iterate(dsa: *mut dsa_area, dp: dsa_pointer)
        -> *mut TBMSharedIterator;
}
extern "C" {
    #[link_name = "\u{1}_tbm_calculate_entries"]
    pub fn tbm_calculate_entries(maxbytes: f64) -> ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexBuildResult {
    pub heap_tuples: f64,
    pub index_tuples: f64,
}
#[test]
fn bindgen_test_layout_IndexBuildResult() {
    assert_eq!(
        ::std::mem::size_of::<IndexBuildResult>(),
        16usize,
        concat!("Size of: ", stringify!(IndexBuildResult))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexBuildResult>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexBuildResult))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexBuildResult>())).heap_tuples as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexBuildResult),
            "::",
            stringify!(heap_tuples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexBuildResult>())).index_tuples as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexBuildResult),
            "::",
            stringify!(index_tuples)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexVacuumInfo {
    pub index: Relation,
    pub analyze_only: bool,
    pub estimated_count: bool,
    pub message_level: ::std::os::raw::c_int,
    pub num_heap_tuples: f64,
    pub strategy: BufferAccessStrategy,
}
#[test]
fn bindgen_test_layout_IndexVacuumInfo() {
    assert_eq!(
        ::std::mem::size_of::<IndexVacuumInfo>(),
        32usize,
        concat!("Size of: ", stringify!(IndexVacuumInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexVacuumInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexVacuumInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexVacuumInfo>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexVacuumInfo),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexVacuumInfo>())).analyze_only as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexVacuumInfo),
            "::",
            stringify!(analyze_only)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexVacuumInfo>())).estimated_count as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexVacuumInfo),
            "::",
            stringify!(estimated_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexVacuumInfo>())).message_level as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexVacuumInfo),
            "::",
            stringify!(message_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexVacuumInfo>())).num_heap_tuples as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexVacuumInfo),
            "::",
            stringify!(num_heap_tuples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexVacuumInfo>())).strategy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexVacuumInfo),
            "::",
            stringify!(strategy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexBulkDeleteResult {
    pub num_pages: BlockNumber,
    pub pages_removed: BlockNumber,
    pub estimated_count: bool,
    pub num_index_tuples: f64,
    pub tuples_removed: f64,
    pub pages_deleted: BlockNumber,
    pub pages_free: BlockNumber,
}
#[test]
fn bindgen_test_layout_IndexBulkDeleteResult() {
    assert_eq!(
        ::std::mem::size_of::<IndexBulkDeleteResult>(),
        40usize,
        concat!("Size of: ", stringify!(IndexBulkDeleteResult))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexBulkDeleteResult>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexBulkDeleteResult))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexBulkDeleteResult>())).num_pages as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexBulkDeleteResult),
            "::",
            stringify!(num_pages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexBulkDeleteResult>())).pages_removed as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexBulkDeleteResult),
            "::",
            stringify!(pages_removed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexBulkDeleteResult>())).estimated_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexBulkDeleteResult),
            "::",
            stringify!(estimated_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexBulkDeleteResult>())).num_index_tuples as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexBulkDeleteResult),
            "::",
            stringify!(num_index_tuples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexBulkDeleteResult>())).tuples_removed as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexBulkDeleteResult),
            "::",
            stringify!(tuples_removed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexBulkDeleteResult>())).pages_deleted as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexBulkDeleteResult),
            "::",
            stringify!(pages_deleted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexBulkDeleteResult>())).pages_free as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexBulkDeleteResult),
            "::",
            stringify!(pages_free)
        )
    );
}
pub type IndexBulkDeleteCallback = ::std::option::Option<
    unsafe extern "C" fn(itemptr: ItemPointer, state: *mut ::std::os::raw::c_void) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScanDescData {
    _unused: [u8; 0],
}
pub type IndexScanDesc = *mut IndexScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysScanDescData {
    _unused: [u8; 0],
}
pub type SysScanDesc = *mut SysScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelIndexScanDescData {
    _unused: [u8; 0],
}
pub type ParallelIndexScanDesc = *mut ParallelIndexScanDescData;
pub const IndexUniqueCheck_UNIQUE_CHECK_NO: IndexUniqueCheck = 0;
pub const IndexUniqueCheck_UNIQUE_CHECK_YES: IndexUniqueCheck = 1;
pub const IndexUniqueCheck_UNIQUE_CHECK_PARTIAL: IndexUniqueCheck = 2;
pub const IndexUniqueCheck_UNIQUE_CHECK_EXISTING: IndexUniqueCheck = 3;
pub type IndexUniqueCheck = u32;
extern "C" {
    #[link_name = "\u{1}_index_open"]
    pub fn index_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    #[link_name = "\u{1}_index_close"]
    pub fn index_close(relation: Relation, lockmode: LOCKMODE);
}
extern "C" {
    #[link_name = "\u{1}_index_insert"]
    pub fn index_insert(
        indexRelation: Relation,
        values: *mut Datum,
        isnull: *mut bool,
        heap_t_ctid: ItemPointer,
        heapRelation: Relation,
        checkUnique: IndexUniqueCheck,
        indexInfo: *mut IndexInfo,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_index_beginscan"]
    pub fn index_beginscan(
        heapRelation: Relation,
        indexRelation: Relation,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
    ) -> IndexScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_index_beginscan_bitmap"]
    pub fn index_beginscan_bitmap(
        indexRelation: Relation,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
    ) -> IndexScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_index_rescan"]
    pub fn index_rescan(
        scan: IndexScanDesc,
        keys: ScanKey,
        nkeys: ::std::os::raw::c_int,
        orderbys: ScanKey,
        norderbys: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_index_endscan"]
    pub fn index_endscan(scan: IndexScanDesc);
}
extern "C" {
    #[link_name = "\u{1}_index_markpos"]
    pub fn index_markpos(scan: IndexScanDesc);
}
extern "C" {
    #[link_name = "\u{1}_index_restrpos"]
    pub fn index_restrpos(scan: IndexScanDesc);
}
extern "C" {
    #[link_name = "\u{1}_index_parallelscan_estimate"]
    pub fn index_parallelscan_estimate(indexrel: Relation, snapshot: Snapshot) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_index_parallelscan_initialize"]
    pub fn index_parallelscan_initialize(
        heaprel: Relation,
        indexrel: Relation,
        snapshot: Snapshot,
        target: ParallelIndexScanDesc,
    );
}
extern "C" {
    #[link_name = "\u{1}_index_parallelrescan"]
    pub fn index_parallelrescan(scan: IndexScanDesc);
}
extern "C" {
    #[link_name = "\u{1}_index_beginscan_parallel"]
    pub fn index_beginscan_parallel(
        heaprel: Relation,
        indexrel: Relation,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
        pscan: ParallelIndexScanDesc,
    ) -> IndexScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_index_getnext_tid"]
    pub fn index_getnext_tid(scan: IndexScanDesc, direction: ScanDirection) -> ItemPointer;
}
extern "C" {
    #[link_name = "\u{1}_index_fetch_heap"]
    pub fn index_fetch_heap(scan: IndexScanDesc) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_index_getnext"]
    pub fn index_getnext(scan: IndexScanDesc, direction: ScanDirection) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_index_getbitmap"]
    pub fn index_getbitmap(scan: IndexScanDesc, bitmap: *mut TIDBitmap) -> int64;
}
extern "C" {
    #[link_name = "\u{1}_index_bulk_delete"]
    pub fn index_bulk_delete(
        info: *mut IndexVacuumInfo,
        stats: *mut IndexBulkDeleteResult,
        callback: IndexBulkDeleteCallback,
        callback_state: *mut ::std::os::raw::c_void,
    ) -> *mut IndexBulkDeleteResult;
}
extern "C" {
    #[link_name = "\u{1}_index_vacuum_cleanup"]
    pub fn index_vacuum_cleanup(
        info: *mut IndexVacuumInfo,
        stats: *mut IndexBulkDeleteResult,
    ) -> *mut IndexBulkDeleteResult;
}
extern "C" {
    #[link_name = "\u{1}_index_can_return"]
    pub fn index_can_return(indexRelation: Relation, attno: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_index_getprocid"]
    pub fn index_getprocid(irel: Relation, attnum: AttrNumber, procnum: uint16) -> RegProcedure;
}
extern "C" {
    #[link_name = "\u{1}_index_getprocinfo"]
    pub fn index_getprocinfo(irel: Relation, attnum: AttrNumber, procnum: uint16) -> *mut FmgrInfo;
}
extern "C" {
    #[link_name = "\u{1}_RelationGetIndexScan"]
    pub fn RelationGetIndexScan(
        indexRelation: Relation,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
    ) -> IndexScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_IndexScanEnd"]
    pub fn IndexScanEnd(scan: IndexScanDesc);
}
extern "C" {
    #[link_name = "\u{1}_BuildIndexValueDescription"]
    pub fn BuildIndexValueDescription(
        indexRelation: Relation,
        values: *mut Datum,
        isnull: *mut bool,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_systable_beginscan"]
    pub fn systable_beginscan(
        heapRelation: Relation,
        indexId: Oid,
        indexOK: bool,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
        key: ScanKey,
    ) -> SysScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_systable_getnext"]
    pub fn systable_getnext(sysscan: SysScanDesc) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_systable_recheck_tuple"]
    pub fn systable_recheck_tuple(sysscan: SysScanDesc, tup: HeapTuple) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_systable_endscan"]
    pub fn systable_endscan(sysscan: SysScanDesc);
}
extern "C" {
    #[link_name = "\u{1}_systable_beginscan_ordered"]
    pub fn systable_beginscan_ordered(
        heapRelation: Relation,
        indexRelation: Relation,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
        key: ScanKey,
    ) -> SysScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_systable_getnext_ordered"]
    pub fn systable_getnext_ordered(sysscan: SysScanDesc, direction: ScanDirection) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_systable_endscan_ordered"]
    pub fn systable_endscan_ordered(sysscan: SysScanDesc);
}
pub type Item = Pointer;
pub type Page = Pointer;
pub type LocationIndex = uint16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PageXLogRecPtr {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
#[test]
fn bindgen_test_layout_PageXLogRecPtr() {
    assert_eq!(
        ::std::mem::size_of::<PageXLogRecPtr>(),
        8usize,
        concat!("Size of: ", stringify!(PageXLogRecPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<PageXLogRecPtr>(),
        4usize,
        concat!("Alignment of ", stringify!(PageXLogRecPtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PageXLogRecPtr>())).xlogid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PageXLogRecPtr),
            "::",
            stringify!(xlogid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PageXLogRecPtr>())).xrecoff as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PageXLogRecPtr),
            "::",
            stringify!(xrecoff)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: __IncompleteArrayField<ItemIdData>,
}
#[test]
fn bindgen_test_layout_PageHeaderData() {
    assert_eq!(
        ::std::mem::size_of::<PageHeaderData>(),
        24usize,
        concat!("Size of: ", stringify!(PageHeaderData))
    );
    assert_eq!(
        ::std::mem::align_of::<PageHeaderData>(),
        4usize,
        concat!("Alignment of ", stringify!(PageHeaderData))
    );
}
pub type PageHeader = *mut PageHeaderData;
extern "C" {
    #[link_name = "\u{1}_PageInit"]
    pub fn PageInit(page: Page, pageSize: Size, specialSize: Size);
}
extern "C" {
    #[link_name = "\u{1}_PageIsVerified"]
    pub fn PageIsVerified(page: Page, blkno: BlockNumber) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_PageAddItemExtended"]
    pub fn PageAddItemExtended(
        page: Page,
        item: Item,
        size: Size,
        offsetNumber: OffsetNumber,
        flags: ::std::os::raw::c_int,
    ) -> OffsetNumber;
}
extern "C" {
    #[link_name = "\u{1}_PageGetTempPage"]
    pub fn PageGetTempPage(page: Page) -> Page;
}
extern "C" {
    #[link_name = "\u{1}_PageGetTempPageCopy"]
    pub fn PageGetTempPageCopy(page: Page) -> Page;
}
extern "C" {
    #[link_name = "\u{1}_PageGetTempPageCopySpecial"]
    pub fn PageGetTempPageCopySpecial(page: Page) -> Page;
}
extern "C" {
    #[link_name = "\u{1}_PageRestoreTempPage"]
    pub fn PageRestoreTempPage(tempPage: Page, oldPage: Page);
}
extern "C" {
    #[link_name = "\u{1}_PageRepairFragmentation"]
    pub fn PageRepairFragmentation(page: Page);
}
extern "C" {
    #[link_name = "\u{1}_PageGetFreeSpace"]
    pub fn PageGetFreeSpace(page: Page) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_PageGetFreeSpaceForMultipleTuples"]
    pub fn PageGetFreeSpaceForMultipleTuples(page: Page, ntups: ::std::os::raw::c_int) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_PageGetExactFreeSpace"]
    pub fn PageGetExactFreeSpace(page: Page) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_PageGetHeapFreeSpace"]
    pub fn PageGetHeapFreeSpace(page: Page) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_PageIndexTupleDelete"]
    pub fn PageIndexTupleDelete(page: Page, offset: OffsetNumber);
}
extern "C" {
    #[link_name = "\u{1}_PageIndexMultiDelete"]
    pub fn PageIndexMultiDelete(
        page: Page,
        itemnos: *mut OffsetNumber,
        nitems: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_PageIndexTupleDeleteNoCompact"]
    pub fn PageIndexTupleDeleteNoCompact(page: Page, offset: OffsetNumber);
}
extern "C" {
    #[link_name = "\u{1}_PageIndexTupleOverwrite"]
    pub fn PageIndexTupleOverwrite(
        page: Page,
        offnum: OffsetNumber,
        newtup: Item,
        newsize: Size,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_PageSetChecksumCopy"]
    pub fn PageSetChecksumCopy(page: Page, blkno: BlockNumber) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_PageSetChecksumInplace"]
    pub fn PageSetChecksumInplace(page: Page, blkno: BlockNumber);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BulkInsertStateData {
    _unused: [u8; 0],
}
pub type BulkInsertState = *mut BulkInsertStateData;
pub const LockTupleMode_LockTupleKeyShare: LockTupleMode = 0;
pub const LockTupleMode_LockTupleShare: LockTupleMode = 1;
pub const LockTupleMode_LockTupleNoKeyExclusive: LockTupleMode = 2;
pub const LockTupleMode_LockTupleExclusive: LockTupleMode = 3;
pub type LockTupleMode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapUpdateFailureData {
    pub ctid: ItemPointerData,
    pub xmax: TransactionId,
    pub cmax: CommandId,
}
#[test]
fn bindgen_test_layout_HeapUpdateFailureData() {
    assert_eq!(
        ::std::mem::size_of::<HeapUpdateFailureData>(),
        16usize,
        concat!("Size of: ", stringify!(HeapUpdateFailureData))
    );
    assert_eq!(
        ::std::mem::align_of::<HeapUpdateFailureData>(),
        4usize,
        concat!("Alignment of ", stringify!(HeapUpdateFailureData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapUpdateFailureData>())).ctid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapUpdateFailureData),
            "::",
            stringify!(ctid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapUpdateFailureData>())).xmax as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapUpdateFailureData),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HeapUpdateFailureData>())).cmax as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HeapUpdateFailureData),
            "::",
            stringify!(cmax)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_relation_open"]
    pub fn relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    #[link_name = "\u{1}_try_relation_open"]
    pub fn try_relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    #[link_name = "\u{1}_relation_openrv"]
    pub fn relation_openrv(relation: *const RangeVar, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    #[link_name = "\u{1}_relation_openrv_extended"]
    pub fn relation_openrv_extended(
        relation: *const RangeVar,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> Relation;
}
extern "C" {
    #[link_name = "\u{1}_relation_close"]
    pub fn relation_close(relation: Relation, lockmode: LOCKMODE);
}
extern "C" {
    #[link_name = "\u{1}_heap_open"]
    pub fn heap_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    #[link_name = "\u{1}_heap_openrv"]
    pub fn heap_openrv(relation: *const RangeVar, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    #[link_name = "\u{1}_heap_openrv_extended"]
    pub fn heap_openrv_extended(
        relation: *const RangeVar,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> Relation;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapScanDescData {
    _unused: [u8; 0],
}
pub type HeapScanDesc = *mut HeapScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelHeapScanDescData {
    _unused: [u8; 0],
}
pub type ParallelHeapScanDesc = *mut ParallelHeapScanDescData;
extern "C" {
    #[link_name = "\u{1}_heap_beginscan"]
    pub fn heap_beginscan(
        relation: Relation,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
        key: ScanKey,
    ) -> HeapScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_heap_beginscan_catalog"]
    pub fn heap_beginscan_catalog(
        relation: Relation,
        nkeys: ::std::os::raw::c_int,
        key: ScanKey,
    ) -> HeapScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_heap_beginscan_strat"]
    pub fn heap_beginscan_strat(
        relation: Relation,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
        key: ScanKey,
        allow_strat: bool,
        allow_sync: bool,
    ) -> HeapScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_heap_beginscan_bm"]
    pub fn heap_beginscan_bm(
        relation: Relation,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
        key: ScanKey,
    ) -> HeapScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_heap_beginscan_sampling"]
    pub fn heap_beginscan_sampling(
        relation: Relation,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
        key: ScanKey,
        allow_strat: bool,
        allow_sync: bool,
        allow_pagemode: bool,
    ) -> HeapScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_heap_setscanlimits"]
    pub fn heap_setscanlimits(scan: HeapScanDesc, startBlk: BlockNumber, endBlk: BlockNumber);
}
extern "C" {
    #[link_name = "\u{1}_heapgetpage"]
    pub fn heapgetpage(scan: HeapScanDesc, page: BlockNumber);
}
extern "C" {
    #[link_name = "\u{1}_heap_rescan"]
    pub fn heap_rescan(scan: HeapScanDesc, key: ScanKey);
}
extern "C" {
    #[link_name = "\u{1}_heap_rescan_set_params"]
    pub fn heap_rescan_set_params(
        scan: HeapScanDesc,
        key: ScanKey,
        allow_strat: bool,
        allow_sync: bool,
        allow_pagemode: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_heap_endscan"]
    pub fn heap_endscan(scan: HeapScanDesc);
}
extern "C" {
    #[link_name = "\u{1}_heap_getnext"]
    pub fn heap_getnext(scan: HeapScanDesc, direction: ScanDirection) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_heap_parallelscan_estimate"]
    pub fn heap_parallelscan_estimate(snapshot: Snapshot) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_heap_parallelscan_initialize"]
    pub fn heap_parallelscan_initialize(
        target: ParallelHeapScanDesc,
        relation: Relation,
        snapshot: Snapshot,
    );
}
extern "C" {
    #[link_name = "\u{1}_heap_parallelscan_reinitialize"]
    pub fn heap_parallelscan_reinitialize(parallel_scan: ParallelHeapScanDesc);
}
extern "C" {
    #[link_name = "\u{1}_heap_beginscan_parallel"]
    pub fn heap_beginscan_parallel(arg1: Relation, arg2: ParallelHeapScanDesc) -> HeapScanDesc;
}
extern "C" {
    #[link_name = "\u{1}_heap_fetch"]
    pub fn heap_fetch(
        relation: Relation,
        snapshot: Snapshot,
        tuple: HeapTuple,
        userbuf: *mut Buffer,
        keep_buf: bool,
        stats_relation: Relation,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_heap_hot_search_buffer"]
    pub fn heap_hot_search_buffer(
        tid: ItemPointer,
        relation: Relation,
        buffer: Buffer,
        snapshot: Snapshot,
        heapTuple: HeapTuple,
        all_dead: *mut bool,
        first_call: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_heap_hot_search"]
    pub fn heap_hot_search(
        tid: ItemPointer,
        relation: Relation,
        snapshot: Snapshot,
        all_dead: *mut bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_heap_get_latest_tid"]
    pub fn heap_get_latest_tid(relation: Relation, snapshot: Snapshot, tid: ItemPointer);
}
extern "C" {
    #[link_name = "\u{1}_setLastTid"]
    pub fn setLastTid(tid: ItemPointer);
}
extern "C" {
    #[link_name = "\u{1}_GetBulkInsertState"]
    pub fn GetBulkInsertState() -> BulkInsertState;
}
extern "C" {
    #[link_name = "\u{1}_FreeBulkInsertState"]
    pub fn FreeBulkInsertState(arg1: BulkInsertState);
}
extern "C" {
    #[link_name = "\u{1}_ReleaseBulkInsertStatePin"]
    pub fn ReleaseBulkInsertStatePin(bistate: BulkInsertState);
}
extern "C" {
    #[link_name = "\u{1}_heap_insert"]
    pub fn heap_insert(
        relation: Relation,
        tup: HeapTuple,
        cid: CommandId,
        options: ::std::os::raw::c_int,
        bistate: BulkInsertState,
    ) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_heap_multi_insert"]
    pub fn heap_multi_insert(
        relation: Relation,
        tuples: *mut HeapTuple,
        ntuples: ::std::os::raw::c_int,
        cid: CommandId,
        options: ::std::os::raw::c_int,
        bistate: BulkInsertState,
    );
}
extern "C" {
    #[link_name = "\u{1}_heap_delete"]
    pub fn heap_delete(
        relation: Relation,
        tid: ItemPointer,
        cid: CommandId,
        crosscheck: Snapshot,
        wait: bool,
        hufd: *mut HeapUpdateFailureData,
        changingPart: bool,
    ) -> HTSU_Result;
}
extern "C" {
    #[link_name = "\u{1}_heap_finish_speculative"]
    pub fn heap_finish_speculative(relation: Relation, tuple: HeapTuple);
}
extern "C" {
    #[link_name = "\u{1}_heap_abort_speculative"]
    pub fn heap_abort_speculative(relation: Relation, tuple: HeapTuple);
}
extern "C" {
    #[link_name = "\u{1}_heap_update"]
    pub fn heap_update(
        relation: Relation,
        otid: ItemPointer,
        newtup: HeapTuple,
        cid: CommandId,
        crosscheck: Snapshot,
        wait: bool,
        hufd: *mut HeapUpdateFailureData,
        lockmode: *mut LockTupleMode,
    ) -> HTSU_Result;
}
extern "C" {
    #[link_name = "\u{1}_heap_lock_tuple"]
    pub fn heap_lock_tuple(
        relation: Relation,
        tuple: HeapTuple,
        cid: CommandId,
        mode: LockTupleMode,
        wait_policy: LockWaitPolicy,
        follow_update: bool,
        buffer: *mut Buffer,
        hufd: *mut HeapUpdateFailureData,
    ) -> HTSU_Result;
}
extern "C" {
    #[link_name = "\u{1}_heap_inplace_update"]
    pub fn heap_inplace_update(relation: Relation, tuple: HeapTuple);
}
extern "C" {
    #[link_name = "\u{1}_heap_freeze_tuple"]
    pub fn heap_freeze_tuple(
        tuple: HeapTupleHeader,
        relfrozenxid: TransactionId,
        relminmxid: TransactionId,
        cutoff_xid: TransactionId,
        cutoff_multi: TransactionId,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_heap_tuple_needs_freeze"]
    pub fn heap_tuple_needs_freeze(
        tuple: HeapTupleHeader,
        cutoff_xid: TransactionId,
        cutoff_multi: MultiXactId,
        buf: Buffer,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_heap_tuple_needs_eventual_freeze"]
    pub fn heap_tuple_needs_eventual_freeze(tuple: HeapTupleHeader) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_simple_heap_insert"]
    pub fn simple_heap_insert(relation: Relation, tup: HeapTuple) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_simple_heap_delete"]
    pub fn simple_heap_delete(relation: Relation, tid: ItemPointer);
}
extern "C" {
    #[link_name = "\u{1}_simple_heap_update"]
    pub fn simple_heap_update(relation: Relation, otid: ItemPointer, tup: HeapTuple);
}
extern "C" {
    #[link_name = "\u{1}_heap_sync"]
    pub fn heap_sync(relation: Relation);
}
extern "C" {
    #[link_name = "\u{1}_heap_update_snapshot"]
    pub fn heap_update_snapshot(scan: HeapScanDesc, snapshot: Snapshot);
}
extern "C" {
    #[link_name = "\u{1}_heap_page_prune_opt"]
    pub fn heap_page_prune_opt(relation: Relation, buffer: Buffer);
}
extern "C" {
    #[link_name = "\u{1}_heap_page_prune"]
    pub fn heap_page_prune(
        relation: Relation,
        buffer: Buffer,
        OldestXmin: TransactionId,
        report_stats: bool,
        latestRemovedXid: *mut TransactionId,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_heap_page_prune_execute"]
    pub fn heap_page_prune_execute(
        buffer: Buffer,
        redirected: *mut OffsetNumber,
        nredirected: ::std::os::raw::c_int,
        nowdead: *mut OffsetNumber,
        ndead: ::std::os::raw::c_int,
        nowunused: *mut OffsetNumber,
        nunused: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_heap_get_root_tuples"]
    pub fn heap_get_root_tuples(page: Page, root_offsets: *mut OffsetNumber);
}
extern "C" {
    #[link_name = "\u{1}_ss_report_location"]
    pub fn ss_report_location(rel: Relation, location: BlockNumber);
}
extern "C" {
    #[link_name = "\u{1}_ss_get_location"]
    pub fn ss_get_location(rel: Relation, relnblocks: BlockNumber) -> BlockNumber;
}
extern "C" {
    #[link_name = "\u{1}_SyncScanShmemInit"]
    pub fn SyncScanShmemInit();
}
extern "C" {
    #[link_name = "\u{1}_SyncScanShmemSize"]
    pub fn SyncScanShmemSize() -> Size;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleConversionMap {
    pub indesc: TupleDesc,
    pub outdesc: TupleDesc,
    pub attrMap: *mut AttrNumber,
    pub invalues: *mut Datum,
    pub inisnull: *mut bool,
    pub outvalues: *mut Datum,
    pub outisnull: *mut bool,
}
#[test]
fn bindgen_test_layout_TupleConversionMap() {
    assert_eq!(
        ::std::mem::size_of::<TupleConversionMap>(),
        56usize,
        concat!("Size of: ", stringify!(TupleConversionMap))
    );
    assert_eq!(
        ::std::mem::align_of::<TupleConversionMap>(),
        8usize,
        concat!("Alignment of ", stringify!(TupleConversionMap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleConversionMap>())).indesc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleConversionMap),
            "::",
            stringify!(indesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleConversionMap>())).outdesc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleConversionMap),
            "::",
            stringify!(outdesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleConversionMap>())).attrMap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleConversionMap),
            "::",
            stringify!(attrMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleConversionMap>())).invalues as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleConversionMap),
            "::",
            stringify!(invalues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleConversionMap>())).inisnull as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleConversionMap),
            "::",
            stringify!(inisnull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleConversionMap>())).outvalues as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleConversionMap),
            "::",
            stringify!(outvalues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleConversionMap>())).outisnull as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleConversionMap),
            "::",
            stringify!(outisnull)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_convert_tuples_by_position"]
    pub fn convert_tuples_by_position(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        msg: *const ::std::os::raw::c_char,
    ) -> *mut TupleConversionMap;
}
extern "C" {
    #[link_name = "\u{1}_convert_tuples_by_name"]
    pub fn convert_tuples_by_name(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        msg: *const ::std::os::raw::c_char,
    ) -> *mut TupleConversionMap;
}
extern "C" {
    #[link_name = "\u{1}_convert_tuples_by_name_map"]
    pub fn convert_tuples_by_name_map(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        msg: *const ::std::os::raw::c_char,
    ) -> *mut AttrNumber;
}
extern "C" {
    #[link_name = "\u{1}_do_convert_tuple"]
    pub fn do_convert_tuple(tuple: HeapTuple, map: *mut TupleConversionMap) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_free_conversion_map"]
    pub fn free_conversion_map(map: *mut TupleConversionMap);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_getdate_err"]
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_asctime"]
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_clock"]
    pub fn clock() -> clock_t;
}
extern "C" {
    #[link_name = "\u{1}_ctime"]
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_difftime"]
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_getdate"]
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_gmtime"]
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_localtime"]
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_mktime"]
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_strftime"]
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_strptime"]
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_time"]
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_tzset"]
    pub fn tzset();
}
extern "C" {
    #[link_name = "\u{1}_asctime_r"]
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ctime_r"]
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_gmtime_r"]
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_localtime_r"]
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_posix2time"]
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_tzsetwall"]
    pub fn tzsetwall();
}
extern "C" {
    #[link_name = "\u{1}_time2posix"]
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_timelocal"]
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_timegm"]
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_nanosleep"]
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = u32;
extern "C" {
    #[link_name = "\u{1}_clock_getres"]
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_clock_gettime"]
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_clock_gettime_nsec_np"]
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    #[link_name = "\u{1}_clock_settime"]
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
pub type instr_time = timespec;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferUsage {
    pub shared_blks_hit: ::std::os::raw::c_long,
    pub shared_blks_read: ::std::os::raw::c_long,
    pub shared_blks_dirtied: ::std::os::raw::c_long,
    pub shared_blks_written: ::std::os::raw::c_long,
    pub local_blks_hit: ::std::os::raw::c_long,
    pub local_blks_read: ::std::os::raw::c_long,
    pub local_blks_dirtied: ::std::os::raw::c_long,
    pub local_blks_written: ::std::os::raw::c_long,
    pub temp_blks_read: ::std::os::raw::c_long,
    pub temp_blks_written: ::std::os::raw::c_long,
    pub blk_read_time: instr_time,
    pub blk_write_time: instr_time,
}
#[test]
fn bindgen_test_layout_BufferUsage() {
    assert_eq!(
        ::std::mem::size_of::<BufferUsage>(),
        112usize,
        concat!("Size of: ", stringify!(BufferUsage))
    );
    assert_eq!(
        ::std::mem::align_of::<BufferUsage>(),
        8usize,
        concat!("Alignment of ", stringify!(BufferUsage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).shared_blks_hit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(shared_blks_hit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).shared_blks_read as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(shared_blks_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).shared_blks_dirtied as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(shared_blks_dirtied)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).shared_blks_written as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(shared_blks_written)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).local_blks_hit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(local_blks_hit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).local_blks_read as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(local_blks_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).local_blks_dirtied as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(local_blks_dirtied)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).local_blks_written as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(local_blks_written)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).temp_blks_read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(temp_blks_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).temp_blks_written as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(temp_blks_written)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).blk_read_time as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(blk_read_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BufferUsage>())).blk_write_time as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BufferUsage),
            "::",
            stringify!(blk_write_time)
        )
    );
}
pub const InstrumentOption_INSTRUMENT_TIMER: InstrumentOption = 1;
pub const InstrumentOption_INSTRUMENT_BUFFERS: InstrumentOption = 2;
pub const InstrumentOption_INSTRUMENT_ROWS: InstrumentOption = 4;
pub const InstrumentOption_INSTRUMENT_ALL: InstrumentOption = 2147483647;
pub type InstrumentOption = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Instrumentation {
    pub need_timer: bool,
    pub need_bufusage: bool,
    pub running: bool,
    pub starttime: instr_time,
    pub counter: instr_time,
    pub firsttuple: f64,
    pub tuplecount: f64,
    pub bufusage_start: BufferUsage,
    pub startup: f64,
    pub total: f64,
    pub ntuples: f64,
    pub ntuples2: f64,
    pub nloops: f64,
    pub nfiltered1: f64,
    pub nfiltered2: f64,
    pub bufusage: BufferUsage,
}
#[test]
fn bindgen_test_layout_Instrumentation() {
    assert_eq!(
        ::std::mem::size_of::<Instrumentation>(),
        336usize,
        concat!("Size of: ", stringify!(Instrumentation))
    );
    assert_eq!(
        ::std::mem::align_of::<Instrumentation>(),
        8usize,
        concat!("Alignment of ", stringify!(Instrumentation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).need_timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(need_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).need_bufusage as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(need_bufusage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).running as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).starttime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(starttime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).counter as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).firsttuple as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(firsttuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).tuplecount as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(tuplecount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).bufusage_start as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(bufusage_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).startup as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(startup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).total as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).ntuples as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(ntuples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).ntuples2 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(ntuples2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).nloops as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(nloops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).nfiltered1 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(nfiltered1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).nfiltered2 as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(nfiltered2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Instrumentation>())).bufusage as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(Instrumentation),
            "::",
            stringify!(bufusage)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct WorkerInstrumentation {
    pub num_workers: ::std::os::raw::c_int,
    pub instrument: __IncompleteArrayField<Instrumentation>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_WorkerInstrumentation() {
    assert_eq!(
        ::std::mem::size_of::<WorkerInstrumentation>(),
        8usize,
        concat!("Size of: ", stringify!(WorkerInstrumentation))
    );
    assert_eq!(
        ::std::mem::align_of::<WorkerInstrumentation>(),
        8usize,
        concat!("Alignment of ", stringify!(WorkerInstrumentation))
    );
}
extern "C" {
    #[link_name = "\u{1}_pgBufferUsage"]
    pub static mut pgBufferUsage: BufferUsage;
}
extern "C" {
    #[link_name = "\u{1}_InstrAlloc"]
    pub fn InstrAlloc(
        n: ::std::os::raw::c_int,
        instrument_options: ::std::os::raw::c_int,
    ) -> *mut Instrumentation;
}
extern "C" {
    #[link_name = "\u{1}_InstrInit"]
    pub fn InstrInit(instr: *mut Instrumentation, instrument_options: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_InstrStartNode"]
    pub fn InstrStartNode(instr: *mut Instrumentation);
}
extern "C" {
    #[link_name = "\u{1}_InstrStopNode"]
    pub fn InstrStopNode(instr: *mut Instrumentation, nTuples: f64);
}
extern "C" {
    #[link_name = "\u{1}_InstrEndLoop"]
    pub fn InstrEndLoop(instr: *mut Instrumentation);
}
extern "C" {
    #[link_name = "\u{1}_InstrAggNode"]
    pub fn InstrAggNode(dst: *mut Instrumentation, add: *mut Instrumentation);
}
extern "C" {
    #[link_name = "\u{1}_InstrStartParallelQuery"]
    pub fn InstrStartParallelQuery();
}
extern "C" {
    #[link_name = "\u{1}_InstrEndParallelQuery"]
    pub fn InstrEndParallelQuery(result: *mut BufferUsage);
}
extern "C" {
    #[link_name = "\u{1}_InstrAccumParallelQuery"]
    pub fn InstrAccumParallelQuery(result: *mut BufferUsage);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamExternData {
    pub value: Datum,
    pub isnull: bool,
    pub pflags: uint16,
    pub ptype: Oid,
}
#[test]
fn bindgen_test_layout_ParamExternData() {
    assert_eq!(
        ::std::mem::size_of::<ParamExternData>(),
        16usize,
        concat!("Size of: ", stringify!(ParamExternData))
    );
    assert_eq!(
        ::std::mem::align_of::<ParamExternData>(),
        8usize,
        concat!("Alignment of ", stringify!(ParamExternData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParamExternData>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ParamExternData),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParamExternData>())).isnull as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ParamExternData),
            "::",
            stringify!(isnull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParamExternData>())).pflags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ParamExternData),
            "::",
            stringify!(pflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParamExternData>())).ptype as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ParamExternData),
            "::",
            stringify!(ptype)
        )
    );
}
pub type ParamListInfo = *mut ParamListInfoData;
pub type ParamFetchHook = ::std::option::Option<
    unsafe extern "C" fn(
        params: ParamListInfo,
        paramid: ::std::os::raw::c_int,
        speculative: bool,
        workspace: *mut ParamExternData,
    ) -> *mut ParamExternData,
>;
pub type ParamCompileHook = ::std::option::Option<
    unsafe extern "C" fn(
        params: ParamListInfo,
        param: *mut Param,
        state: *mut ExprState,
        resv: *mut Datum,
        resnull: *mut bool,
    ),
>;
pub type ParserSetupHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: *mut ParseState, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug)]
pub struct ParamListInfoData {
    pub paramFetch: ParamFetchHook,
    pub paramFetchArg: *mut ::std::os::raw::c_void,
    pub paramCompile: ParamCompileHook,
    pub paramCompileArg: *mut ::std::os::raw::c_void,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::std::os::raw::c_void,
    pub numParams: ::std::os::raw::c_int,
    pub params: __IncompleteArrayField<ParamExternData>,
}
#[test]
fn bindgen_test_layout_ParamListInfoData() {
    assert_eq!(
        ::std::mem::size_of::<ParamListInfoData>(),
        56usize,
        concat!("Size of: ", stringify!(ParamListInfoData))
    );
    assert_eq!(
        ::std::mem::align_of::<ParamListInfoData>(),
        8usize,
        concat!("Alignment of ", stringify!(ParamListInfoData))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamExecData {
    pub execPlan: *mut ::std::os::raw::c_void,
    pub value: Datum,
    pub isnull: bool,
}
#[test]
fn bindgen_test_layout_ParamExecData() {
    assert_eq!(
        ::std::mem::size_of::<ParamExecData>(),
        24usize,
        concat!("Size of: ", stringify!(ParamExecData))
    );
    assert_eq!(
        ::std::mem::align_of::<ParamExecData>(),
        8usize,
        concat!("Alignment of ", stringify!(ParamExecData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParamExecData>())).execPlan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ParamExecData),
            "::",
            stringify!(execPlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParamExecData>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ParamExecData),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ParamExecData>())).isnull as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ParamExecData),
            "::",
            stringify!(isnull)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_copyParamList"]
    pub fn copyParamList(from: ParamListInfo) -> ParamListInfo;
}
extern "C" {
    #[link_name = "\u{1}_EstimateParamListSpace"]
    pub fn EstimateParamListSpace(paramLI: ParamListInfo) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_SerializeParamList"]
    pub fn SerializeParamList(
        paramLI: ParamListInfo,
        start_address: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_RestoreParamList"]
    pub fn RestoreParamList(start_address: *mut *mut ::std::os::raw::c_char) -> ParamListInfo;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannedStmt {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub queryId: uint64,
    pub hasReturning: bool,
    pub hasModifyingCTE: bool,
    pub canSetTag: bool,
    pub transientPlan: bool,
    pub dependsOnRole: bool,
    pub parallelModeNeeded: bool,
    pub jitFlags: ::std::os::raw::c_int,
    pub planTree: *mut Plan,
    pub rtable: *mut List,
    pub resultRelations: *mut List,
    pub nonleafResultRelations: *mut List,
    pub rootResultRelations: *mut List,
    pub subplans: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub paramExecTypes: *mut List,
    pub utilityStmt: *mut Node,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PlannedStmt() {
    assert_eq!(
        ::std::mem::size_of::<PlannedStmt>(),
        136usize,
        concat!("Size of: ", stringify!(PlannedStmt))
    );
    assert_eq!(
        ::std::mem::align_of::<PlannedStmt>(),
        8usize,
        concat!("Alignment of ", stringify!(PlannedStmt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).commandType as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(commandType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).queryId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(queryId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).hasReturning as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(hasReturning)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).hasModifyingCTE as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(hasModifyingCTE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).canSetTag as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(canSetTag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).transientPlan as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(transientPlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).dependsOnRole as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(dependsOnRole)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).parallelModeNeeded as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(parallelModeNeeded)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).jitFlags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(jitFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).planTree as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(planTree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).rtable as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(rtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).resultRelations as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(resultRelations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PlannedStmt>())).nonleafResultRelations as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(nonleafResultRelations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).rootResultRelations as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(rootResultRelations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).subplans as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(subplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).rewindPlanIDs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(rewindPlanIDs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).rowMarks as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(rowMarks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).relationOids as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(relationOids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).invalItems as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(invalItems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).paramExecTypes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(paramExecTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).utilityStmt as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(utilityStmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).stmt_location as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(stmt_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlannedStmt>())).stmt_len as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(PlannedStmt),
            "::",
            stringify!(stmt_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Plan {
    pub type_: NodeTag,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub plan_rows: f64,
    pub plan_width: ::std::os::raw::c_int,
    pub parallel_aware: bool,
    pub parallel_safe: bool,
    pub plan_node_id: ::std::os::raw::c_int,
    pub targetlist: *mut List,
    pub qual: *mut List,
    pub lefttree: *mut Plan,
    pub righttree: *mut Plan,
    pub initPlan: *mut List,
    pub extParam: *mut Bitmapset,
    pub allParam: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_Plan() {
    assert_eq!(
        ::std::mem::size_of::<Plan>(),
        104usize,
        concat!("Size of: ", stringify!(Plan))
    );
    assert_eq!(
        ::std::mem::align_of::<Plan>(),
        8usize,
        concat!("Alignment of ", stringify!(Plan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).startup_cost as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(startup_cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).total_cost as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(total_cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).plan_rows as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(plan_rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).plan_width as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(plan_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).parallel_aware as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(parallel_aware)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).parallel_safe as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(parallel_safe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).plan_node_id as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(plan_node_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).targetlist as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(targetlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).qual as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(qual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).lefttree as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(lefttree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).righttree as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(righttree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).initPlan as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(initPlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).extParam as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(extParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plan>())).allParam as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Plan),
            "::",
            stringify!(allParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Result {
    pub plan: Plan,
    pub resconstantqual: *mut Node,
}
#[test]
fn bindgen_test_layout_Result() {
    assert_eq!(
        ::std::mem::size_of::<Result>(),
        112usize,
        concat!("Size of: ", stringify!(Result))
    );
    assert_eq!(
        ::std::mem::align_of::<Result>(),
        8usize,
        concat!("Alignment of ", stringify!(Result))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Result>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Result),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Result>())).resconstantqual as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Result),
            "::",
            stringify!(resconstantqual)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectSet {
    pub plan: Plan,
}
#[test]
fn bindgen_test_layout_ProjectSet() {
    assert_eq!(
        ::std::mem::size_of::<ProjectSet>(),
        104usize,
        concat!("Size of: ", stringify!(ProjectSet))
    );
    assert_eq!(
        ::std::mem::align_of::<ProjectSet>(),
        8usize,
        concat!("Alignment of ", stringify!(ProjectSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProjectSet>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProjectSet),
            "::",
            stringify!(plan)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModifyTable {
    pub plan: Plan,
    pub operation: CmdType,
    pub canSetTag: bool,
    pub nominalRelation: Index,
    pub partitioned_rels: *mut List,
    pub partColsUpdated: bool,
    pub resultRelations: *mut List,
    pub resultRelIndex: ::std::os::raw::c_int,
    pub rootResultRelIndex: ::std::os::raw::c_int,
    pub plans: *mut List,
    pub withCheckOptionLists: *mut List,
    pub returningLists: *mut List,
    pub fdwPrivLists: *mut List,
    pub fdwDirectModifyPlans: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
    pub onConflictAction: OnConflictAction,
    pub arbiterIndexes: *mut List,
    pub onConflictSet: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelRTI: Index,
    pub exclRelTlist: *mut List,
}
#[test]
fn bindgen_test_layout_ModifyTable() {
    assert_eq!(
        ::std::mem::size_of::<ModifyTable>(),
        248usize,
        concat!("Size of: ", stringify!(ModifyTable))
    );
    assert_eq!(
        ::std::mem::align_of::<ModifyTable>(),
        8usize,
        concat!("Alignment of ", stringify!(ModifyTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).operation as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).canSetTag as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(canSetTag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).nominalRelation as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(nominalRelation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).partitioned_rels as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(partitioned_rels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).partColsUpdated as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(partColsUpdated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).resultRelations as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(resultRelations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).resultRelIndex as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(resultRelIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).rootResultRelIndex as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(rootResultRelIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).plans as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(plans)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ModifyTable>())).withCheckOptionLists as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(withCheckOptionLists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).returningLists as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(returningLists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).fdwPrivLists as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(fdwPrivLists)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ModifyTable>())).fdwDirectModifyPlans as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(fdwDirectModifyPlans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).rowMarks as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(rowMarks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).epqParam as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(epqParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).onConflictAction as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(onConflictAction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).arbiterIndexes as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(arbiterIndexes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).onConflictSet as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(onConflictSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).onConflictWhere as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(onConflictWhere)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).exclRelRTI as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(exclRelRTI)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTable>())).exclRelTlist as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTable),
            "::",
            stringify!(exclRelTlist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Append {
    pub plan: Plan,
    pub appendplans: *mut List,
    pub first_partial_plan: ::std::os::raw::c_int,
    pub partitioned_rels: *mut List,
    pub part_prune_info: *mut PartitionPruneInfo,
}
#[test]
fn bindgen_test_layout_Append() {
    assert_eq!(
        ::std::mem::size_of::<Append>(),
        136usize,
        concat!("Size of: ", stringify!(Append))
    );
    assert_eq!(
        ::std::mem::align_of::<Append>(),
        8usize,
        concat!("Alignment of ", stringify!(Append))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Append>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Append),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Append>())).appendplans as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Append),
            "::",
            stringify!(appendplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Append>())).first_partial_plan as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Append),
            "::",
            stringify!(first_partial_plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Append>())).partitioned_rels as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Append),
            "::",
            stringify!(partitioned_rels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Append>())).part_prune_info as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Append),
            "::",
            stringify!(part_prune_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppend {
    pub plan: Plan,
    pub partitioned_rels: *mut List,
    pub mergeplans: *mut List,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
}
#[test]
fn bindgen_test_layout_MergeAppend() {
    assert_eq!(
        ::std::mem::size_of::<MergeAppend>(),
        160usize,
        concat!("Size of: ", stringify!(MergeAppend))
    );
    assert_eq!(
        ::std::mem::align_of::<MergeAppend>(),
        8usize,
        concat!("Alignment of ", stringify!(MergeAppend))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppend>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppend),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppend>())).partitioned_rels as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppend),
            "::",
            stringify!(partitioned_rels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppend>())).mergeplans as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppend),
            "::",
            stringify!(mergeplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppend>())).numCols as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppend),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppend>())).sortColIdx as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppend),
            "::",
            stringify!(sortColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppend>())).sortOperators as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppend),
            "::",
            stringify!(sortOperators)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppend>())).collations as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppend),
            "::",
            stringify!(collations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppend>())).nullsFirst as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppend),
            "::",
            stringify!(nullsFirst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecursiveUnion {
    pub plan: Plan,
    pub wtParam: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_RecursiveUnion() {
    assert_eq!(
        ::std::mem::size_of::<RecursiveUnion>(),
        136usize,
        concat!("Size of: ", stringify!(RecursiveUnion))
    );
    assert_eq!(
        ::std::mem::align_of::<RecursiveUnion>(),
        8usize,
        concat!("Alignment of ", stringify!(RecursiveUnion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecursiveUnion>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnion),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecursiveUnion>())).wtParam as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnion),
            "::",
            stringify!(wtParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecursiveUnion>())).numCols as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnion),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecursiveUnion>())).dupColIdx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnion),
            "::",
            stringify!(dupColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecursiveUnion>())).dupOperators as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnion),
            "::",
            stringify!(dupOperators)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecursiveUnion>())).numGroups as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnion),
            "::",
            stringify!(numGroups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapAnd {
    pub plan: Plan,
    pub bitmapplans: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapAnd() {
    assert_eq!(
        ::std::mem::size_of::<BitmapAnd>(),
        112usize,
        concat!("Size of: ", stringify!(BitmapAnd))
    );
    assert_eq!(
        ::std::mem::align_of::<BitmapAnd>(),
        8usize,
        concat!("Alignment of ", stringify!(BitmapAnd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapAnd>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapAnd),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapAnd>())).bitmapplans as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapAnd),
            "::",
            stringify!(bitmapplans)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapOr {
    pub plan: Plan,
    pub isshared: bool,
    pub bitmapplans: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapOr() {
    assert_eq!(
        ::std::mem::size_of::<BitmapOr>(),
        120usize,
        concat!("Size of: ", stringify!(BitmapOr))
    );
    assert_eq!(
        ::std::mem::align_of::<BitmapOr>(),
        8usize,
        concat!("Alignment of ", stringify!(BitmapOr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapOr>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapOr),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapOr>())).isshared as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapOr),
            "::",
            stringify!(isshared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapOr>())).bitmapplans as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapOr),
            "::",
            stringify!(bitmapplans)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Scan {
    pub plan: Plan,
    pub scanrelid: Index,
}
#[test]
fn bindgen_test_layout_Scan() {
    assert_eq!(
        ::std::mem::size_of::<Scan>(),
        112usize,
        concat!("Size of: ", stringify!(Scan))
    );
    assert_eq!(
        ::std::mem::align_of::<Scan>(),
        8usize,
        concat!("Alignment of ", stringify!(Scan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scan>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Scan),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Scan>())).scanrelid as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Scan),
            "::",
            stringify!(scanrelid)
        )
    );
}
pub type SeqScan = Scan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleScan {
    pub scan: Scan,
    pub tablesample: *mut TableSampleClause,
}
#[test]
fn bindgen_test_layout_SampleScan() {
    assert_eq!(
        ::std::mem::size_of::<SampleScan>(),
        120usize,
        concat!("Size of: ", stringify!(SampleScan))
    );
    assert_eq!(
        ::std::mem::align_of::<SampleScan>(),
        8usize,
        concat!("Alignment of ", stringify!(SampleScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SampleScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SampleScan>())).tablesample as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleScan),
            "::",
            stringify!(tablesample)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
    pub indexorderby: *mut List,
    pub indexorderbyorig: *mut List,
    pub indexorderbyops: *mut List,
    pub indexorderdir: ScanDirection,
}
#[test]
fn bindgen_test_layout_IndexScan() {
    assert_eq!(
        ::std::mem::size_of::<IndexScan>(),
        168usize,
        concat!("Size of: ", stringify!(IndexScan))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexScan>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScan>())).indexid as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScan),
            "::",
            stringify!(indexid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScan>())).indexqual as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScan),
            "::",
            stringify!(indexqual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScan>())).indexqualorig as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScan),
            "::",
            stringify!(indexqualorig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScan>())).indexorderby as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScan),
            "::",
            stringify!(indexorderby)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScan>())).indexorderbyorig as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScan),
            "::",
            stringify!(indexorderbyorig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScan>())).indexorderbyops as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScan),
            "::",
            stringify!(indexorderbyops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScan>())).indexorderdir as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScan),
            "::",
            stringify!(indexorderdir)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexOnlyScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexorderby: *mut List,
    pub indextlist: *mut List,
    pub indexorderdir: ScanDirection,
}
#[test]
fn bindgen_test_layout_IndexOnlyScan() {
    assert_eq!(
        ::std::mem::size_of::<IndexOnlyScan>(),
        152usize,
        concat!("Size of: ", stringify!(IndexOnlyScan))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexOnlyScan>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexOnlyScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexOnlyScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexOnlyScan>())).indexid as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScan),
            "::",
            stringify!(indexid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexOnlyScan>())).indexqual as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScan),
            "::",
            stringify!(indexqual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexOnlyScan>())).indexorderby as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScan),
            "::",
            stringify!(indexorderby)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexOnlyScan>())).indextlist as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScan),
            "::",
            stringify!(indextlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexOnlyScan>())).indexorderdir as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScan),
            "::",
            stringify!(indexorderdir)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapIndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub isshared: bool,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapIndexScan() {
    assert_eq!(
        ::std::mem::size_of::<BitmapIndexScan>(),
        136usize,
        concat!("Size of: ", stringify!(BitmapIndexScan))
    );
    assert_eq!(
        ::std::mem::align_of::<BitmapIndexScan>(),
        8usize,
        concat!("Alignment of ", stringify!(BitmapIndexScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapIndexScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapIndexScan>())).indexid as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScan),
            "::",
            stringify!(indexid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapIndexScan>())).isshared as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScan),
            "::",
            stringify!(isshared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapIndexScan>())).indexqual as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScan),
            "::",
            stringify!(indexqual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapIndexScan>())).indexqualorig as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScan),
            "::",
            stringify!(indexqualorig)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapHeapScan {
    pub scan: Scan,
    pub bitmapqualorig: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapHeapScan() {
    assert_eq!(
        ::std::mem::size_of::<BitmapHeapScan>(),
        120usize,
        concat!("Size of: ", stringify!(BitmapHeapScan))
    );
    assert_eq!(
        ::std::mem::align_of::<BitmapHeapScan>(),
        8usize,
        concat!("Alignment of ", stringify!(BitmapHeapScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScan>())).bitmapqualorig as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScan),
            "::",
            stringify!(bitmapqualorig)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidScan {
    pub scan: Scan,
    pub tidquals: *mut List,
}
#[test]
fn bindgen_test_layout_TidScan() {
    assert_eq!(
        ::std::mem::size_of::<TidScan>(),
        120usize,
        concat!("Size of: ", stringify!(TidScan))
    );
    assert_eq!(
        ::std::mem::align_of::<TidScan>(),
        8usize,
        concat!("Alignment of ", stringify!(TidScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TidScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TidScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TidScan>())).tidquals as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(TidScan),
            "::",
            stringify!(tidquals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubqueryScan {
    pub scan: Scan,
    pub subplan: *mut Plan,
}
#[test]
fn bindgen_test_layout_SubqueryScan() {
    assert_eq!(
        ::std::mem::size_of::<SubqueryScan>(),
        120usize,
        concat!("Size of: ", stringify!(SubqueryScan))
    );
    assert_eq!(
        ::std::mem::align_of::<SubqueryScan>(),
        8usize,
        concat!("Alignment of ", stringify!(SubqueryScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubqueryScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubqueryScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubqueryScan>())).subplan as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SubqueryScan),
            "::",
            stringify!(subplan)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScan {
    pub scan: Scan,
    pub functions: *mut List,
    pub funcordinality: bool,
}
#[test]
fn bindgen_test_layout_FunctionScan() {
    assert_eq!(
        ::std::mem::size_of::<FunctionScan>(),
        128usize,
        concat!("Size of: ", stringify!(FunctionScan))
    );
    assert_eq!(
        ::std::mem::align_of::<FunctionScan>(),
        8usize,
        concat!("Alignment of ", stringify!(FunctionScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionScan>())).functions as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionScan),
            "::",
            stringify!(functions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionScan>())).funcordinality as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionScan),
            "::",
            stringify!(funcordinality)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValuesScan {
    pub scan: Scan,
    pub values_lists: *mut List,
}
#[test]
fn bindgen_test_layout_ValuesScan() {
    assert_eq!(
        ::std::mem::size_of::<ValuesScan>(),
        120usize,
        concat!("Size of: ", stringify!(ValuesScan))
    );
    assert_eq!(
        ::std::mem::align_of::<ValuesScan>(),
        8usize,
        concat!("Alignment of ", stringify!(ValuesScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValuesScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValuesScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValuesScan>())).values_lists as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ValuesScan),
            "::",
            stringify!(values_lists)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFuncScan {
    pub scan: Scan,
    pub tablefunc: *mut TableFunc,
}
#[test]
fn bindgen_test_layout_TableFuncScan() {
    assert_eq!(
        ::std::mem::size_of::<TableFuncScan>(),
        120usize,
        concat!("Size of: ", stringify!(TableFuncScan))
    );
    assert_eq!(
        ::std::mem::align_of::<TableFuncScan>(),
        8usize,
        concat!("Alignment of ", stringify!(TableFuncScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScan>())).tablefunc as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScan),
            "::",
            stringify!(tablefunc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CteScan {
    pub scan: Scan,
    pub ctePlanId: ::std::os::raw::c_int,
    pub cteParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CteScan() {
    assert_eq!(
        ::std::mem::size_of::<CteScan>(),
        120usize,
        concat!("Size of: ", stringify!(CteScan))
    );
    assert_eq!(
        ::std::mem::align_of::<CteScan>(),
        8usize,
        concat!("Alignment of ", stringify!(CteScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CteScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CteScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CteScan>())).ctePlanId as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CteScan),
            "::",
            stringify!(ctePlanId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CteScan>())).cteParam as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(CteScan),
            "::",
            stringify!(cteParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedTuplestoreScan {
    pub scan: Scan,
    pub enrname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NamedTuplestoreScan() {
    assert_eq!(
        ::std::mem::size_of::<NamedTuplestoreScan>(),
        120usize,
        concat!("Size of: ", stringify!(NamedTuplestoreScan))
    );
    assert_eq!(
        ::std::mem::align_of::<NamedTuplestoreScan>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedTuplestoreScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NamedTuplestoreScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedTuplestoreScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NamedTuplestoreScan>())).enrname as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedTuplestoreScan),
            "::",
            stringify!(enrname)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WorkTableScan {
    pub scan: Scan,
    pub wtParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WorkTableScan() {
    assert_eq!(
        ::std::mem::size_of::<WorkTableScan>(),
        120usize,
        concat!("Size of: ", stringify!(WorkTableScan))
    );
    assert_eq!(
        ::std::mem::align_of::<WorkTableScan>(),
        8usize,
        concat!("Alignment of ", stringify!(WorkTableScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorkTableScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkTableScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorkTableScan>())).wtParam as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkTableScan),
            "::",
            stringify!(wtParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignScan {
    pub scan: Scan,
    pub operation: CmdType,
    pub fs_server: Oid,
    pub fdw_exprs: *mut List,
    pub fdw_private: *mut List,
    pub fdw_scan_tlist: *mut List,
    pub fdw_recheck_quals: *mut List,
    pub fs_relids: *mut Bitmapset,
    pub fsSystemCol: bool,
}
#[test]
fn bindgen_test_layout_ForeignScan() {
    assert_eq!(
        ::std::mem::size_of::<ForeignScan>(),
        168usize,
        concat!("Size of: ", stringify!(ForeignScan))
    );
    assert_eq!(
        ::std::mem::align_of::<ForeignScan>(),
        8usize,
        concat!("Alignment of ", stringify!(ForeignScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScan>())).operation as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScan),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScan>())).fs_server as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScan),
            "::",
            stringify!(fs_server)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScan>())).fdw_exprs as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScan),
            "::",
            stringify!(fdw_exprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScan>())).fdw_private as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScan),
            "::",
            stringify!(fdw_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScan>())).fdw_scan_tlist as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScan),
            "::",
            stringify!(fdw_scan_tlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScan>())).fdw_recheck_quals as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScan),
            "::",
            stringify!(fdw_recheck_quals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScan>())).fs_relids as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScan),
            "::",
            stringify!(fs_relids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScan>())).fsSystemCol as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScan),
            "::",
            stringify!(fsSystemCol)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScanMethods {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScan {
    pub scan: Scan,
    pub flags: uint32,
    pub custom_plans: *mut List,
    pub custom_exprs: *mut List,
    pub custom_private: *mut List,
    pub custom_scan_tlist: *mut List,
    pub custom_relids: *mut Bitmapset,
    pub methods: *const CustomScanMethods,
}
#[test]
fn bindgen_test_layout_CustomScan() {
    assert_eq!(
        ::std::mem::size_of::<CustomScan>(),
        168usize,
        concat!("Size of: ", stringify!(CustomScan))
    );
    assert_eq!(
        ::std::mem::align_of::<CustomScan>(),
        8usize,
        concat!("Alignment of ", stringify!(CustomScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScan>())).scan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScan),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScan>())).flags as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScan),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScan>())).custom_plans as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScan),
            "::",
            stringify!(custom_plans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScan>())).custom_exprs as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScan),
            "::",
            stringify!(custom_exprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScan>())).custom_private as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScan),
            "::",
            stringify!(custom_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScan>())).custom_scan_tlist as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScan),
            "::",
            stringify!(custom_scan_tlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScan>())).custom_relids as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScan),
            "::",
            stringify!(custom_relids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScan>())).methods as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScan),
            "::",
            stringify!(methods)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Join {
    pub plan: Plan,
    pub jointype: JoinType,
    pub inner_unique: bool,
    pub joinqual: *mut List,
}
#[test]
fn bindgen_test_layout_Join() {
    assert_eq!(
        ::std::mem::size_of::<Join>(),
        120usize,
        concat!("Size of: ", stringify!(Join))
    );
    assert_eq!(
        ::std::mem::align_of::<Join>(),
        8usize,
        concat!("Alignment of ", stringify!(Join))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Join>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Join),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Join>())).jointype as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Join),
            "::",
            stringify!(jointype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Join>())).inner_unique as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Join),
            "::",
            stringify!(inner_unique)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Join>())).joinqual as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Join),
            "::",
            stringify!(joinqual)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoop {
    pub join: Join,
    pub nestParams: *mut List,
}
#[test]
fn bindgen_test_layout_NestLoop() {
    assert_eq!(
        ::std::mem::size_of::<NestLoop>(),
        128usize,
        concat!("Size of: ", stringify!(NestLoop))
    );
    assert_eq!(
        ::std::mem::align_of::<NestLoop>(),
        8usize,
        concat!("Alignment of ", stringify!(NestLoop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NestLoop>())).join as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NestLoop),
            "::",
            stringify!(join)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NestLoop>())).nestParams as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(NestLoop),
            "::",
            stringify!(nestParams)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoopParam {
    pub type_: NodeTag,
    pub paramno: ::std::os::raw::c_int,
    pub paramval: *mut Var,
}
#[test]
fn bindgen_test_layout_NestLoopParam() {
    assert_eq!(
        ::std::mem::size_of::<NestLoopParam>(),
        16usize,
        concat!("Size of: ", stringify!(NestLoopParam))
    );
    assert_eq!(
        ::std::mem::align_of::<NestLoopParam>(),
        8usize,
        concat!("Alignment of ", stringify!(NestLoopParam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NestLoopParam>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NestLoopParam),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NestLoopParam>())).paramno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NestLoopParam),
            "::",
            stringify!(paramno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NestLoopParam>())).paramval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NestLoopParam),
            "::",
            stringify!(paramval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoin {
    pub join: Join,
    pub skip_mark_restore: bool,
    pub mergeclauses: *mut List,
    pub mergeFamilies: *mut Oid,
    pub mergeCollations: *mut Oid,
    pub mergeStrategies: *mut ::std::os::raw::c_int,
    pub mergeNullsFirst: *mut bool,
}
#[test]
fn bindgen_test_layout_MergeJoin() {
    assert_eq!(
        ::std::mem::size_of::<MergeJoin>(),
        168usize,
        concat!("Size of: ", stringify!(MergeJoin))
    );
    assert_eq!(
        ::std::mem::align_of::<MergeJoin>(),
        8usize,
        concat!("Alignment of ", stringify!(MergeJoin))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoin>())).join as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoin),
            "::",
            stringify!(join)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoin>())).skip_mark_restore as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoin),
            "::",
            stringify!(skip_mark_restore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoin>())).mergeclauses as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoin),
            "::",
            stringify!(mergeclauses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoin>())).mergeFamilies as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoin),
            "::",
            stringify!(mergeFamilies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoin>())).mergeCollations as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoin),
            "::",
            stringify!(mergeCollations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoin>())).mergeStrategies as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoin),
            "::",
            stringify!(mergeStrategies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoin>())).mergeNullsFirst as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoin),
            "::",
            stringify!(mergeNullsFirst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoin {
    pub join: Join,
    pub hashclauses: *mut List,
}
#[test]
fn bindgen_test_layout_HashJoin() {
    assert_eq!(
        ::std::mem::size_of::<HashJoin>(),
        128usize,
        concat!("Size of: ", stringify!(HashJoin))
    );
    assert_eq!(
        ::std::mem::align_of::<HashJoin>(),
        8usize,
        concat!("Alignment of ", stringify!(HashJoin))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoin>())).join as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoin),
            "::",
            stringify!(join)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoin>())).hashclauses as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoin),
            "::",
            stringify!(hashclauses)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Material {
    pub plan: Plan,
}
#[test]
fn bindgen_test_layout_Material() {
    assert_eq!(
        ::std::mem::size_of::<Material>(),
        104usize,
        concat!("Size of: ", stringify!(Material))
    );
    assert_eq!(
        ::std::mem::align_of::<Material>(),
        8usize,
        concat!("Alignment of ", stringify!(Material))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Material>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Material),
            "::",
            stringify!(plan)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sort {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
}
#[test]
fn bindgen_test_layout_Sort() {
    assert_eq!(
        ::std::mem::size_of::<Sort>(),
        144usize,
        concat!("Size of: ", stringify!(Sort))
    );
    assert_eq!(
        ::std::mem::align_of::<Sort>(),
        8usize,
        concat!("Alignment of ", stringify!(Sort))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sort>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sort),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sort>())).numCols as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Sort),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sort>())).sortColIdx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Sort),
            "::",
            stringify!(sortColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sort>())).sortOperators as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Sort),
            "::",
            stringify!(sortOperators)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sort>())).collations as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Sort),
            "::",
            stringify!(collations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sort>())).nullsFirst as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Sort),
            "::",
            stringify!(nullsFirst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Group {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
}
#[test]
fn bindgen_test_layout_Group() {
    assert_eq!(
        ::std::mem::size_of::<Group>(),
        128usize,
        concat!("Size of: ", stringify!(Group))
    );
    assert_eq!(
        ::std::mem::align_of::<Group>(),
        8usize,
        concat!("Alignment of ", stringify!(Group))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Group>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Group),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Group>())).numCols as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Group),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Group>())).grpColIdx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Group),
            "::",
            stringify!(grpColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Group>())).grpOperators as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Group),
            "::",
            stringify!(grpOperators)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Agg {
    pub plan: Plan,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
    pub aggParams: *mut Bitmapset,
    pub groupingSets: *mut List,
    pub chain: *mut List,
}
#[test]
fn bindgen_test_layout_Agg() {
    assert_eq!(
        ::std::mem::size_of::<Agg>(),
        168usize,
        concat!("Size of: ", stringify!(Agg))
    );
    assert_eq!(
        ::std::mem::align_of::<Agg>(),
        8usize,
        concat!("Alignment of ", stringify!(Agg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Agg>())).plan as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Agg), "::", stringify!(plan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Agg>())).aggstrategy as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Agg),
            "::",
            stringify!(aggstrategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Agg>())).aggsplit as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Agg),
            "::",
            stringify!(aggsplit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Agg>())).numCols as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Agg),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Agg>())).grpColIdx as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Agg),
            "::",
            stringify!(grpColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Agg>())).grpOperators as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Agg),
            "::",
            stringify!(grpOperators)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Agg>())).numGroups as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Agg),
            "::",
            stringify!(numGroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Agg>())).aggParams as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Agg),
            "::",
            stringify!(aggParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Agg>())).groupingSets as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Agg),
            "::",
            stringify!(groupingSets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Agg>())).chain as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(Agg),
            "::",
            stringify!(chain)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAgg {
    pub plan: Plan,
    pub winref: Index,
    pub partNumCols: ::std::os::raw::c_int,
    pub partColIdx: *mut AttrNumber,
    pub partOperators: *mut Oid,
    pub ordNumCols: ::std::os::raw::c_int,
    pub ordColIdx: *mut AttrNumber,
    pub ordOperators: *mut Oid,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub startInRangeFunc: Oid,
    pub endInRangeFunc: Oid,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
}
#[test]
fn bindgen_test_layout_WindowAgg() {
    assert_eq!(
        ::std::mem::size_of::<WindowAgg>(),
        192usize,
        concat!("Size of: ", stringify!(WindowAgg))
    );
    assert_eq!(
        ::std::mem::align_of::<WindowAgg>(),
        8usize,
        concat!("Alignment of ", stringify!(WindowAgg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).winref as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(winref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).partNumCols as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(partNumCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).partColIdx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(partColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).partOperators as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(partOperators)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).ordNumCols as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(ordNumCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).ordColIdx as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(ordColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).ordOperators as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(ordOperators)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).frameOptions as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(frameOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).startOffset as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(startOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).endOffset as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(endOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).startInRangeFunc as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(startInRangeFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).endInRangeFunc as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(endInRangeFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).inRangeColl as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(inRangeColl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).inRangeAsc as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(inRangeAsc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAgg>())).inRangeNullsFirst as *const _ as usize },
        189usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAgg),
            "::",
            stringify!(inRangeNullsFirst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Unique {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub uniqColIdx: *mut AttrNumber,
    pub uniqOperators: *mut Oid,
}
#[test]
fn bindgen_test_layout_Unique() {
    assert_eq!(
        ::std::mem::size_of::<Unique>(),
        128usize,
        concat!("Size of: ", stringify!(Unique))
    );
    assert_eq!(
        ::std::mem::align_of::<Unique>(),
        8usize,
        concat!("Alignment of ", stringify!(Unique))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Unique>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Unique),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Unique>())).numCols as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Unique),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Unique>())).uniqColIdx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Unique),
            "::",
            stringify!(uniqColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Unique>())).uniqOperators as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Unique),
            "::",
            stringify!(uniqOperators)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gather {
    pub plan: Plan,
    pub num_workers: ::std::os::raw::c_int,
    pub rescan_param: ::std::os::raw::c_int,
    pub single_copy: bool,
    pub invisible: bool,
    pub initParam: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_Gather() {
    assert_eq!(
        ::std::mem::size_of::<Gather>(),
        128usize,
        concat!("Size of: ", stringify!(Gather))
    );
    assert_eq!(
        ::std::mem::align_of::<Gather>(),
        8usize,
        concat!("Alignment of ", stringify!(Gather))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gather>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Gather),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gather>())).num_workers as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Gather),
            "::",
            stringify!(num_workers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gather>())).rescan_param as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Gather),
            "::",
            stringify!(rescan_param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gather>())).single_copy as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Gather),
            "::",
            stringify!(single_copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gather>())).invisible as *const _ as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(Gather),
            "::",
            stringify!(invisible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Gather>())).initParam as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Gather),
            "::",
            stringify!(initParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherMerge {
    pub plan: Plan,
    pub num_workers: ::std::os::raw::c_int,
    pub rescan_param: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
    pub initParam: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_GatherMerge() {
    assert_eq!(
        ::std::mem::size_of::<GatherMerge>(),
        160usize,
        concat!("Size of: ", stringify!(GatherMerge))
    );
    assert_eq!(
        ::std::mem::align_of::<GatherMerge>(),
        8usize,
        concat!("Alignment of ", stringify!(GatherMerge))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMerge>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMerge),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMerge>())).num_workers as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMerge),
            "::",
            stringify!(num_workers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMerge>())).rescan_param as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMerge),
            "::",
            stringify!(rescan_param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMerge>())).numCols as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMerge),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMerge>())).sortColIdx as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMerge),
            "::",
            stringify!(sortColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMerge>())).sortOperators as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMerge),
            "::",
            stringify!(sortOperators)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMerge>())).collations as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMerge),
            "::",
            stringify!(collations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMerge>())).nullsFirst as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMerge),
            "::",
            stringify!(nullsFirst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMerge>())).initParam as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMerge),
            "::",
            stringify!(initParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Hash {
    pub plan: Plan,
    pub skewTable: Oid,
    pub skewColumn: AttrNumber,
    pub skewInherit: bool,
    pub rows_total: f64,
}
#[test]
fn bindgen_test_layout_Hash() {
    assert_eq!(
        ::std::mem::size_of::<Hash>(),
        120usize,
        concat!("Size of: ", stringify!(Hash))
    );
    assert_eq!(
        ::std::mem::align_of::<Hash>(),
        8usize,
        concat!("Alignment of ", stringify!(Hash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Hash>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Hash),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Hash>())).skewTable as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Hash),
            "::",
            stringify!(skewTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Hash>())).skewColumn as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Hash),
            "::",
            stringify!(skewColumn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Hash>())).skewInherit as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(Hash),
            "::",
            stringify!(skewInherit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Hash>())).rows_total as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Hash),
            "::",
            stringify!(rows_total)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOp {
    pub plan: Plan,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_SetOp() {
    assert_eq!(
        ::std::mem::size_of::<SetOp>(),
        152usize,
        concat!("Size of: ", stringify!(SetOp))
    );
    assert_eq!(
        ::std::mem::align_of::<SetOp>(),
        8usize,
        concat!("Alignment of ", stringify!(SetOp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOp>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOp),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOp>())).cmd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOp),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOp>())).strategy as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOp),
            "::",
            stringify!(strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOp>())).numCols as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOp),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOp>())).dupColIdx as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOp),
            "::",
            stringify!(dupColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOp>())).dupOperators as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOp),
            "::",
            stringify!(dupOperators)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOp>())).flagColIdx as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOp),
            "::",
            stringify!(flagColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOp>())).firstFlag as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOp),
            "::",
            stringify!(firstFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOp>())).numGroups as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOp),
            "::",
            stringify!(numGroups)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRows {
    pub plan: Plan,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LockRows() {
    assert_eq!(
        ::std::mem::size_of::<LockRows>(),
        120usize,
        concat!("Size of: ", stringify!(LockRows))
    );
    assert_eq!(
        ::std::mem::align_of::<LockRows>(),
        8usize,
        concat!("Alignment of ", stringify!(LockRows))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockRows>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LockRows),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockRows>())).rowMarks as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(LockRows),
            "::",
            stringify!(rowMarks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockRows>())).epqParam as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(LockRows),
            "::",
            stringify!(epqParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Limit {
    pub plan: Plan,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
}
#[test]
fn bindgen_test_layout_Limit() {
    assert_eq!(
        ::std::mem::size_of::<Limit>(),
        120usize,
        concat!("Size of: ", stringify!(Limit))
    );
    assert_eq!(
        ::std::mem::align_of::<Limit>(),
        8usize,
        concat!("Alignment of ", stringify!(Limit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Limit>())).plan as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Limit),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Limit>())).limitOffset as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Limit),
            "::",
            stringify!(limitOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Limit>())).limitCount as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Limit),
            "::",
            stringify!(limitCount)
        )
    );
}
pub const RowMarkType_ROW_MARK_EXCLUSIVE: RowMarkType = 0;
pub const RowMarkType_ROW_MARK_NOKEYEXCLUSIVE: RowMarkType = 1;
pub const RowMarkType_ROW_MARK_SHARE: RowMarkType = 2;
pub const RowMarkType_ROW_MARK_KEYSHARE: RowMarkType = 3;
pub const RowMarkType_ROW_MARK_REFERENCE: RowMarkType = 4;
pub const RowMarkType_ROW_MARK_COPY: RowMarkType = 5;
pub type RowMarkType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanRowMark {
    pub type_: NodeTag,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub allMarkTypes: ::std::os::raw::c_int,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub isParent: bool,
}
#[test]
fn bindgen_test_layout_PlanRowMark() {
    assert_eq!(
        ::std::mem::size_of::<PlanRowMark>(),
        36usize,
        concat!("Size of: ", stringify!(PlanRowMark))
    );
    assert_eq!(
        ::std::mem::align_of::<PlanRowMark>(),
        4usize,
        concat!("Alignment of ", stringify!(PlanRowMark))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanRowMark>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanRowMark),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanRowMark>())).rti as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanRowMark),
            "::",
            stringify!(rti)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanRowMark>())).prti as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanRowMark),
            "::",
            stringify!(prti)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanRowMark>())).rowmarkId as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanRowMark),
            "::",
            stringify!(rowmarkId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanRowMark>())).markType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanRowMark),
            "::",
            stringify!(markType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanRowMark>())).allMarkTypes as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanRowMark),
            "::",
            stringify!(allMarkTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanRowMark>())).strength as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanRowMark),
            "::",
            stringify!(strength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanRowMark>())).waitPolicy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanRowMark),
            "::",
            stringify!(waitPolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanRowMark>())).isParent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanRowMark),
            "::",
            stringify!(isParent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneInfo {
    pub type_: NodeTag,
    pub prune_infos: *mut List,
    pub other_subplans: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_PartitionPruneInfo() {
    assert_eq!(
        ::std::mem::size_of::<PartitionPruneInfo>(),
        24usize,
        concat!("Size of: ", stringify!(PartitionPruneInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PartitionPruneInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PartitionPruneInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionPruneInfo>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionPruneInfo>())).prune_infos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneInfo),
            "::",
            stringify!(prune_infos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PartitionPruneInfo>())).other_subplans as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneInfo),
            "::",
            stringify!(other_subplans)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionedRelPruneInfo {
    pub type_: NodeTag,
    pub reloid: Oid,
    pub pruning_steps: *mut List,
    pub present_parts: *mut Bitmapset,
    pub nparts: ::std::os::raw::c_int,
    pub nexprs: ::std::os::raw::c_int,
    pub subplan_map: *mut ::std::os::raw::c_int,
    pub subpart_map: *mut ::std::os::raw::c_int,
    pub hasexecparam: *mut bool,
    pub do_initial_prune: bool,
    pub do_exec_prune: bool,
    pub execparamids: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_PartitionedRelPruneInfo() {
    assert_eq!(
        ::std::mem::size_of::<PartitionedRelPruneInfo>(),
        72usize,
        concat!("Size of: ", stringify!(PartitionedRelPruneInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<PartitionedRelPruneInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PartitionedRelPruneInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).reloid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(reloid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).pruning_steps as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(pruning_steps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).present_parts as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(present_parts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).nparts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(nparts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).nexprs as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(nexprs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).subplan_map as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(subplan_map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).subpart_map as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(subpart_map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).hasexecparam as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(hasexecparam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).do_initial_prune as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(do_initial_prune)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).do_exec_prune as *const _ as usize
        },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(do_exec_prune)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PartitionedRelPruneInfo>())).execparamids as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionedRelPruneInfo),
            "::",
            stringify!(execparamids)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStep {
    pub type_: NodeTag,
    pub step_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PartitionPruneStep() {
    assert_eq!(
        ::std::mem::size_of::<PartitionPruneStep>(),
        8usize,
        concat!("Size of: ", stringify!(PartitionPruneStep))
    );
    assert_eq!(
        ::std::mem::align_of::<PartitionPruneStep>(),
        4usize,
        concat!("Alignment of ", stringify!(PartitionPruneStep))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionPruneStep>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneStep),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionPruneStep>())).step_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneStep),
            "::",
            stringify!(step_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStepOp {
    pub step: PartitionPruneStep,
    pub opstrategy: StrategyNumber,
    pub exprs: *mut List,
    pub cmpfns: *mut List,
    pub nullkeys: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_PartitionPruneStepOp() {
    assert_eq!(
        ::std::mem::size_of::<PartitionPruneStepOp>(),
        40usize,
        concat!("Size of: ", stringify!(PartitionPruneStepOp))
    );
    assert_eq!(
        ::std::mem::align_of::<PartitionPruneStepOp>(),
        8usize,
        concat!("Alignment of ", stringify!(PartitionPruneStepOp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionPruneStepOp>())).step as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneStepOp),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionPruneStepOp>())).opstrategy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneStepOp),
            "::",
            stringify!(opstrategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionPruneStepOp>())).exprs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneStepOp),
            "::",
            stringify!(exprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionPruneStepOp>())).cmpfns as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneStepOp),
            "::",
            stringify!(cmpfns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionPruneStepOp>())).nullkeys as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneStepOp),
            "::",
            stringify!(nullkeys)
        )
    );
}
pub const PartitionPruneCombineOp_PARTPRUNE_COMBINE_UNION: PartitionPruneCombineOp = 0;
pub const PartitionPruneCombineOp_PARTPRUNE_COMBINE_INTERSECT: PartitionPruneCombineOp = 1;
pub type PartitionPruneCombineOp = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStepCombine {
    pub step: PartitionPruneStep,
    pub combineOp: PartitionPruneCombineOp,
    pub source_stepids: *mut List,
}
#[test]
fn bindgen_test_layout_PartitionPruneStepCombine() {
    assert_eq!(
        ::std::mem::size_of::<PartitionPruneStepCombine>(),
        24usize,
        concat!("Size of: ", stringify!(PartitionPruneStepCombine))
    );
    assert_eq!(
        ::std::mem::align_of::<PartitionPruneStepCombine>(),
        8usize,
        concat!("Alignment of ", stringify!(PartitionPruneStepCombine))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PartitionPruneStepCombine>())).step as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneStepCombine),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PartitionPruneStepCombine>())).combineOp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneStepCombine),
            "::",
            stringify!(combineOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PartitionPruneStepCombine>())).source_stepids as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PartitionPruneStepCombine),
            "::",
            stringify!(source_stepids)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanInvalItem {
    pub type_: NodeTag,
    pub cacheId: ::std::os::raw::c_int,
    pub hashValue: uint32,
}
#[test]
fn bindgen_test_layout_PlanInvalItem() {
    assert_eq!(
        ::std::mem::size_of::<PlanInvalItem>(),
        12usize,
        concat!("Size of: ", stringify!(PlanInvalItem))
    );
    assert_eq!(
        ::std::mem::align_of::<PlanInvalItem>(),
        4usize,
        concat!("Alignment of ", stringify!(PlanInvalItem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanInvalItem>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanInvalItem),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanInvalItem>())).cacheId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanInvalItem),
            "::",
            stringify!(cacheId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanInvalItem>())).hashValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanInvalItem),
            "::",
            stringify!(hashValue)
        )
    );
}
pub type HashValueFunc = ::std::option::Option<
    unsafe extern "C" fn(key: *const ::std::os::raw::c_void, keysize: Size) -> uint32,
>;
pub type HashCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(
        key1: *const ::std::os::raw::c_void,
        key2: *const ::std::os::raw::c_void,
        keysize: Size,
    ) -> ::std::os::raw::c_int,
>;
pub type HashCopyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        keysize: Size,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type HashAllocFunc =
    ::std::option::Option<unsafe extern "C" fn(request: Size) -> *mut ::std::os::raw::c_void>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHELEMENT {
    pub link: *mut HASHELEMENT,
    pub hashvalue: uint32,
}
#[test]
fn bindgen_test_layout_HASHELEMENT() {
    assert_eq!(
        ::std::mem::size_of::<HASHELEMENT>(),
        16usize,
        concat!("Size of: ", stringify!(HASHELEMENT))
    );
    assert_eq!(
        ::std::mem::align_of::<HASHELEMENT>(),
        8usize,
        concat!("Alignment of ", stringify!(HASHELEMENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHELEMENT>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHELEMENT),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHELEMENT>())).hashvalue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHELEMENT),
            "::",
            stringify!(hashvalue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHHDR {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTAB {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHCTL {
    pub num_partitions: ::std::os::raw::c_long,
    pub ssize: ::std::os::raw::c_long,
    pub dsize: ::std::os::raw::c_long,
    pub max_dsize: ::std::os::raw::c_long,
    pub ffactor: ::std::os::raw::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub match_: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: MemoryContext,
    pub hctl: *mut HASHHDR,
}
#[test]
fn bindgen_test_layout_HASHCTL() {
    assert_eq!(
        ::std::mem::size_of::<HASHCTL>(),
        104usize,
        concat!("Size of: ", stringify!(HASHCTL))
    );
    assert_eq!(
        ::std::mem::align_of::<HASHCTL>(),
        8usize,
        concat!("Alignment of ", stringify!(HASHCTL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).num_partitions as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(num_partitions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).ssize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(ssize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).dsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(dsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).max_dsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(max_dsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).ffactor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(ffactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).keysize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(keysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).entrysize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(entrysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).hash as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).match_ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).keycopy as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(keycopy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).alloc as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).hcxt as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(hcxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASHCTL>())).hctl as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(HASHCTL),
            "::",
            stringify!(hctl)
        )
    );
}
pub const HASHACTION_HASH_FIND: HASHACTION = 0;
pub const HASHACTION_HASH_ENTER: HASHACTION = 1;
pub const HASHACTION_HASH_REMOVE: HASHACTION = 2;
pub const HASHACTION_HASH_ENTER_NULL: HASHACTION = 3;
pub type HASHACTION = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASH_SEQ_STATUS {
    pub hashp: *mut HTAB,
    pub curBucket: uint32,
    pub curEntry: *mut HASHELEMENT,
}
#[test]
fn bindgen_test_layout_HASH_SEQ_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<HASH_SEQ_STATUS>(),
        24usize,
        concat!("Size of: ", stringify!(HASH_SEQ_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<HASH_SEQ_STATUS>(),
        8usize,
        concat!("Alignment of ", stringify!(HASH_SEQ_STATUS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASH_SEQ_STATUS>())).hashp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_SEQ_STATUS),
            "::",
            stringify!(hashp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASH_SEQ_STATUS>())).curBucket as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_SEQ_STATUS),
            "::",
            stringify!(curBucket)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HASH_SEQ_STATUS>())).curEntry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HASH_SEQ_STATUS),
            "::",
            stringify!(curEntry)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_hash_create"]
    pub fn hash_create(
        tabname: *const ::std::os::raw::c_char,
        nelem: ::std::os::raw::c_long,
        info: *mut HASHCTL,
        flags: ::std::os::raw::c_int,
    ) -> *mut HTAB;
}
extern "C" {
    #[link_name = "\u{1}_hash_destroy"]
    pub fn hash_destroy(hashp: *mut HTAB);
}
extern "C" {
    #[link_name = "\u{1}_hash_stats"]
    pub fn hash_stats(where_: *const ::std::os::raw::c_char, hashp: *mut HTAB);
}
extern "C" {
    #[link_name = "\u{1}_hash_search"]
    pub fn hash_search(
        hashp: *mut HTAB,
        keyPtr: *const ::std::os::raw::c_void,
        action: HASHACTION,
        foundPtr: *mut bool,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_get_hash_value"]
    pub fn get_hash_value(hashp: *mut HTAB, keyPtr: *const ::std::os::raw::c_void) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}_hash_search_with_hash_value"]
    pub fn hash_search_with_hash_value(
        hashp: *mut HTAB,
        keyPtr: *const ::std::os::raw::c_void,
        hashvalue: uint32,
        action: HASHACTION,
        foundPtr: *mut bool,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_hash_update_hash_key"]
    pub fn hash_update_hash_key(
        hashp: *mut HTAB,
        existingEntry: *mut ::std::os::raw::c_void,
        newKeyPtr: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_hash_get_num_entries"]
    pub fn hash_get_num_entries(hashp: *mut HTAB) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_hash_seq_init"]
    pub fn hash_seq_init(status: *mut HASH_SEQ_STATUS, hashp: *mut HTAB);
}
extern "C" {
    #[link_name = "\u{1}_hash_seq_search"]
    pub fn hash_seq_search(status: *mut HASH_SEQ_STATUS) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_hash_seq_term"]
    pub fn hash_seq_term(status: *mut HASH_SEQ_STATUS);
}
extern "C" {
    #[link_name = "\u{1}_hash_freeze"]
    pub fn hash_freeze(hashp: *mut HTAB);
}
extern "C" {
    #[link_name = "\u{1}_hash_estimate_size"]
    pub fn hash_estimate_size(num_entries: ::std::os::raw::c_long, entrysize: Size) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_hash_select_dirsize"]
    pub fn hash_select_dirsize(num_entries: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_hash_get_shared_size"]
    pub fn hash_get_shared_size(info: *mut HASHCTL, flags: ::std::os::raw::c_int) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_AtEOXact_HashTables"]
    pub fn AtEOXact_HashTables(isCommit: bool);
}
extern "C" {
    #[link_name = "\u{1}_AtEOSubXact_HashTables"]
    pub fn AtEOSubXact_HashTables(isCommit: bool, nestDepth: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_string_hash"]
    pub fn string_hash(key: *const ::std::os::raw::c_void, keysize: Size) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}_tag_hash"]
    pub fn tag_hash(key: *const ::std::os::raw::c_void, keysize: Size) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}_uint32_hash"]
    pub fn uint32_hash(key: *const ::std::os::raw::c_void, keysize: Size) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}_bitmap_hash"]
    pub fn bitmap_hash(key: *const ::std::os::raw::c_void, keysize: Size) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}_bitmap_match"]
    pub fn bitmap_match(
        key1: *const ::std::os::raw::c_void,
        key2: *const ::std::os::raw::c_void,
        keysize: Size,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Trigger {
    pub tgoid: Oid,
    pub tgname: *mut ::std::os::raw::c_char,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool,
    pub tginitdeferred: bool,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: *mut int16,
    pub tgargs: *mut *mut ::std::os::raw::c_char,
    pub tgqual: *mut ::std::os::raw::c_char,
    pub tgoldtable: *mut ::std::os::raw::c_char,
    pub tgnewtable: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Trigger() {
    assert_eq!(
        ::std::mem::size_of::<Trigger>(),
        88usize,
        concat!("Size of: ", stringify!(Trigger))
    );
    assert_eq!(
        ::std::mem::align_of::<Trigger>(),
        8usize,
        concat!("Alignment of ", stringify!(Trigger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgoid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgoid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgfoid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgfoid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgtype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgenabled as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgenabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgisinternal as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgisinternal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgconstrrelid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgconstrrelid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgconstrindid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgconstrindid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgconstraint as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgconstraint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgdeferrable as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgdeferrable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tginitdeferred as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tginitdeferred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgnargs as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgnargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgnattr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgnattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgattr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgargs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgqual as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgqual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgoldtable as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgoldtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Trigger>())).tgnewtable as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Trigger),
            "::",
            stringify!(tgnewtable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerDesc {
    pub triggers: *mut Trigger,
    pub numtriggers: ::std::os::raw::c_int,
    pub trig_insert_before_row: bool,
    pub trig_insert_after_row: bool,
    pub trig_insert_instead_row: bool,
    pub trig_insert_before_statement: bool,
    pub trig_insert_after_statement: bool,
    pub trig_update_before_row: bool,
    pub trig_update_after_row: bool,
    pub trig_update_instead_row: bool,
    pub trig_update_before_statement: bool,
    pub trig_update_after_statement: bool,
    pub trig_delete_before_row: bool,
    pub trig_delete_after_row: bool,
    pub trig_delete_instead_row: bool,
    pub trig_delete_before_statement: bool,
    pub trig_delete_after_statement: bool,
    pub trig_truncate_before_statement: bool,
    pub trig_truncate_after_statement: bool,
    pub trig_insert_new_table: bool,
    pub trig_update_old_table: bool,
    pub trig_update_new_table: bool,
    pub trig_delete_old_table: bool,
}
#[test]
fn bindgen_test_layout_TriggerDesc() {
    assert_eq!(
        ::std::mem::size_of::<TriggerDesc>(),
        40usize,
        concat!("Size of: ", stringify!(TriggerDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<TriggerDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(TriggerDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerDesc>())).triggers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(triggers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerDesc>())).numtriggers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(numtriggers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_insert_before_row as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_insert_before_row)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_insert_after_row as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_insert_after_row)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_insert_instead_row as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_insert_instead_row)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_insert_before_statement as *const _
                as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_insert_before_statement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_insert_after_statement as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_insert_after_statement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_update_before_row as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_update_before_row)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_update_after_row as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_update_after_row)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_update_instead_row as *const _ as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_update_instead_row)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_update_before_statement as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_update_before_statement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_update_after_statement as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_update_after_statement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_delete_before_row as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_delete_before_row)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_delete_after_row as *const _ as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_delete_after_row)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_delete_instead_row as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_delete_instead_row)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_delete_before_statement as *const _
                as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_delete_before_statement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_delete_after_statement as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_delete_after_statement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_truncate_before_statement as *const _
                as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_truncate_before_statement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_truncate_after_statement as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_truncate_after_statement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_insert_new_table as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_insert_new_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_update_old_table as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_update_old_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_update_new_table as *const _ as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_update_new_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TriggerDesc>())).trig_delete_old_table as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerDesc),
            "::",
            stringify!(trig_delete_old_table)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirent {
    pub d_ino: __uint64_t,
    pub d_seekoff: __uint64_t,
    pub d_reclen: __uint16_t,
    pub d_namlen: __uint16_t,
    pub d_type: __uint8_t,
    pub d_name: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        1048usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_seekoff as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_seekoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_reclen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_namlen as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_namlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_type as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_name as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _telldir {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DIR {
    pub __dd_fd: ::std::os::raw::c_int,
    pub __dd_loc: ::std::os::raw::c_long,
    pub __dd_size: ::std::os::raw::c_long,
    pub __dd_buf: *mut ::std::os::raw::c_char,
    pub __dd_len: ::std::os::raw::c_int,
    pub __dd_seek: ::std::os::raw::c_long,
    pub __padding: ::std::os::raw::c_long,
    pub __dd_flags: ::std::os::raw::c_int,
    pub __dd_lock: __darwin_pthread_mutex_t,
    pub __dd_td: *mut _telldir,
}
#[test]
fn bindgen_test_layout_DIR() {
    assert_eq!(
        ::std::mem::size_of::<DIR>(),
        136usize,
        concat!("Size of: ", stringify!(DIR))
    );
    assert_eq!(
        ::std::mem::align_of::<DIR>(),
        8usize,
        concat!("Alignment of ", stringify!(DIR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_loc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_loc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_buf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_seek as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__padding as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_td as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_td)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_closedir"]
    pub fn closedir(arg1: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_opendir$INODE64"]
    pub fn opendir(arg1: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    #[link_name = "\u{1}_readdir$INODE64"]
    pub fn readdir(arg1: *mut DIR) -> *mut dirent;
}
extern "C" {
    #[link_name = "\u{1}_readdir_r$INODE64"]
    pub fn readdir_r(
        arg1: *mut DIR,
        arg2: *mut dirent,
        arg3: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rewinddir$INODE64"]
    pub fn rewinddir(arg1: *mut DIR);
}
extern "C" {
    #[link_name = "\u{1}_seekdir$INODE64"]
    pub fn seekdir(arg1: *mut DIR, arg2: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_telldir$INODE64"]
    pub fn telldir(arg1: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_fdopendir$INODE64"]
    pub fn fdopendir(arg1: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    #[link_name = "\u{1}_alphasort$INODE64"]
    pub fn alphasort(arg1: *mut *const dirent, arg2: *mut *const dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_dirfd"]
    pub fn dirfd(dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_scandir$INODE64"]
    pub fn scandir(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_scandir_b$INODE64"]
    pub fn scandir_b(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getdirentries_is_not_available_when_64_bit_inodes_are_in_effect"]
    pub fn getdirentries(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___opendir2$INODE64"]
    pub fn __opendir2(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_int)
        -> *mut DIR;
}
pub type File = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "\u{1}_max_files_per_process"]
    pub static mut max_files_per_process: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_max_safe_fds"]
    pub static mut max_safe_fds: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_PathNameOpenFile"]
    pub fn PathNameOpenFile(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
    ) -> File;
}
extern "C" {
    #[link_name = "\u{1}_PathNameOpenFilePerm"]
    pub fn PathNameOpenFilePerm(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
        fileMode: mode_t,
    ) -> File;
}
extern "C" {
    #[link_name = "\u{1}_OpenTemporaryFile"]
    pub fn OpenTemporaryFile(interXact: bool) -> File;
}
extern "C" {
    #[link_name = "\u{1}_FileClose"]
    pub fn FileClose(file: File);
}
extern "C" {
    #[link_name = "\u{1}_FilePrefetch"]
    pub fn FilePrefetch(
        file: File,
        offset: off_t,
        amount: ::std::os::raw::c_int,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_FileRead"]
    pub fn FileRead(
        file: File,
        buffer: *mut ::std::os::raw::c_char,
        amount: ::std::os::raw::c_int,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_FileWrite"]
    pub fn FileWrite(
        file: File,
        buffer: *mut ::std::os::raw::c_char,
        amount: ::std::os::raw::c_int,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_FileSync"]
    pub fn FileSync(file: File, wait_event_info: uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_FileSeek"]
    pub fn FileSeek(file: File, offset: off_t, whence: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    #[link_name = "\u{1}_FileTruncate"]
    pub fn FileTruncate(
        file: File,
        offset: off_t,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_FileWriteback"]
    pub fn FileWriteback(file: File, offset: off_t, nbytes: off_t, wait_event_info: uint32);
}
extern "C" {
    #[link_name = "\u{1}_FilePathName"]
    pub fn FilePathName(file: File) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_FileGetRawDesc"]
    pub fn FileGetRawDesc(file: File) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_FileGetRawFlags"]
    pub fn FileGetRawFlags(file: File) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_FileGetRawMode"]
    pub fn FileGetRawMode(file: File) -> mode_t;
}
extern "C" {
    #[link_name = "\u{1}_PathNameCreateTemporaryFile"]
    pub fn PathNameCreateTemporaryFile(
        name: *const ::std::os::raw::c_char,
        error_on_failure: bool,
    ) -> File;
}
extern "C" {
    #[link_name = "\u{1}_PathNameOpenTemporaryFile"]
    pub fn PathNameOpenTemporaryFile(name: *const ::std::os::raw::c_char) -> File;
}
extern "C" {
    #[link_name = "\u{1}_PathNameDeleteTemporaryFile"]
    pub fn PathNameDeleteTemporaryFile(
        name: *const ::std::os::raw::c_char,
        error_on_failure: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_PathNameCreateTemporaryDir"]
    pub fn PathNameCreateTemporaryDir(
        base: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_PathNameDeleteTemporaryDir"]
    pub fn PathNameDeleteTemporaryDir(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_TempTablespacePath"]
    pub fn TempTablespacePath(path: *mut ::std::os::raw::c_char, tablespace: Oid);
}
extern "C" {
    #[link_name = "\u{1}_AllocateFile"]
    pub fn AllocateFile(
        name: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_FreeFile"]
    pub fn FreeFile(file: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_OpenPipeStream"]
    pub fn OpenPipeStream(
        command: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}_ClosePipeStream"]
    pub fn ClosePipeStream(file: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_AllocateDir"]
    pub fn AllocateDir(dirname: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    #[link_name = "\u{1}_ReadDir"]
    pub fn ReadDir(dir: *mut DIR, dirname: *const ::std::os::raw::c_char) -> *mut dirent;
}
extern "C" {
    #[link_name = "\u{1}_ReadDirExtended"]
    pub fn ReadDirExtended(
        dir: *mut DIR,
        dirname: *const ::std::os::raw::c_char,
        elevel: ::std::os::raw::c_int,
    ) -> *mut dirent;
}
extern "C" {
    #[link_name = "\u{1}_FreeDir"]
    pub fn FreeDir(dir: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_OpenTransientFile"]
    pub fn OpenTransientFile(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_OpenTransientFilePerm"]
    pub fn OpenTransientFilePerm(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
        fileMode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_CloseTransientFile"]
    pub fn CloseTransientFile(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_BasicOpenFile"]
    pub fn BasicOpenFile(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_BasicOpenFilePerm"]
    pub fn BasicOpenFilePerm(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
        fileMode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_MakePGDirectory"]
    pub fn MakePGDirectory(directoryName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_InitFileAccess"]
    pub fn InitFileAccess();
}
extern "C" {
    #[link_name = "\u{1}_set_max_safe_fds"]
    pub fn set_max_safe_fds();
}
extern "C" {
    #[link_name = "\u{1}_closeAllVfds"]
    pub fn closeAllVfds();
}
extern "C" {
    #[link_name = "\u{1}_SetTempTablespaces"]
    pub fn SetTempTablespaces(tableSpaces: *mut Oid, numSpaces: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_TempTablespacesAreSet"]
    pub fn TempTablespacesAreSet() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_GetTempTablespaces"]
    pub fn GetTempTablespaces(
        tableSpaces: *mut Oid,
        numSpaces: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_GetNextTempTableSpace"]
    pub fn GetNextTempTableSpace() -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_AtEOXact_Files"]
    pub fn AtEOXact_Files(isCommit: bool);
}
extern "C" {
    #[link_name = "\u{1}_AtEOSubXact_Files"]
    pub fn AtEOSubXact_Files(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
}
extern "C" {
    #[link_name = "\u{1}_RemovePgTempFiles"]
    pub fn RemovePgTempFiles();
}
extern "C" {
    #[link_name = "\u{1}_looks_like_temp_rel_name"]
    pub fn looks_like_temp_rel_name(name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_pg_fsync"]
    pub fn pg_fsync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pg_fsync_no_writethrough"]
    pub fn pg_fsync_no_writethrough(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pg_fsync_writethrough"]
    pub fn pg_fsync_writethrough(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pg_fdatasync"]
    pub fn pg_fdatasync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pg_flush_data"]
    pub fn pg_flush_data(fd: ::std::os::raw::c_int, offset: off_t, amount: off_t);
}
extern "C" {
    #[link_name = "\u{1}_fsync_fname"]
    pub fn fsync_fname(fname: *const ::std::os::raw::c_char, isdir: bool);
}
extern "C" {
    #[link_name = "\u{1}_durable_rename"]
    pub fn durable_rename(
        oldfile: *const ::std::os::raw::c_char,
        newfile: *const ::std::os::raw::c_char,
        loglevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_durable_unlink"]
    pub fn durable_unlink(
        fname: *const ::std::os::raw::c_char,
        loglevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_durable_link_or_rename"]
    pub fn durable_link_or_rename(
        oldfile: *const ::std::os::raw::c_char,
        newfile: *const ::std::os::raw::c_char,
        loglevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SyncDataDirectory"]
    pub fn SyncDataDirectory();
}
pub type slock_t = ::std::os::raw::c_uchar;
extern "C" {
    #[link_name = "\u{1}_dummy_spinlock"]
    pub static mut dummy_spinlock: slock_t;
}
extern "C" {
    #[link_name = "\u{1}_s_lock"]
    pub fn s_lock(
        lock: *mut slock_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_set_spins_per_delay"]
    pub fn set_spins_per_delay(shared_spins_per_delay: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_update_spins_per_delay"]
    pub fn update_spins_per_delay(
        shared_spins_per_delay: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpinDelayStatus {
    pub spins: ::std::os::raw::c_int,
    pub delays: ::std::os::raw::c_int,
    pub cur_delay: ::std::os::raw::c_int,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_int,
    pub func: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SpinDelayStatus() {
    assert_eq!(
        ::std::mem::size_of::<SpinDelayStatus>(),
        40usize,
        concat!("Size of: ", stringify!(SpinDelayStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<SpinDelayStatus>(),
        8usize,
        concat!("Alignment of ", stringify!(SpinDelayStatus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SpinDelayStatus>())).spins as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SpinDelayStatus),
            "::",
            stringify!(spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SpinDelayStatus>())).delays as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SpinDelayStatus),
            "::",
            stringify!(delays)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SpinDelayStatus>())).cur_delay as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SpinDelayStatus),
            "::",
            stringify!(cur_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SpinDelayStatus>())).file as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SpinDelayStatus),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SpinDelayStatus>())).line as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SpinDelayStatus),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SpinDelayStatus>())).func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SpinDelayStatus),
            "::",
            stringify!(func)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_perform_spin_delay"]
    pub fn perform_spin_delay(status: *mut SpinDelayStatus);
}
extern "C" {
    #[link_name = "\u{1}_finish_spin_delay"]
    pub fn finish_spin_delay(status: *mut SpinDelayStatus);
}
extern "C" {
    #[link_name = "\u{1}_SpinlockSemas"]
    pub fn SpinlockSemas() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SpinlockSemaSize"]
    pub fn SpinlockSemaSize() -> Size;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedFileSet {
    pub creator_pid: pid_t,
    pub number: uint32,
    pub mutex: slock_t,
    pub refcnt: ::std::os::raw::c_int,
    pub ntablespaces: ::std::os::raw::c_int,
    pub tablespaces: [Oid; 8usize],
}
#[test]
fn bindgen_test_layout_SharedFileSet() {
    assert_eq!(
        ::std::mem::size_of::<SharedFileSet>(),
        52usize,
        concat!("Size of: ", stringify!(SharedFileSet))
    );
    assert_eq!(
        ::std::mem::align_of::<SharedFileSet>(),
        4usize,
        concat!("Alignment of ", stringify!(SharedFileSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SharedFileSet>())).creator_pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedFileSet),
            "::",
            stringify!(creator_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SharedFileSet>())).number as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedFileSet),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SharedFileSet>())).mutex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedFileSet),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SharedFileSet>())).refcnt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedFileSet),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SharedFileSet>())).ntablespaces as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedFileSet),
            "::",
            stringify!(ntablespaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SharedFileSet>())).tablespaces as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SharedFileSet),
            "::",
            stringify!(tablespaces)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_SharedFileSetInit"]
    pub fn SharedFileSetInit(fileset: *mut SharedFileSet, seg: *mut dsm_segment);
}
extern "C" {
    #[link_name = "\u{1}_SharedFileSetAttach"]
    pub fn SharedFileSetAttach(fileset: *mut SharedFileSet, seg: *mut dsm_segment);
}
extern "C" {
    #[link_name = "\u{1}_SharedFileSetCreate"]
    pub fn SharedFileSetCreate(
        fileset: *mut SharedFileSet,
        name: *const ::std::os::raw::c_char,
    ) -> File;
}
extern "C" {
    #[link_name = "\u{1}_SharedFileSetOpen"]
    pub fn SharedFileSetOpen(
        fileset: *mut SharedFileSet,
        name: *const ::std::os::raw::c_char,
    ) -> File;
}
extern "C" {
    #[link_name = "\u{1}_SharedFileSetDelete"]
    pub fn SharedFileSetDelete(
        fileset: *mut SharedFileSet,
        name: *const ::std::os::raw::c_char,
        error_on_failure: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_SharedFileSetDeleteAll"]
    pub fn SharedFileSetDeleteAll(fileset: *mut SharedFileSet);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedTuplestore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedTuplestoreAccessor {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_sts_estimate"]
    pub fn sts_estimate(participants: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_sts_initialize"]
    pub fn sts_initialize(
        sts: *mut SharedTuplestore,
        participants: ::std::os::raw::c_int,
        my_participant_number: ::std::os::raw::c_int,
        meta_data_size: usize,
        flags: ::std::os::raw::c_int,
        fileset: *mut SharedFileSet,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SharedTuplestoreAccessor;
}
extern "C" {
    #[link_name = "\u{1}_sts_attach"]
    pub fn sts_attach(
        sts: *mut SharedTuplestore,
        my_participant_number: ::std::os::raw::c_int,
        fileset: *mut SharedFileSet,
    ) -> *mut SharedTuplestoreAccessor;
}
extern "C" {
    #[link_name = "\u{1}_sts_end_write"]
    pub fn sts_end_write(accessor: *mut SharedTuplestoreAccessor);
}
extern "C" {
    #[link_name = "\u{1}_sts_reinitialize"]
    pub fn sts_reinitialize(accessor: *mut SharedTuplestoreAccessor);
}
extern "C" {
    #[link_name = "\u{1}_sts_begin_parallel_scan"]
    pub fn sts_begin_parallel_scan(accessor: *mut SharedTuplestoreAccessor);
}
extern "C" {
    #[link_name = "\u{1}_sts_end_parallel_scan"]
    pub fn sts_end_parallel_scan(accessor: *mut SharedTuplestoreAccessor);
}
extern "C" {
    #[link_name = "\u{1}_sts_puttuple"]
    pub fn sts_puttuple(
        accessor: *mut SharedTuplestoreAccessor,
        meta_data: *mut ::std::os::raw::c_void,
        tuple: MinimalTuple,
    );
}
extern "C" {
    #[link_name = "\u{1}_sts_parallel_scan_next"]
    pub fn sts_parallel_scan_next(
        accessor: *mut SharedTuplestoreAccessor,
        meta_data: *mut ::std::os::raw::c_void,
    ) -> MinimalTuple;
}
pub type SortSupport = *mut SortSupportData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortSupportData {
    pub ssup_cxt: MemoryContext,
    pub ssup_collation: Oid,
    pub ssup_reverse: bool,
    pub ssup_nulls_first: bool,
    pub ssup_attno: AttrNumber,
    pub ssup_extra: *mut ::std::os::raw::c_void,
    pub comparator: ::std::option::Option<
        unsafe extern "C" fn(x: Datum, y: Datum, ssup: SortSupport) -> ::std::os::raw::c_int,
    >,
    pub abbreviate: bool,
    pub abbrev_converter:
        ::std::option::Option<unsafe extern "C" fn(original: Datum, ssup: SortSupport) -> Datum>,
    pub abbrev_abort: ::std::option::Option<
        unsafe extern "C" fn(memtupcount: ::std::os::raw::c_int, ssup: SortSupport) -> bool,
    >,
    pub abbrev_full_comparator: ::std::option::Option<
        unsafe extern "C" fn(x: Datum, y: Datum, ssup: SortSupport) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_SortSupportData() {
    assert_eq!(
        ::std::mem::size_of::<SortSupportData>(),
        64usize,
        concat!("Size of: ", stringify!(SortSupportData))
    );
    assert_eq!(
        ::std::mem::align_of::<SortSupportData>(),
        8usize,
        concat!("Alignment of ", stringify!(SortSupportData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortSupportData>())).ssup_cxt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SortSupportData),
            "::",
            stringify!(ssup_cxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortSupportData>())).ssup_collation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SortSupportData),
            "::",
            stringify!(ssup_collation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortSupportData>())).ssup_reverse as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SortSupportData),
            "::",
            stringify!(ssup_reverse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SortSupportData>())).ssup_nulls_first as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SortSupportData),
            "::",
            stringify!(ssup_nulls_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortSupportData>())).ssup_attno as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SortSupportData),
            "::",
            stringify!(ssup_attno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortSupportData>())).ssup_extra as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SortSupportData),
            "::",
            stringify!(ssup_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortSupportData>())).comparator as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SortSupportData),
            "::",
            stringify!(comparator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortSupportData>())).abbreviate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SortSupportData),
            "::",
            stringify!(abbreviate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SortSupportData>())).abbrev_converter as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SortSupportData),
            "::",
            stringify!(abbrev_converter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortSupportData>())).abbrev_abort as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SortSupportData),
            "::",
            stringify!(abbrev_abort)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SortSupportData>())).abbrev_full_comparator as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SortSupportData),
            "::",
            stringify!(abbrev_full_comparator)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_PrepareSortSupportComparisonShim"]
    pub fn PrepareSortSupportComparisonShim(cmpFunc: Oid, ssup: SortSupport);
}
extern "C" {
    #[link_name = "\u{1}_PrepareSortSupportFromOrderingOp"]
    pub fn PrepareSortSupportFromOrderingOp(orderingOp: Oid, ssup: SortSupport);
}
extern "C" {
    #[link_name = "\u{1}_PrepareSortSupportFromIndexRel"]
    pub fn PrepareSortSupportFromIndexRel(indexRel: Relation, strategy: int16, ssup: SortSupport);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleTableSlot {
    pub type_: NodeTag,
    pub tts_isempty: bool,
    pub tts_shouldFree: bool,
    pub tts_shouldFreeMin: bool,
    pub tts_slow: bool,
    pub tts_tuple: HeapTuple,
    pub tts_tupleDescriptor: TupleDesc,
    pub tts_mcxt: MemoryContext,
    pub tts_buffer: Buffer,
    pub tts_nvalid: ::std::os::raw::c_int,
    pub tts_values: *mut Datum,
    pub tts_isnull: *mut bool,
    pub tts_mintuple: MinimalTuple,
    pub tts_minhdr: HeapTupleData,
    pub tts_off: uint32,
    pub tts_fixedTupleDescriptor: bool,
}
#[test]
fn bindgen_test_layout_TupleTableSlot() {
    assert_eq!(
        ::std::mem::size_of::<TupleTableSlot>(),
        96usize,
        concat!("Size of: ", stringify!(TupleTableSlot))
    );
    assert_eq!(
        ::std::mem::align_of::<TupleTableSlot>(),
        8usize,
        concat!("Alignment of ", stringify!(TupleTableSlot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_isempty as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_isempty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_shouldFree as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_shouldFree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TupleTableSlot>())).tts_shouldFreeMin as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_shouldFreeMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_slow as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_slow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_tuple as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_tuple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TupleTableSlot>())).tts_tupleDescriptor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_tupleDescriptor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_mcxt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_mcxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_buffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_nvalid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_nvalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_values as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_isnull as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_isnull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_mintuple as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_mintuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_minhdr as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_minhdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleTableSlot>())).tts_off as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_off)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TupleTableSlot>())).tts_fixedTupleDescriptor as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleTableSlot),
            "::",
            stringify!(tts_fixedTupleDescriptor)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_MakeTupleTableSlot"]
    pub fn MakeTupleTableSlot(desc: TupleDesc) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecAllocTableSlot"]
    pub fn ExecAllocTableSlot(tupleTable: *mut *mut List, desc: TupleDesc) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecResetTupleTable"]
    pub fn ExecResetTupleTable(tupleTable: *mut List, shouldFree: bool);
}
extern "C" {
    #[link_name = "\u{1}_MakeSingleTupleTableSlot"]
    pub fn MakeSingleTupleTableSlot(tupdesc: TupleDesc) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecDropSingleTupleTableSlot"]
    pub fn ExecDropSingleTupleTableSlot(slot: *mut TupleTableSlot);
}
extern "C" {
    #[link_name = "\u{1}_ExecSetSlotDescriptor"]
    pub fn ExecSetSlotDescriptor(slot: *mut TupleTableSlot, tupdesc: TupleDesc);
}
extern "C" {
    #[link_name = "\u{1}_ExecStoreTuple"]
    pub fn ExecStoreTuple(
        tuple: HeapTuple,
        slot: *mut TupleTableSlot,
        buffer: Buffer,
        shouldFree: bool,
    ) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecStoreMinimalTuple"]
    pub fn ExecStoreMinimalTuple(
        mtup: MinimalTuple,
        slot: *mut TupleTableSlot,
        shouldFree: bool,
    ) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecClearTuple"]
    pub fn ExecClearTuple(slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecStoreVirtualTuple"]
    pub fn ExecStoreVirtualTuple(slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecStoreAllNullTuple"]
    pub fn ExecStoreAllNullTuple(slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecCopySlotTuple"]
    pub fn ExecCopySlotTuple(slot: *mut TupleTableSlot) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_ExecCopySlotMinimalTuple"]
    pub fn ExecCopySlotMinimalTuple(slot: *mut TupleTableSlot) -> MinimalTuple;
}
extern "C" {
    #[link_name = "\u{1}_ExecFetchSlotTuple"]
    pub fn ExecFetchSlotTuple(slot: *mut TupleTableSlot) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_ExecFetchSlotMinimalTuple"]
    pub fn ExecFetchSlotMinimalTuple(slot: *mut TupleTableSlot) -> MinimalTuple;
}
extern "C" {
    #[link_name = "\u{1}_ExecFetchSlotTupleDatum"]
    pub fn ExecFetchSlotTupleDatum(slot: *mut TupleTableSlot) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ExecMaterializeSlot"]
    pub fn ExecMaterializeSlot(slot: *mut TupleTableSlot) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_ExecCopySlot"]
    pub fn ExecCopySlot(
        dstslot: *mut TupleTableSlot,
        srcslot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_slot_getattr"]
    pub fn slot_getattr(
        slot: *mut TupleTableSlot,
        attnum: ::std::os::raw::c_int,
        isnull: *mut bool,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_slot_getallattrs"]
    pub fn slot_getallattrs(slot: *mut TupleTableSlot);
}
extern "C" {
    #[link_name = "\u{1}_slot_getsomeattrs"]
    pub fn slot_getsomeattrs(slot: *mut TupleTableSlot, attnum: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_slot_attisnull"]
    pub fn slot_attisnull(slot: *mut TupleTableSlot, attnum: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_slot_getsysattr"]
    pub fn slot_getsysattr(
        slot: *mut TupleTableSlot,
        attnum: ::std::os::raw::c_int,
        value: *mut Datum,
        isnull: *mut bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_slot_getmissingattrs"]
    pub fn slot_getmissingattrs(
        slot: *mut TupleTableSlot,
        startAttNum: ::std::os::raw::c_int,
        lastAttNum: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplestorestate {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_begin_heap"]
    pub fn tuplestore_begin_heap(
        randomAccess: bool,
        interXact: bool,
        maxKBytes: ::std::os::raw::c_int,
    ) -> *mut Tuplestorestate;
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_set_eflags"]
    pub fn tuplestore_set_eflags(state: *mut Tuplestorestate, eflags: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_puttupleslot"]
    pub fn tuplestore_puttupleslot(state: *mut Tuplestorestate, slot: *mut TupleTableSlot);
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_puttuple"]
    pub fn tuplestore_puttuple(state: *mut Tuplestorestate, tuple: HeapTuple);
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_putvalues"]
    pub fn tuplestore_putvalues(
        state: *mut Tuplestorestate,
        tdesc: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_alloc_read_pointer"]
    pub fn tuplestore_alloc_read_pointer(
        state: *mut Tuplestorestate,
        eflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_select_read_pointer"]
    pub fn tuplestore_select_read_pointer(state: *mut Tuplestorestate, ptr: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_copy_read_pointer"]
    pub fn tuplestore_copy_read_pointer(
        state: *mut Tuplestorestate,
        srcptr: ::std::os::raw::c_int,
        destptr: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_trim"]
    pub fn tuplestore_trim(state: *mut Tuplestorestate);
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_in_memory"]
    pub fn tuplestore_in_memory(state: *mut Tuplestorestate) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_gettupleslot"]
    pub fn tuplestore_gettupleslot(
        state: *mut Tuplestorestate,
        forward: bool,
        copy: bool,
        slot: *mut TupleTableSlot,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_advance"]
    pub fn tuplestore_advance(state: *mut Tuplestorestate, forward: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_skiptuples"]
    pub fn tuplestore_skiptuples(
        state: *mut Tuplestorestate,
        ntuples: int64,
        forward: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_tuple_count"]
    pub fn tuplestore_tuple_count(state: *mut Tuplestorestate) -> int64;
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_ateof"]
    pub fn tuplestore_ateof(state: *mut Tuplestorestate) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_rescan"]
    pub fn tuplestore_rescan(state: *mut Tuplestorestate);
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_clear"]
    pub fn tuplestore_clear(state: *mut Tuplestorestate);
}
extern "C" {
    #[link_name = "\u{1}_tuplestore_end"]
    pub fn tuplestore_end(state: *mut Tuplestorestate);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexTupleData {
    pub t_tid: ItemPointerData,
    pub t_info: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_IndexTupleData() {
    assert_eq!(
        ::std::mem::size_of::<IndexTupleData>(),
        8usize,
        concat!("Size of: ", stringify!(IndexTupleData))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexTupleData>(),
        2usize,
        concat!("Alignment of ", stringify!(IndexTupleData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexTupleData>())).t_tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexTupleData),
            "::",
            stringify!(t_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexTupleData>())).t_info as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexTupleData),
            "::",
            stringify!(t_info)
        )
    );
}
pub type IndexTuple = *mut IndexTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexAttributeBitMapData {
    pub bits: [bits8; 4usize],
}
#[test]
fn bindgen_test_layout_IndexAttributeBitMapData() {
    assert_eq!(
        ::std::mem::size_of::<IndexAttributeBitMapData>(),
        4usize,
        concat!("Size of: ", stringify!(IndexAttributeBitMapData))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexAttributeBitMapData>(),
        1usize,
        concat!("Alignment of ", stringify!(IndexAttributeBitMapData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexAttributeBitMapData>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexAttributeBitMapData),
            "::",
            stringify!(bits)
        )
    );
}
pub type IndexAttributeBitMap = *mut IndexAttributeBitMapData;
extern "C" {
    #[link_name = "\u{1}_index_form_tuple"]
    pub fn index_form_tuple(
        tupleDescriptor: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    ) -> IndexTuple;
}
extern "C" {
    #[link_name = "\u{1}_nocache_index_getattr"]
    pub fn nocache_index_getattr(
        tup: IndexTuple,
        attnum: ::std::os::raw::c_int,
        tupleDesc: TupleDesc,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_index_deform_tuple"]
    pub fn index_deform_tuple(
        tup: IndexTuple,
        tupleDescriptor: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_CopyIndexTuple"]
    pub fn CopyIndexTuple(source: IndexTuple) -> IndexTuple;
}
extern "C" {
    #[link_name = "\u{1}_index_truncate_tuple"]
    pub fn index_truncate_tuple(
        sourceDescriptor: TupleDesc,
        source: IndexTuple,
        leavenatts: ::std::os::raw::c_int,
    ) -> IndexTuple;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplesortstate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sharedsort {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortCoordinateData {
    pub isWorker: bool,
    pub nParticipants: ::std::os::raw::c_int,
    pub sharedsort: *mut Sharedsort,
}
#[test]
fn bindgen_test_layout_SortCoordinateData() {
    assert_eq!(
        ::std::mem::size_of::<SortCoordinateData>(),
        16usize,
        concat!("Size of: ", stringify!(SortCoordinateData))
    );
    assert_eq!(
        ::std::mem::align_of::<SortCoordinateData>(),
        8usize,
        concat!("Alignment of ", stringify!(SortCoordinateData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortCoordinateData>())).isWorker as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SortCoordinateData),
            "::",
            stringify!(isWorker)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SortCoordinateData>())).nParticipants as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SortCoordinateData),
            "::",
            stringify!(nParticipants)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortCoordinateData>())).sharedsort as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SortCoordinateData),
            "::",
            stringify!(sharedsort)
        )
    );
}
pub type SortCoordinate = *mut SortCoordinateData;
pub const TuplesortMethod_SORT_TYPE_STILL_IN_PROGRESS: TuplesortMethod = 0;
pub const TuplesortMethod_SORT_TYPE_TOP_N_HEAPSORT: TuplesortMethod = 1;
pub const TuplesortMethod_SORT_TYPE_QUICKSORT: TuplesortMethod = 2;
pub const TuplesortMethod_SORT_TYPE_EXTERNAL_SORT: TuplesortMethod = 3;
pub const TuplesortMethod_SORT_TYPE_EXTERNAL_MERGE: TuplesortMethod = 4;
pub type TuplesortMethod = u32;
pub const TuplesortSpaceType_SORT_SPACE_TYPE_DISK: TuplesortSpaceType = 0;
pub const TuplesortSpaceType_SORT_SPACE_TYPE_MEMORY: TuplesortSpaceType = 1;
pub type TuplesortSpaceType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TuplesortInstrumentation {
    pub sortMethod: TuplesortMethod,
    pub spaceType: TuplesortSpaceType,
    pub spaceUsed: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_TuplesortInstrumentation() {
    assert_eq!(
        ::std::mem::size_of::<TuplesortInstrumentation>(),
        16usize,
        concat!("Size of: ", stringify!(TuplesortInstrumentation))
    );
    assert_eq!(
        ::std::mem::align_of::<TuplesortInstrumentation>(),
        8usize,
        concat!("Alignment of ", stringify!(TuplesortInstrumentation))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TuplesortInstrumentation>())).sortMethod as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TuplesortInstrumentation),
            "::",
            stringify!(sortMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TuplesortInstrumentation>())).spaceType as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TuplesortInstrumentation),
            "::",
            stringify!(spaceType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TuplesortInstrumentation>())).spaceUsed as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TuplesortInstrumentation),
            "::",
            stringify!(spaceUsed)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_begin_heap"]
    pub fn tuplesort_begin_heap(
        tupDesc: TupleDesc,
        nkeys: ::std::os::raw::c_int,
        attNums: *mut AttrNumber,
        sortOperators: *mut Oid,
        sortCollations: *mut Oid,
        nullsFirstFlags: *mut bool,
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        randomAccess: bool,
    ) -> *mut Tuplesortstate;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_begin_cluster"]
    pub fn tuplesort_begin_cluster(
        tupDesc: TupleDesc,
        indexRel: Relation,
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        randomAccess: bool,
    ) -> *mut Tuplesortstate;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_begin_index_btree"]
    pub fn tuplesort_begin_index_btree(
        heapRel: Relation,
        indexRel: Relation,
        enforceUnique: bool,
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        randomAccess: bool,
    ) -> *mut Tuplesortstate;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_begin_index_hash"]
    pub fn tuplesort_begin_index_hash(
        heapRel: Relation,
        indexRel: Relation,
        high_mask: uint32,
        low_mask: uint32,
        max_buckets: uint32,
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        randomAccess: bool,
    ) -> *mut Tuplesortstate;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_begin_datum"]
    pub fn tuplesort_begin_datum(
        datumType: Oid,
        sortOperator: Oid,
        sortCollation: Oid,
        nullsFirstFlag: bool,
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        randomAccess: bool,
    ) -> *mut Tuplesortstate;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_set_bound"]
    pub fn tuplesort_set_bound(state: *mut Tuplesortstate, bound: int64);
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_puttupleslot"]
    pub fn tuplesort_puttupleslot(state: *mut Tuplesortstate, slot: *mut TupleTableSlot);
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_putheaptuple"]
    pub fn tuplesort_putheaptuple(state: *mut Tuplesortstate, tup: HeapTuple);
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_putindextuplevalues"]
    pub fn tuplesort_putindextuplevalues(
        state: *mut Tuplesortstate,
        rel: Relation,
        self_: ItemPointer,
        values: *mut Datum,
        isnull: *mut bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_putdatum"]
    pub fn tuplesort_putdatum(state: *mut Tuplesortstate, val: Datum, isNull: bool);
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_performsort"]
    pub fn tuplesort_performsort(state: *mut Tuplesortstate);
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_gettupleslot"]
    pub fn tuplesort_gettupleslot(
        state: *mut Tuplesortstate,
        forward: bool,
        copy: bool,
        slot: *mut TupleTableSlot,
        abbrev: *mut Datum,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_getheaptuple"]
    pub fn tuplesort_getheaptuple(state: *mut Tuplesortstate, forward: bool) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_getindextuple"]
    pub fn tuplesort_getindextuple(state: *mut Tuplesortstate, forward: bool) -> IndexTuple;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_getdatum"]
    pub fn tuplesort_getdatum(
        state: *mut Tuplesortstate,
        forward: bool,
        val: *mut Datum,
        isNull: *mut bool,
        abbrev: *mut Datum,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_skiptuples"]
    pub fn tuplesort_skiptuples(state: *mut Tuplesortstate, ntuples: int64, forward: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_end"]
    pub fn tuplesort_end(state: *mut Tuplesortstate);
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_get_stats"]
    pub fn tuplesort_get_stats(state: *mut Tuplesortstate, stats: *mut TuplesortInstrumentation);
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_method_name"]
    pub fn tuplesort_method_name(m: TuplesortMethod) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_space_type_name"]
    pub fn tuplesort_space_type_name(t: TuplesortSpaceType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_merge_order"]
    pub fn tuplesort_merge_order(allowedMem: int64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_estimate_shared"]
    pub fn tuplesort_estimate_shared(nworkers: ::std::os::raw::c_int) -> Size;
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_initialize_shared"]
    pub fn tuplesort_initialize_shared(
        shared: *mut Sharedsort,
        nWorkers: ::std::os::raw::c_int,
        seg: *mut dsm_segment,
    );
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_attach_shared"]
    pub fn tuplesort_attach_shared(shared: *mut Sharedsort, seg: *mut dsm_segment);
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_rescan"]
    pub fn tuplesort_rescan(state: *mut Tuplesortstate);
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_markpos"]
    pub fn tuplesort_markpos(state: *mut Tuplesortstate);
}
extern "C" {
    #[link_name = "\u{1}_tuplesort_restorepos"]
    pub fn tuplesort_restorepos(state: *mut Tuplesortstate);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proclist_node {
    pub next: ::std::os::raw::c_int,
    pub prev: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_proclist_node() {
    assert_eq!(
        ::std::mem::size_of::<proclist_node>(),
        8usize,
        concat!("Size of: ", stringify!(proclist_node))
    );
    assert_eq!(
        ::std::mem::align_of::<proclist_node>(),
        4usize,
        concat!("Alignment of ", stringify!(proclist_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<proclist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proclist_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<proclist_node>())).prev as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proclist_node),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proclist_head {
    pub head: ::std::os::raw::c_int,
    pub tail: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_proclist_head() {
    assert_eq!(
        ::std::mem::size_of::<proclist_head>(),
        8usize,
        concat!("Size of: ", stringify!(proclist_head))
    );
    assert_eq!(
        ::std::mem::align_of::<proclist_head>(),
        4usize,
        concat!("Alignment of ", stringify!(proclist_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<proclist_head>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proclist_head),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<proclist_head>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proclist_head),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proclist_mutable_iter {
    pub cur: ::std::os::raw::c_int,
    pub next: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_proclist_mutable_iter() {
    assert_eq!(
        ::std::mem::size_of::<proclist_mutable_iter>(),
        8usize,
        concat!("Size of: ", stringify!(proclist_mutable_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<proclist_mutable_iter>(),
        4usize,
        concat!("Alignment of ", stringify!(proclist_mutable_iter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<proclist_mutable_iter>())).cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proclist_mutable_iter),
            "::",
            stringify!(cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<proclist_mutable_iter>())).next as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proclist_mutable_iter),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConditionVariable {
    pub mutex: slock_t,
    pub wakeup: proclist_head,
}
#[test]
fn bindgen_test_layout_ConditionVariable() {
    assert_eq!(
        ::std::mem::size_of::<ConditionVariable>(),
        12usize,
        concat!("Size of: ", stringify!(ConditionVariable))
    );
    assert_eq!(
        ::std::mem::align_of::<ConditionVariable>(),
        4usize,
        concat!("Alignment of ", stringify!(ConditionVariable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConditionVariable>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConditionVariable),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ConditionVariable>())).wakeup as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ConditionVariable),
            "::",
            stringify!(wakeup)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ConditionVariableInit"]
    pub fn ConditionVariableInit(cv: *mut ConditionVariable);
}
extern "C" {
    #[link_name = "\u{1}_ConditionVariableSleep"]
    pub fn ConditionVariableSleep(cv: *mut ConditionVariable, wait_event_info: uint32);
}
extern "C" {
    #[link_name = "\u{1}_ConditionVariableCancelSleep"]
    pub fn ConditionVariableCancelSleep();
}
extern "C" {
    #[link_name = "\u{1}_ConditionVariablePrepareToSleep"]
    pub fn ConditionVariablePrepareToSleep(cv: *mut ConditionVariable);
}
extern "C" {
    #[link_name = "\u{1}_ConditionVariableSignal"]
    pub fn ConditionVariableSignal(cv: *mut ConditionVariable);
}
extern "C" {
    #[link_name = "\u{1}_ConditionVariableBroadcast"]
    pub fn ConditionVariableBroadcast(cv: *mut ConditionVariable);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelHashJoinState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep {
    _unused: [u8; 0],
}
pub type ExprStateEvalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        expression: *mut ExprState,
        econtext: *mut ExprContext,
        isNull: *mut bool,
    ) -> Datum,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprState {
    pub tag: Node,
    pub flags: uint8,
    pub resnull: bool,
    pub resvalue: Datum,
    pub resultslot: *mut TupleTableSlot,
    pub steps: *mut ExprEvalStep,
    pub evalfunc: ExprStateEvalFunc,
    pub expr: *mut Expr,
    pub evalfunc_private: *mut ::std::os::raw::c_void,
    pub steps_len: ::std::os::raw::c_int,
    pub steps_alloc: ::std::os::raw::c_int,
    pub parent: *mut PlanState,
    pub ext_params: ParamListInfo,
    pub innermost_caseval: *mut Datum,
    pub innermost_casenull: *mut bool,
    pub innermost_domainval: *mut Datum,
    pub innermost_domainnull: *mut bool,
}
#[test]
fn bindgen_test_layout_ExprState() {
    assert_eq!(
        ::std::mem::size_of::<ExprState>(),
        112usize,
        concat!("Size of: ", stringify!(ExprState))
    );
    assert_eq!(
        ::std::mem::align_of::<ExprState>(),
        8usize,
        concat!("Alignment of ", stringify!(ExprState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).resnull as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(resnull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).resvalue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(resvalue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).resultslot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(resultslot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).steps as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(steps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).evalfunc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(evalfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).expr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(expr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).evalfunc_private as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(evalfunc_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).steps_len as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(steps_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).steps_alloc as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(steps_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).parent as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).ext_params as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(ext_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).innermost_caseval as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(innermost_caseval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).innermost_casenull as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(innermost_casenull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).innermost_domainval as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(innermost_domainval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprState>())).innermost_domainnull as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprState),
            "::",
            stringify!(innermost_domainnull)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexInfo {
    pub type_: NodeTag,
    pub ii_NumIndexAttrs: ::std::os::raw::c_int,
    pub ii_NumIndexKeyAttrs: ::std::os::raw::c_int,
    pub ii_IndexAttrNumbers: [AttrNumber; 32usize],
    pub ii_Expressions: *mut List,
    pub ii_ExpressionsState: *mut List,
    pub ii_Predicate: *mut List,
    pub ii_PredicateState: *mut ExprState,
    pub ii_ExclusionOps: *mut Oid,
    pub ii_ExclusionProcs: *mut Oid,
    pub ii_ExclusionStrats: *mut uint16,
    pub ii_UniqueOps: *mut Oid,
    pub ii_UniqueProcs: *mut Oid,
    pub ii_UniqueStrats: *mut uint16,
    pub ii_Unique: bool,
    pub ii_ReadyForInserts: bool,
    pub ii_Concurrent: bool,
    pub ii_BrokenHotChain: bool,
    pub ii_ParallelWorkers: ::std::os::raw::c_int,
    pub ii_Am: Oid,
    pub ii_AmCache: *mut ::std::os::raw::c_void,
    pub ii_Context: MemoryContext,
}
#[test]
fn bindgen_test_layout_IndexInfo() {
    assert_eq!(
        ::std::mem::size_of::<IndexInfo>(),
        192usize,
        concat!("Size of: ", stringify!(IndexInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_NumIndexAttrs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_NumIndexAttrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_NumIndexKeyAttrs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_NumIndexKeyAttrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_IndexAttrNumbers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_IndexAttrNumbers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_Expressions as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_Expressions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_ExpressionsState as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_ExpressionsState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_Predicate as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_Predicate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_PredicateState as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_PredicateState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_ExclusionOps as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_ExclusionOps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_ExclusionProcs as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_ExclusionProcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_ExclusionStrats as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_ExclusionStrats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_UniqueOps as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_UniqueOps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_UniqueProcs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_UniqueProcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_UniqueStrats as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_UniqueStrats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_Unique as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_Unique)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_ReadyForInserts as *const _ as usize },
        161usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_ReadyForInserts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_Concurrent as *const _ as usize },
        162usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_Concurrent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_BrokenHotChain as *const _ as usize },
        163usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_BrokenHotChain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_ParallelWorkers as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_ParallelWorkers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_Am as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_Am)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_AmCache as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_AmCache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexInfo>())).ii_Context as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexInfo),
            "::",
            stringify!(ii_Context)
        )
    );
}
pub type ExprContextCallbackFunction = ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprContext_CB {
    pub next: *mut ExprContext_CB,
    pub function: ExprContextCallbackFunction,
    pub arg: Datum,
}
#[test]
fn bindgen_test_layout_ExprContext_CB() {
    assert_eq!(
        ::std::mem::size_of::<ExprContext_CB>(),
        24usize,
        concat!("Size of: ", stringify!(ExprContext_CB))
    );
    assert_eq!(
        ::std::mem::align_of::<ExprContext_CB>(),
        8usize,
        concat!("Alignment of ", stringify!(ExprContext_CB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext_CB>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext_CB),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext_CB>())).function as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext_CB),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext_CB>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext_CB),
            "::",
            stringify!(arg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprContext {
    pub type_: NodeTag,
    pub ecxt_scantuple: *mut TupleTableSlot,
    pub ecxt_innertuple: *mut TupleTableSlot,
    pub ecxt_outertuple: *mut TupleTableSlot,
    pub ecxt_per_query_memory: MemoryContext,
    pub ecxt_per_tuple_memory: MemoryContext,
    pub ecxt_param_exec_vals: *mut ParamExecData,
    pub ecxt_param_list_info: ParamListInfo,
    pub ecxt_aggvalues: *mut Datum,
    pub ecxt_aggnulls: *mut bool,
    pub caseValue_datum: Datum,
    pub caseValue_isNull: bool,
    pub domainValue_datum: Datum,
    pub domainValue_isNull: bool,
    pub ecxt_estate: *mut EState,
    pub ecxt_callbacks: *mut ExprContext_CB,
}
#[test]
fn bindgen_test_layout_ExprContext() {
    assert_eq!(
        ::std::mem::size_of::<ExprContext>(),
        128usize,
        concat!("Size of: ", stringify!(ExprContext))
    );
    assert_eq!(
        ::std::mem::align_of::<ExprContext>(),
        8usize,
        concat!("Alignment of ", stringify!(ExprContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).ecxt_scantuple as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(ecxt_scantuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).ecxt_innertuple as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(ecxt_innertuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).ecxt_outertuple as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(ecxt_outertuple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ExprContext>())).ecxt_per_query_memory as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(ecxt_per_query_memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ExprContext>())).ecxt_per_tuple_memory as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(ecxt_per_tuple_memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ExprContext>())).ecxt_param_exec_vals as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(ecxt_param_exec_vals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ExprContext>())).ecxt_param_list_info as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(ecxt_param_list_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).ecxt_aggvalues as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(ecxt_aggvalues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).ecxt_aggnulls as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(ecxt_aggnulls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).caseValue_datum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(caseValue_datum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).caseValue_isNull as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(caseValue_isNull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).domainValue_datum as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(domainValue_datum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).domainValue_isNull as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(domainValue_isNull)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).ecxt_estate as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(ecxt_estate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExprContext>())).ecxt_callbacks as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ExprContext),
            "::",
            stringify!(ecxt_callbacks)
        )
    );
}
pub const ExprDoneCond_ExprSingleResult: ExprDoneCond = 0;
pub const ExprDoneCond_ExprMultipleResult: ExprDoneCond = 1;
pub const ExprDoneCond_ExprEndResult: ExprDoneCond = 2;
pub type ExprDoneCond = u32;
pub const SetFunctionReturnMode_SFRM_ValuePerCall: SetFunctionReturnMode = 1;
pub const SetFunctionReturnMode_SFRM_Materialize: SetFunctionReturnMode = 2;
pub const SetFunctionReturnMode_SFRM_Materialize_Random: SetFunctionReturnMode = 4;
pub const SetFunctionReturnMode_SFRM_Materialize_Preferred: SetFunctionReturnMode = 8;
pub type SetFunctionReturnMode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReturnSetInfo {
    pub type_: NodeTag,
    pub econtext: *mut ExprContext,
    pub expectedDesc: TupleDesc,
    pub allowedModes: ::std::os::raw::c_int,
    pub returnMode: SetFunctionReturnMode,
    pub isDone: ExprDoneCond,
    pub setResult: *mut Tuplestorestate,
    pub setDesc: TupleDesc,
}
#[test]
fn bindgen_test_layout_ReturnSetInfo() {
    assert_eq!(
        ::std::mem::size_of::<ReturnSetInfo>(),
        56usize,
        concat!("Size of: ", stringify!(ReturnSetInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ReturnSetInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ReturnSetInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReturnSetInfo>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ReturnSetInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReturnSetInfo>())).econtext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ReturnSetInfo),
            "::",
            stringify!(econtext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReturnSetInfo>())).expectedDesc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ReturnSetInfo),
            "::",
            stringify!(expectedDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReturnSetInfo>())).allowedModes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ReturnSetInfo),
            "::",
            stringify!(allowedModes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReturnSetInfo>())).returnMode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ReturnSetInfo),
            "::",
            stringify!(returnMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReturnSetInfo>())).isDone as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ReturnSetInfo),
            "::",
            stringify!(isDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReturnSetInfo>())).setResult as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ReturnSetInfo),
            "::",
            stringify!(setResult)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ReturnSetInfo>())).setDesc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ReturnSetInfo),
            "::",
            stringify!(setDesc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectionInfo {
    pub type_: NodeTag,
    pub pi_state: ExprState,
    pub pi_exprContext: *mut ExprContext,
}
#[test]
fn bindgen_test_layout_ProjectionInfo() {
    assert_eq!(
        ::std::mem::size_of::<ProjectionInfo>(),
        128usize,
        concat!("Size of: ", stringify!(ProjectionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ProjectionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ProjectionInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProjectionInfo>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProjectionInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProjectionInfo>())).pi_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ProjectionInfo),
            "::",
            stringify!(pi_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProjectionInfo>())).pi_exprContext as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ProjectionInfo),
            "::",
            stringify!(pi_exprContext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JunkFilter {
    pub type_: NodeTag,
    pub jf_targetList: *mut List,
    pub jf_cleanTupType: TupleDesc,
    pub jf_cleanMap: *mut AttrNumber,
    pub jf_resultSlot: *mut TupleTableSlot,
    pub jf_junkAttNo: AttrNumber,
}
#[test]
fn bindgen_test_layout_JunkFilter() {
    assert_eq!(
        ::std::mem::size_of::<JunkFilter>(),
        48usize,
        concat!("Size of: ", stringify!(JunkFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<JunkFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(JunkFilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JunkFilter>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JunkFilter),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JunkFilter>())).jf_targetList as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JunkFilter),
            "::",
            stringify!(jf_targetList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JunkFilter>())).jf_cleanTupType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JunkFilter),
            "::",
            stringify!(jf_cleanTupType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JunkFilter>())).jf_cleanMap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JunkFilter),
            "::",
            stringify!(jf_cleanMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JunkFilter>())).jf_resultSlot as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JunkFilter),
            "::",
            stringify!(jf_resultSlot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JunkFilter>())).jf_junkAttNo as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JunkFilter),
            "::",
            stringify!(jf_junkAttNo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictSetState {
    pub type_: NodeTag,
    pub oc_ProjInfo: *mut ProjectionInfo,
    pub oc_ProjTupdesc: TupleDesc,
    pub oc_WhereClause: *mut ExprState,
}
#[test]
fn bindgen_test_layout_OnConflictSetState() {
    assert_eq!(
        ::std::mem::size_of::<OnConflictSetState>(),
        32usize,
        concat!("Size of: ", stringify!(OnConflictSetState))
    );
    assert_eq!(
        ::std::mem::align_of::<OnConflictSetState>(),
        8usize,
        concat!("Alignment of ", stringify!(OnConflictSetState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictSetState>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictSetState),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OnConflictSetState>())).oc_ProjInfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictSetState),
            "::",
            stringify!(oc_ProjInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnConflictSetState>())).oc_ProjTupdesc as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictSetState),
            "::",
            stringify!(oc_ProjTupdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<OnConflictSetState>())).oc_WhereClause as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OnConflictSetState),
            "::",
            stringify!(oc_WhereClause)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResultRelInfo {
    pub type_: NodeTag,
    pub ri_RangeTableIndex: Index,
    pub ri_RelationDesc: Relation,
    pub ri_NumIndices: ::std::os::raw::c_int,
    pub ri_IndexRelationDescs: RelationPtr,
    pub ri_IndexRelationInfo: *mut *mut IndexInfo,
    pub ri_TrigDesc: *mut TriggerDesc,
    pub ri_TrigFunctions: *mut FmgrInfo,
    pub ri_TrigWhenExprs: *mut *mut ExprState,
    pub ri_TrigInstrument: *mut Instrumentation,
    pub ri_FdwRoutine: *mut FdwRoutine,
    pub ri_FdwState: *mut ::std::os::raw::c_void,
    pub ri_usesFdwDirectModify: bool,
    pub ri_WithCheckOptions: *mut List,
    pub ri_WithCheckOptionExprs: *mut List,
    pub ri_ConstraintExprs: *mut *mut ExprState,
    pub ri_junkFilter: *mut JunkFilter,
    pub ri_returningList: *mut List,
    pub ri_projectReturning: *mut ProjectionInfo,
    pub ri_onConflictArbiterIndexes: *mut List,
    pub ri_onConflict: *mut OnConflictSetState,
    pub ri_PartitionCheck: *mut List,
    pub ri_PartitionCheckExpr: *mut ExprState,
    pub ri_PartitionRoot: Relation,
    pub ri_PartitionReadyForRouting: bool,
}
#[test]
fn bindgen_test_layout_ResultRelInfo() {
    assert_eq!(
        ::std::mem::size_of::<ResultRelInfo>(),
        192usize,
        concat!("Size of: ", stringify!(ResultRelInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ResultRelInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ResultRelInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ResultRelInfo>())).ri_RangeTableIndex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_RangeTableIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_RelationDesc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_RelationDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_NumIndices as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_NumIndices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ResultRelInfo>())).ri_IndexRelationDescs as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_IndexRelationDescs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ResultRelInfo>())).ri_IndexRelationInfo as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_IndexRelationInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_TrigDesc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_TrigDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_TrigFunctions as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_TrigFunctions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_TrigWhenExprs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_TrigWhenExprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_TrigInstrument as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_TrigInstrument)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_FdwRoutine as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_FdwRoutine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_FdwState as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_FdwState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ResultRelInfo>())).ri_usesFdwDirectModify as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_usesFdwDirectModify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ResultRelInfo>())).ri_WithCheckOptions as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_WithCheckOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ResultRelInfo>())).ri_WithCheckOptionExprs as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_WithCheckOptionExprs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ResultRelInfo>())).ri_ConstraintExprs as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_ConstraintExprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_junkFilter as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_junkFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_returningList as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_returningList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ResultRelInfo>())).ri_projectReturning as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_projectReturning)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ResultRelInfo>())).ri_onConflictArbiterIndexes as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_onConflictArbiterIndexes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_onConflict as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_onConflict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_PartitionCheck as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_PartitionCheck)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ResultRelInfo>())).ri_PartitionCheckExpr as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_PartitionCheckExpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultRelInfo>())).ri_PartitionRoot as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_PartitionRoot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ResultRelInfo>())).ri_PartitionReadyForRouting as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultRelInfo),
            "::",
            stringify!(ri_PartitionReadyForRouting)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EState {
    pub type_: NodeTag,
    pub es_direction: ScanDirection,
    pub es_snapshot: Snapshot,
    pub es_crosscheck_snapshot: Snapshot,
    pub es_range_table: *mut List,
    pub es_plannedstmt: *mut PlannedStmt,
    pub es_sourceText: *const ::std::os::raw::c_char,
    pub es_junkFilter: *mut JunkFilter,
    pub es_output_cid: CommandId,
    pub es_result_relations: *mut ResultRelInfo,
    pub es_num_result_relations: ::std::os::raw::c_int,
    pub es_result_relation_info: *mut ResultRelInfo,
    pub es_root_result_relations: *mut ResultRelInfo,
    pub es_num_root_result_relations: ::std::os::raw::c_int,
    pub es_tuple_routing_result_relations: *mut List,
    pub es_trig_target_relations: *mut List,
    pub es_trig_tuple_slot: *mut TupleTableSlot,
    pub es_trig_oldtup_slot: *mut TupleTableSlot,
    pub es_trig_newtup_slot: *mut TupleTableSlot,
    pub es_param_list_info: ParamListInfo,
    pub es_param_exec_vals: *mut ParamExecData,
    pub es_queryEnv: *mut QueryEnvironment,
    pub es_query_cxt: MemoryContext,
    pub es_tupleTable: *mut List,
    pub es_rowMarks: *mut List,
    pub es_processed: uint64,
    pub es_lastoid: Oid,
    pub es_top_eflags: ::std::os::raw::c_int,
    pub es_instrument: ::std::os::raw::c_int,
    pub es_finished: bool,
    pub es_exprcontexts: *mut List,
    pub es_subplanstates: *mut List,
    pub es_auxmodifytables: *mut List,
    pub es_per_tuple_exprcontext: *mut ExprContext,
    pub es_epqTuple: *mut HeapTuple,
    pub es_epqTupleSet: *mut bool,
    pub es_epqScanDone: *mut bool,
    pub es_use_parallel_mode: bool,
    pub es_query_dsa: *mut dsa_area,
    pub es_jit_flags: ::std::os::raw::c_int,
    pub es_jit: *mut JitContext,
    pub es_jit_worker_instr: *mut JitInstrumentation,
}
#[test]
fn bindgen_test_layout_EState() {
    assert_eq!(
        ::std::mem::size_of::<EState>(),
        312usize,
        concat!("Size of: ", stringify!(EState))
    );
    assert_eq!(
        ::std::mem::align_of::<EState>(),
        8usize,
        concat!("Alignment of ", stringify!(EState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_snapshot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_snapshot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_crosscheck_snapshot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_crosscheck_snapshot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_range_table as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_range_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_plannedstmt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_plannedstmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_sourceText as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_sourceText)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_junkFilter as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_junkFilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_output_cid as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_output_cid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_result_relations as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_result_relations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_num_result_relations as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_num_result_relations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_result_relation_info as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_result_relation_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_root_result_relations as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_root_result_relations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EState>())).es_num_root_result_relations as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_num_root_result_relations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EState>())).es_tuple_routing_result_relations as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_tuple_routing_result_relations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_trig_target_relations as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_trig_target_relations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_trig_tuple_slot as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_trig_tuple_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_trig_oldtup_slot as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_trig_oldtup_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_trig_newtup_slot as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_trig_newtup_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_param_list_info as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_param_list_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_param_exec_vals as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_param_exec_vals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_queryEnv as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_queryEnv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_query_cxt as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_query_cxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_tupleTable as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_tupleTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_rowMarks as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_rowMarks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_processed as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_processed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_lastoid as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_lastoid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_top_eflags as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_top_eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_instrument as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_instrument)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_finished as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_finished)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_exprcontexts as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_exprcontexts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_subplanstates as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_subplanstates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_auxmodifytables as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_auxmodifytables)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_per_tuple_exprcontext as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_per_tuple_exprcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_epqTuple as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_epqTuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_epqTupleSet as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_epqTupleSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_epqScanDone as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_epqScanDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_use_parallel_mode as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_use_parallel_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_query_dsa as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_query_dsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_jit_flags as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_jit_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_jit as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_jit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EState>())).es_jit_worker_instr as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(EState),
            "::",
            stringify!(es_jit_worker_instr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecRowMark {
    pub relation: Relation,
    pub relid: Oid,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub ermActive: bool,
    pub curCtid: ItemPointerData,
    pub ermExtra: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ExecRowMark() {
    assert_eq!(
        ::std::mem::size_of::<ExecRowMark>(),
        56usize,
        concat!("Size of: ", stringify!(ExecRowMark))
    );
    assert_eq!(
        ::std::mem::align_of::<ExecRowMark>(),
        8usize,
        concat!("Alignment of ", stringify!(ExecRowMark))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecRowMark>())).relation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecRowMark),
            "::",
            stringify!(relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecRowMark>())).relid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecRowMark),
            "::",
            stringify!(relid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecRowMark>())).rti as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecRowMark),
            "::",
            stringify!(rti)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecRowMark>())).prti as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecRowMark),
            "::",
            stringify!(prti)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecRowMark>())).rowmarkId as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecRowMark),
            "::",
            stringify!(rowmarkId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecRowMark>())).markType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecRowMark),
            "::",
            stringify!(markType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecRowMark>())).strength as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecRowMark),
            "::",
            stringify!(strength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecRowMark>())).waitPolicy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecRowMark),
            "::",
            stringify!(waitPolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecRowMark>())).ermActive as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecRowMark),
            "::",
            stringify!(ermActive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecRowMark>())).curCtid as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecRowMark),
            "::",
            stringify!(curCtid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecRowMark>())).ermExtra as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecRowMark),
            "::",
            stringify!(ermExtra)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecAuxRowMark {
    pub rowmark: *mut ExecRowMark,
    pub ctidAttNo: AttrNumber,
    pub toidAttNo: AttrNumber,
    pub wholeAttNo: AttrNumber,
}
#[test]
fn bindgen_test_layout_ExecAuxRowMark() {
    assert_eq!(
        ::std::mem::size_of::<ExecAuxRowMark>(),
        16usize,
        concat!("Size of: ", stringify!(ExecAuxRowMark))
    );
    assert_eq!(
        ::std::mem::align_of::<ExecAuxRowMark>(),
        8usize,
        concat!("Alignment of ", stringify!(ExecAuxRowMark))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecAuxRowMark>())).rowmark as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecAuxRowMark),
            "::",
            stringify!(rowmark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecAuxRowMark>())).ctidAttNo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecAuxRowMark),
            "::",
            stringify!(ctidAttNo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecAuxRowMark>())).toidAttNo as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecAuxRowMark),
            "::",
            stringify!(toidAttNo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ExecAuxRowMark>())).wholeAttNo as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ExecAuxRowMark),
            "::",
            stringify!(wholeAttNo)
        )
    );
}
pub type TupleHashEntry = *mut TupleHashEntryData;
pub type TupleHashTable = *mut TupleHashTableData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleHashEntryData {
    pub firstTuple: MinimalTuple,
    pub additional: *mut ::std::os::raw::c_void,
    pub status: uint32,
    pub hash: uint32,
}
#[test]
fn bindgen_test_layout_TupleHashEntryData() {
    assert_eq!(
        ::std::mem::size_of::<TupleHashEntryData>(),
        24usize,
        concat!("Size of: ", stringify!(TupleHashEntryData))
    );
    assert_eq!(
        ::std::mem::align_of::<TupleHashEntryData>(),
        8usize,
        concat!("Alignment of ", stringify!(TupleHashEntryData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashEntryData>())).firstTuple as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashEntryData),
            "::",
            stringify!(firstTuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashEntryData>())).additional as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashEntryData),
            "::",
            stringify!(additional)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashEntryData>())).status as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashEntryData),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashEntryData>())).hash as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashEntryData),
            "::",
            stringify!(hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tuplehash_hash {
    pub size: uint64,
    pub members: uint32,
    pub sizemask: uint32,
    pub grow_threshold: uint32,
    pub data: *mut TupleHashEntryData,
    pub ctx: MemoryContext,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_tuplehash_hash() {
    assert_eq!(
        ::std::mem::size_of::<tuplehash_hash>(),
        48usize,
        concat!("Size of: ", stringify!(tuplehash_hash))
    );
    assert_eq!(
        ::std::mem::align_of::<tuplehash_hash>(),
        8usize,
        concat!("Alignment of ", stringify!(tuplehash_hash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tuplehash_hash>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tuplehash_hash),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tuplehash_hash>())).members as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tuplehash_hash),
            "::",
            stringify!(members)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tuplehash_hash>())).sizemask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tuplehash_hash),
            "::",
            stringify!(sizemask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tuplehash_hash>())).grow_threshold as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tuplehash_hash),
            "::",
            stringify!(grow_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tuplehash_hash>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tuplehash_hash),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tuplehash_hash>())).ctx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tuplehash_hash),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tuplehash_hash>())).private_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tuplehash_hash),
            "::",
            stringify!(private_data)
        )
    );
}
pub const tuplehash_status_tuplehash_EMPTY: tuplehash_status = 0;
pub const tuplehash_status_tuplehash_IN_USE: tuplehash_status = 1;
pub type tuplehash_status = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tuplehash_iterator {
    pub cur: uint32,
    pub end: uint32,
    pub done: bool,
}
#[test]
fn bindgen_test_layout_tuplehash_iterator() {
    assert_eq!(
        ::std::mem::size_of::<tuplehash_iterator>(),
        12usize,
        concat!("Size of: ", stringify!(tuplehash_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<tuplehash_iterator>(),
        4usize,
        concat!("Alignment of ", stringify!(tuplehash_iterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tuplehash_iterator>())).cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tuplehash_iterator),
            "::",
            stringify!(cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tuplehash_iterator>())).end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tuplehash_iterator),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tuplehash_iterator>())).done as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tuplehash_iterator),
            "::",
            stringify!(done)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_tuplehash_create"]
    pub fn tuplehash_create(
        ctx: MemoryContext,
        nelements: uint32,
        private_data: *mut ::std::os::raw::c_void,
    ) -> *mut tuplehash_hash;
}
extern "C" {
    #[link_name = "\u{1}_tuplehash_destroy"]
    pub fn tuplehash_destroy(tb: *mut tuplehash_hash);
}
extern "C" {
    #[link_name = "\u{1}_tuplehash_grow"]
    pub fn tuplehash_grow(tb: *mut tuplehash_hash, newsize: uint32);
}
extern "C" {
    #[link_name = "\u{1}_tuplehash_insert"]
    pub fn tuplehash_insert(
        tb: *mut tuplehash_hash,
        key: MinimalTuple,
        found: *mut bool,
    ) -> *mut TupleHashEntryData;
}
extern "C" {
    #[link_name = "\u{1}_tuplehash_lookup"]
    pub fn tuplehash_lookup(tb: *mut tuplehash_hash, key: MinimalTuple) -> *mut TupleHashEntryData;
}
extern "C" {
    #[link_name = "\u{1}_tuplehash_delete"]
    pub fn tuplehash_delete(tb: *mut tuplehash_hash, key: MinimalTuple) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_tuplehash_start_iterate"]
    pub fn tuplehash_start_iterate(tb: *mut tuplehash_hash, iter: *mut tuplehash_iterator);
}
extern "C" {
    #[link_name = "\u{1}_tuplehash_start_iterate_at"]
    pub fn tuplehash_start_iterate_at(
        tb: *mut tuplehash_hash,
        iter: *mut tuplehash_iterator,
        at: uint32,
    );
}
extern "C" {
    #[link_name = "\u{1}_tuplehash_iterate"]
    pub fn tuplehash_iterate(
        tb: *mut tuplehash_hash,
        iter: *mut tuplehash_iterator,
    ) -> *mut TupleHashEntryData;
}
extern "C" {
    #[link_name = "\u{1}_tuplehash_stat"]
    pub fn tuplehash_stat(tb: *mut tuplehash_hash);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleHashTableData {
    pub hashtab: *mut tuplehash_hash,
    pub numCols: ::std::os::raw::c_int,
    pub keyColIdx: *mut AttrNumber,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_func: *mut ExprState,
    pub tablecxt: MemoryContext,
    pub tempcxt: MemoryContext,
    pub entrysize: Size,
    pub tableslot: *mut TupleTableSlot,
    pub inputslot: *mut TupleTableSlot,
    pub in_hash_funcs: *mut FmgrInfo,
    pub cur_eq_func: *mut ExprState,
    pub hash_iv: uint32,
    pub exprcontext: *mut ExprContext,
}
#[test]
fn bindgen_test_layout_TupleHashTableData() {
    assert_eq!(
        ::std::mem::size_of::<TupleHashTableData>(),
        112usize,
        concat!("Size of: ", stringify!(TupleHashTableData))
    );
    assert_eq!(
        ::std::mem::align_of::<TupleHashTableData>(),
        8usize,
        concat!("Alignment of ", stringify!(TupleHashTableData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).hashtab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(hashtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).numCols as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).keyColIdx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(keyColIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TupleHashTableData>())).tab_hash_funcs as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(tab_hash_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).tab_eq_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(tab_eq_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).tablecxt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(tablecxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).tempcxt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(tempcxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).entrysize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(entrysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).tableslot as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(tableslot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).inputslot as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(inputslot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TupleHashTableData>())).in_hash_funcs as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(in_hash_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).cur_eq_func as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(cur_eq_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).hash_iv as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(hash_iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TupleHashTableData>())).exprcontext as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(TupleHashTableData),
            "::",
            stringify!(exprcontext)
        )
    );
}
pub type TupleHashIterator = tuplehash_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggrefExprState {
    pub type_: NodeTag,
    pub aggref: *mut Aggref,
    pub aggno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AggrefExprState() {
    assert_eq!(
        ::std::mem::size_of::<AggrefExprState>(),
        24usize,
        concat!("Size of: ", stringify!(AggrefExprState))
    );
    assert_eq!(
        ::std::mem::align_of::<AggrefExprState>(),
        8usize,
        concat!("Alignment of ", stringify!(AggrefExprState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggrefExprState>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AggrefExprState),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggrefExprState>())).aggref as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AggrefExprState),
            "::",
            stringify!(aggref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggrefExprState>())).aggno as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AggrefExprState),
            "::",
            stringify!(aggno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFuncExprState {
    pub type_: NodeTag,
    pub wfunc: *mut WindowFunc,
    pub args: *mut List,
    pub aggfilter: *mut ExprState,
    pub wfuncno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WindowFuncExprState() {
    assert_eq!(
        ::std::mem::size_of::<WindowFuncExprState>(),
        40usize,
        concat!("Size of: ", stringify!(WindowFuncExprState))
    );
    assert_eq!(
        ::std::mem::align_of::<WindowFuncExprState>(),
        8usize,
        concat!("Alignment of ", stringify!(WindowFuncExprState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFuncExprState>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFuncExprState),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFuncExprState>())).wfunc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFuncExprState),
            "::",
            stringify!(wfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFuncExprState>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFuncExprState),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFuncExprState>())).aggfilter as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFuncExprState),
            "::",
            stringify!(aggfilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowFuncExprState>())).wfuncno as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowFuncExprState),
            "::",
            stringify!(wfuncno)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SetExprState {
    pub type_: NodeTag,
    pub expr: *mut Expr,
    pub args: *mut List,
    pub elidedFuncState: *mut ExprState,
    pub func: FmgrInfo,
    pub funcResultStore: *mut Tuplestorestate,
    pub funcResultSlot: *mut TupleTableSlot,
    pub funcResultDesc: TupleDesc,
    pub funcReturnsTuple: bool,
    pub funcReturnsSet: bool,
    pub setArgsValid: bool,
    pub shutdown_reg: bool,
    pub fcinfo_data: FunctionCallInfoData,
}
#[test]
fn bindgen_test_layout_SetExprState() {
    assert_eq!(
        ::std::mem::size_of::<SetExprState>(),
        1048usize,
        concat!("Size of: ", stringify!(SetExprState))
    );
    assert_eq!(
        ::std::mem::align_of::<SetExprState>(),
        8usize,
        concat!("Alignment of ", stringify!(SetExprState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).expr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(expr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).elidedFuncState as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(elidedFuncState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).funcResultStore as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(funcResultStore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).funcResultSlot as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(funcResultSlot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).funcResultDesc as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(funcResultDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).funcReturnsTuple as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(funcReturnsTuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).funcReturnsSet as *const _ as usize },
        105usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(funcReturnsSet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).setArgsValid as *const _ as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(setArgsValid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).shutdown_reg as *const _ as usize },
        107usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(shutdown_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetExprState>())).fcinfo_data as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SetExprState),
            "::",
            stringify!(fcinfo_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubPlanState {
    pub type_: NodeTag,
    pub subplan: *mut SubPlan,
    pub planstate: *mut PlanState,
    pub parent: *mut PlanState,
    pub testexpr: *mut ExprState,
    pub args: *mut List,
    pub curTuple: HeapTuple,
    pub curArray: Datum,
    pub descRight: TupleDesc,
    pub projLeft: *mut ProjectionInfo,
    pub projRight: *mut ProjectionInfo,
    pub hashtable: TupleHashTable,
    pub hashnulls: TupleHashTable,
    pub havehashrows: bool,
    pub havenullrows: bool,
    pub hashtablecxt: MemoryContext,
    pub hashtempcxt: MemoryContext,
    pub innerecontext: *mut ExprContext,
    pub keyColIdx: *mut AttrNumber,
    pub tab_eq_funcoids: *mut Oid,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_funcs: *mut FmgrInfo,
    pub lhs_hash_funcs: *mut FmgrInfo,
    pub cur_eq_funcs: *mut FmgrInfo,
    pub cur_eq_comp: *mut ExprState,
}
#[test]
fn bindgen_test_layout_SubPlanState() {
    assert_eq!(
        ::std::mem::size_of::<SubPlanState>(),
        192usize,
        concat!("Size of: ", stringify!(SubPlanState))
    );
    assert_eq!(
        ::std::mem::align_of::<SubPlanState>(),
        8usize,
        concat!("Alignment of ", stringify!(SubPlanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).subplan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(subplan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).planstate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(planstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).testexpr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(testexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).args as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).curTuple as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(curTuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).curArray as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(curArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).descRight as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(descRight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).projLeft as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(projLeft)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).projRight as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(projRight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).hashtable as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(hashtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).hashnulls as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(hashnulls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).havehashrows as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(havehashrows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).havenullrows as *const _ as usize },
        105usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(havenullrows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).hashtablecxt as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(hashtablecxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).hashtempcxt as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(hashtempcxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).innerecontext as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(innerecontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).keyColIdx as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(keyColIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).tab_eq_funcoids as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(tab_eq_funcoids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).tab_hash_funcs as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(tab_hash_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).tab_eq_funcs as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(tab_eq_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).lhs_hash_funcs as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(lhs_hash_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).cur_eq_funcs as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(cur_eq_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubPlanState>())).cur_eq_comp as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SubPlanState),
            "::",
            stringify!(cur_eq_comp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlternativeSubPlanState {
    pub type_: NodeTag,
    pub subplan: *mut AlternativeSubPlan,
    pub subplans: *mut List,
    pub active: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AlternativeSubPlanState() {
    assert_eq!(
        ::std::mem::size_of::<AlternativeSubPlanState>(),
        32usize,
        concat!("Size of: ", stringify!(AlternativeSubPlanState))
    );
    assert_eq!(
        ::std::mem::align_of::<AlternativeSubPlanState>(),
        8usize,
        concat!("Alignment of ", stringify!(AlternativeSubPlanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlternativeSubPlanState>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AlternativeSubPlanState),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlternativeSubPlanState>())).subplan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AlternativeSubPlanState),
            "::",
            stringify!(subplan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AlternativeSubPlanState>())).subplans as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AlternativeSubPlanState),
            "::",
            stringify!(subplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AlternativeSubPlanState>())).active as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AlternativeSubPlanState),
            "::",
            stringify!(active)
        )
    );
}
pub const DomainConstraintType_DOM_CONSTRAINT_NOTNULL: DomainConstraintType = 0;
pub const DomainConstraintType_DOM_CONSTRAINT_CHECK: DomainConstraintType = 1;
pub type DomainConstraintType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DomainConstraintState {
    pub type_: NodeTag,
    pub constrainttype: DomainConstraintType,
    pub name: *mut ::std::os::raw::c_char,
    pub check_expr: *mut Expr,
    pub check_exprstate: *mut ExprState,
}
#[test]
fn bindgen_test_layout_DomainConstraintState() {
    assert_eq!(
        ::std::mem::size_of::<DomainConstraintState>(),
        32usize,
        concat!("Size of: ", stringify!(DomainConstraintState))
    );
    assert_eq!(
        ::std::mem::align_of::<DomainConstraintState>(),
        8usize,
        concat!("Alignment of ", stringify!(DomainConstraintState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DomainConstraintState>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainConstraintState),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DomainConstraintState>())).constrainttype as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainConstraintState),
            "::",
            stringify!(constrainttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DomainConstraintState>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainConstraintState),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DomainConstraintState>())).check_expr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainConstraintState),
            "::",
            stringify!(check_expr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DomainConstraintState>())).check_exprstate as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DomainConstraintState),
            "::",
            stringify!(check_exprstate)
        )
    );
}
pub type ExecProcNodeMtd =
    ::std::option::Option<unsafe extern "C" fn(pstate: *mut PlanState) -> *mut TupleTableSlot>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanState {
    pub type_: NodeTag,
    pub plan: *mut Plan,
    pub state: *mut EState,
    pub ExecProcNode: ExecProcNodeMtd,
    pub ExecProcNodeReal: ExecProcNodeMtd,
    pub instrument: *mut Instrumentation,
    pub worker_instrument: *mut WorkerInstrumentation,
    pub worker_jit_instrument: *mut SharedJitInstrumentation,
    pub qual: *mut ExprState,
    pub lefttree: *mut PlanState,
    pub righttree: *mut PlanState,
    pub initPlan: *mut List,
    pub subPlan: *mut List,
    pub chgParam: *mut Bitmapset,
    pub ps_ResultTupleSlot: *mut TupleTableSlot,
    pub ps_ExprContext: *mut ExprContext,
    pub ps_ProjInfo: *mut ProjectionInfo,
    pub scandesc: TupleDesc,
}
#[test]
fn bindgen_test_layout_PlanState() {
    assert_eq!(
        ::std::mem::size_of::<PlanState>(),
        144usize,
        concat!("Size of: ", stringify!(PlanState))
    );
    assert_eq!(
        ::std::mem::align_of::<PlanState>(),
        8usize,
        concat!("Alignment of ", stringify!(PlanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).plan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).ExecProcNode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(ExecProcNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).ExecProcNodeReal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(ExecProcNodeReal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).instrument as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(instrument)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).worker_instrument as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(worker_instrument)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).worker_jit_instrument as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(worker_jit_instrument)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).qual as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(qual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).lefttree as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(lefttree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).righttree as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(righttree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).initPlan as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(initPlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).subPlan as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(subPlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).chgParam as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(chgParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).ps_ResultTupleSlot as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(ps_ResultTupleSlot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).ps_ExprContext as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(ps_ExprContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).ps_ProjInfo as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(ps_ProjInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PlanState>())).scandesc as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(PlanState),
            "::",
            stringify!(scandesc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EPQState {
    pub estate: *mut EState,
    pub planstate: *mut PlanState,
    pub origslot: *mut TupleTableSlot,
    pub plan: *mut Plan,
    pub arowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EPQState() {
    assert_eq!(
        ::std::mem::size_of::<EPQState>(),
        48usize,
        concat!("Size of: ", stringify!(EPQState))
    );
    assert_eq!(
        ::std::mem::align_of::<EPQState>(),
        8usize,
        concat!("Alignment of ", stringify!(EPQState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EPQState>())).estate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EPQState),
            "::",
            stringify!(estate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EPQState>())).planstate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EPQState),
            "::",
            stringify!(planstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EPQState>())).origslot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EPQState),
            "::",
            stringify!(origslot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EPQState>())).plan as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EPQState),
            "::",
            stringify!(plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EPQState>())).arowMarks as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EPQState),
            "::",
            stringify!(arowMarks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EPQState>())).epqParam as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EPQState),
            "::",
            stringify!(epqParam)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResultState {
    pub ps: PlanState,
    pub resconstantqual: *mut ExprState,
    pub rs_done: bool,
    pub rs_checkqual: bool,
}
#[test]
fn bindgen_test_layout_ResultState() {
    assert_eq!(
        ::std::mem::size_of::<ResultState>(),
        160usize,
        concat!("Size of: ", stringify!(ResultState))
    );
    assert_eq!(
        ::std::mem::align_of::<ResultState>(),
        8usize,
        concat!("Alignment of ", stringify!(ResultState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultState>())).resconstantqual as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultState),
            "::",
            stringify!(resconstantqual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultState>())).rs_done as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultState),
            "::",
            stringify!(rs_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ResultState>())).rs_checkqual as *const _ as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(ResultState),
            "::",
            stringify!(rs_checkqual)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectSetState {
    pub ps: PlanState,
    pub elems: *mut *mut Node,
    pub elemdone: *mut ExprDoneCond,
    pub nelems: ::std::os::raw::c_int,
    pub pending_srf_tuples: bool,
    pub argcontext: MemoryContext,
}
#[test]
fn bindgen_test_layout_ProjectSetState() {
    assert_eq!(
        ::std::mem::size_of::<ProjectSetState>(),
        176usize,
        concat!("Size of: ", stringify!(ProjectSetState))
    );
    assert_eq!(
        ::std::mem::align_of::<ProjectSetState>(),
        8usize,
        concat!("Alignment of ", stringify!(ProjectSetState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProjectSetState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProjectSetState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProjectSetState>())).elems as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ProjectSetState),
            "::",
            stringify!(elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProjectSetState>())).elemdone as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ProjectSetState),
            "::",
            stringify!(elemdone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProjectSetState>())).nelems as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ProjectSetState),
            "::",
            stringify!(nelems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ProjectSetState>())).pending_srf_tuples as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ProjectSetState),
            "::",
            stringify!(pending_srf_tuples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ProjectSetState>())).argcontext as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ProjectSetState),
            "::",
            stringify!(argcontext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModifyTableState {
    pub ps: PlanState,
    pub operation: CmdType,
    pub canSetTag: bool,
    pub mt_done: bool,
    pub mt_plans: *mut *mut PlanState,
    pub mt_nplans: ::std::os::raw::c_int,
    pub mt_whichplan: ::std::os::raw::c_int,
    pub resultRelInfo: *mut ResultRelInfo,
    pub rootResultRelInfo: *mut ResultRelInfo,
    pub mt_arowmarks: *mut *mut List,
    pub mt_epqstate: EPQState,
    pub fireBSTriggers: bool,
    pub mt_existing: *mut TupleTableSlot,
    pub mt_excludedtlist: *mut List,
    pub mt_conflproj: *mut TupleTableSlot,
    pub mt_partition_tuple_routing: *mut PartitionTupleRouting,
    pub mt_transition_capture: *mut TransitionCaptureState,
    pub mt_oc_transition_capture: *mut TransitionCaptureState,
    pub mt_per_subplan_tupconv_maps: *mut *mut TupleConversionMap,
}
#[test]
fn bindgen_test_layout_ModifyTableState() {
    assert_eq!(
        ::std::mem::size_of::<ModifyTableState>(),
        304usize,
        concat!("Size of: ", stringify!(ModifyTableState))
    );
    assert_eq!(
        ::std::mem::align_of::<ModifyTableState>(),
        8usize,
        concat!("Alignment of ", stringify!(ModifyTableState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).operation as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).canSetTag as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(canSetTag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).mt_done as *const _ as usize },
        149usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).mt_plans as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_plans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).mt_nplans as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_nplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).mt_whichplan as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_whichplan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).resultRelInfo as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(resultRelInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ModifyTableState>())).rootResultRelInfo as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(rootResultRelInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).mt_arowmarks as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_arowmarks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).mt_epqstate as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_epqstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).fireBSTriggers as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(fireBSTriggers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).mt_existing as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_existing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ModifyTableState>())).mt_excludedtlist as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_excludedtlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModifyTableState>())).mt_conflproj as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_conflproj)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ModifyTableState>())).mt_partition_tuple_routing as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_partition_tuple_routing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ModifyTableState>())).mt_transition_capture as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_transition_capture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ModifyTableState>())).mt_oc_transition_capture as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_oc_transition_capture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ModifyTableState>())).mt_per_subplan_tupconv_maps as *const _
                as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ModifyTableState),
            "::",
            stringify!(mt_per_subplan_tupconv_maps)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelAppendState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppendState {
    pub ps: PlanState,
    pub appendplans: *mut *mut PlanState,
    pub as_nplans: ::std::os::raw::c_int,
    pub as_whichplan: ::std::os::raw::c_int,
    pub as_first_partial_plan: ::std::os::raw::c_int,
    pub as_pstate: *mut ParallelAppendState,
    pub pstate_len: Size,
    pub as_prune_state: *mut PartitionPruneState,
    pub as_valid_subplans: *mut Bitmapset,
    pub choose_next_subplan:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AppendState) -> bool>,
}
#[test]
fn bindgen_test_layout_AppendState() {
    assert_eq!(
        ::std::mem::size_of::<AppendState>(),
        208usize,
        concat!("Size of: ", stringify!(AppendState))
    );
    assert_eq!(
        ::std::mem::align_of::<AppendState>(),
        8usize,
        concat!("Alignment of ", stringify!(AppendState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AppendState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppendState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AppendState>())).appendplans as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AppendState),
            "::",
            stringify!(appendplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AppendState>())).as_nplans as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AppendState),
            "::",
            stringify!(as_nplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AppendState>())).as_whichplan as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(AppendState),
            "::",
            stringify!(as_whichplan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AppendState>())).as_first_partial_plan as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AppendState),
            "::",
            stringify!(as_first_partial_plan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AppendState>())).as_pstate as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AppendState),
            "::",
            stringify!(as_pstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AppendState>())).pstate_len as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AppendState),
            "::",
            stringify!(pstate_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AppendState>())).as_prune_state as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AppendState),
            "::",
            stringify!(as_prune_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AppendState>())).as_valid_subplans as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AppendState),
            "::",
            stringify!(as_valid_subplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AppendState>())).choose_next_subplan as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AppendState),
            "::",
            stringify!(choose_next_subplan)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppendState {
    pub ps: PlanState,
    pub mergeplans: *mut *mut PlanState,
    pub ms_nplans: ::std::os::raw::c_int,
    pub ms_nkeys: ::std::os::raw::c_int,
    pub ms_sortkeys: SortSupport,
    pub ms_slots: *mut *mut TupleTableSlot,
    pub ms_heap: *mut binaryheap,
    pub ms_initialized: bool,
}
#[test]
fn bindgen_test_layout_MergeAppendState() {
    assert_eq!(
        ::std::mem::size_of::<MergeAppendState>(),
        192usize,
        concat!("Size of: ", stringify!(MergeAppendState))
    );
    assert_eq!(
        ::std::mem::align_of::<MergeAppendState>(),
        8usize,
        concat!("Alignment of ", stringify!(MergeAppendState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppendState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppendState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppendState>())).mergeplans as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppendState),
            "::",
            stringify!(mergeplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppendState>())).ms_nplans as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppendState),
            "::",
            stringify!(ms_nplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppendState>())).ms_nkeys as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppendState),
            "::",
            stringify!(ms_nkeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppendState>())).ms_sortkeys as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppendState),
            "::",
            stringify!(ms_sortkeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppendState>())).ms_slots as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppendState),
            "::",
            stringify!(ms_slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppendState>())).ms_heap as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppendState),
            "::",
            stringify!(ms_heap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeAppendState>())).ms_initialized as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeAppendState),
            "::",
            stringify!(ms_initialized)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecursiveUnionState {
    pub ps: PlanState,
    pub recursing: bool,
    pub intermediate_empty: bool,
    pub working_table: *mut Tuplestorestate,
    pub intermediate_table: *mut Tuplestorestate,
    pub eqfuncoids: *mut Oid,
    pub hashfunctions: *mut FmgrInfo,
    pub tempContext: MemoryContext,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
}
#[test]
fn bindgen_test_layout_RecursiveUnionState() {
    assert_eq!(
        ::std::mem::size_of::<RecursiveUnionState>(),
        208usize,
        concat!("Size of: ", stringify!(RecursiveUnionState))
    );
    assert_eq!(
        ::std::mem::align_of::<RecursiveUnionState>(),
        8usize,
        concat!("Alignment of ", stringify!(RecursiveUnionState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecursiveUnionState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnionState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecursiveUnionState>())).recursing as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnionState),
            "::",
            stringify!(recursing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecursiveUnionState>())).intermediate_empty as *const _ as usize
        },
        145usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnionState),
            "::",
            stringify!(intermediate_empty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecursiveUnionState>())).working_table as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnionState),
            "::",
            stringify!(working_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecursiveUnionState>())).intermediate_table as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnionState),
            "::",
            stringify!(intermediate_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecursiveUnionState>())).eqfuncoids as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnionState),
            "::",
            stringify!(eqfuncoids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecursiveUnionState>())).hashfunctions as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnionState),
            "::",
            stringify!(hashfunctions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecursiveUnionState>())).tempContext as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnionState),
            "::",
            stringify!(tempContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecursiveUnionState>())).hashtable as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnionState),
            "::",
            stringify!(hashtable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecursiveUnionState>())).tableContext as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(RecursiveUnionState),
            "::",
            stringify!(tableContext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapAndState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BitmapAndState() {
    assert_eq!(
        ::std::mem::size_of::<BitmapAndState>(),
        160usize,
        concat!("Size of: ", stringify!(BitmapAndState))
    );
    assert_eq!(
        ::std::mem::align_of::<BitmapAndState>(),
        8usize,
        concat!("Alignment of ", stringify!(BitmapAndState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapAndState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapAndState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapAndState>())).bitmapplans as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapAndState),
            "::",
            stringify!(bitmapplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapAndState>())).nplans as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapAndState),
            "::",
            stringify!(nplans)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapOrState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BitmapOrState() {
    assert_eq!(
        ::std::mem::size_of::<BitmapOrState>(),
        160usize,
        concat!("Size of: ", stringify!(BitmapOrState))
    );
    assert_eq!(
        ::std::mem::align_of::<BitmapOrState>(),
        8usize,
        concat!("Alignment of ", stringify!(BitmapOrState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapOrState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapOrState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapOrState>())).bitmapplans as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapOrState),
            "::",
            stringify!(bitmapplans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapOrState>())).nplans as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapOrState),
            "::",
            stringify!(nplans)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScanState {
    pub ps: PlanState,
    pub ss_currentRelation: Relation,
    pub ss_currentScanDesc: HeapScanDesc,
    pub ss_ScanTupleSlot: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_ScanState() {
    assert_eq!(
        ::std::mem::size_of::<ScanState>(),
        168usize,
        concat!("Size of: ", stringify!(ScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<ScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(ScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScanState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ScanState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScanState>())).ss_currentRelation as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ScanState),
            "::",
            stringify!(ss_currentRelation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScanState>())).ss_currentScanDesc as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ScanState),
            "::",
            stringify!(ss_currentScanDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ScanState>())).ss_ScanTupleSlot as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ScanState),
            "::",
            stringify!(ss_ScanTupleSlot)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SeqScanState {
    pub ss: ScanState,
    pub pscan_len: Size,
}
#[test]
fn bindgen_test_layout_SeqScanState() {
    assert_eq!(
        ::std::mem::size_of::<SeqScanState>(),
        176usize,
        concat!("Size of: ", stringify!(SeqScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<SeqScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(SeqScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SeqScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SeqScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SeqScanState>())).pscan_len as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SeqScanState),
            "::",
            stringify!(pscan_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleScanState {
    pub ss: ScanState,
    pub args: *mut List,
    pub repeatable: *mut ExprState,
    pub tsmroutine: *mut TsmRoutine,
    pub tsm_state: *mut ::std::os::raw::c_void,
    pub use_bulkread: bool,
    pub use_pagemode: bool,
    pub begun: bool,
    pub seed: uint32,
}
#[test]
fn bindgen_test_layout_SampleScanState() {
    assert_eq!(
        ::std::mem::size_of::<SampleScanState>(),
        208usize,
        concat!("Size of: ", stringify!(SampleScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<SampleScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(SampleScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SampleScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SampleScanState>())).args as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleScanState),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SampleScanState>())).repeatable as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleScanState),
            "::",
            stringify!(repeatable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SampleScanState>())).tsmroutine as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleScanState),
            "::",
            stringify!(tsmroutine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SampleScanState>())).tsm_state as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleScanState),
            "::",
            stringify!(tsm_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SampleScanState>())).use_bulkread as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleScanState),
            "::",
            stringify!(use_bulkread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SampleScanState>())).use_pagemode as *const _ as usize },
        201usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleScanState),
            "::",
            stringify!(use_pagemode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SampleScanState>())).begun as *const _ as usize },
        202usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleScanState),
            "::",
            stringify!(begun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SampleScanState>())).seed as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(SampleScanState),
            "::",
            stringify!(seed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexRuntimeKeyInfo {
    pub scan_key: ScanKey,
    pub key_expr: *mut ExprState,
    pub key_toastable: bool,
}
#[test]
fn bindgen_test_layout_IndexRuntimeKeyInfo() {
    assert_eq!(
        ::std::mem::size_of::<IndexRuntimeKeyInfo>(),
        24usize,
        concat!("Size of: ", stringify!(IndexRuntimeKeyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexRuntimeKeyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexRuntimeKeyInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexRuntimeKeyInfo>())).scan_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexRuntimeKeyInfo),
            "::",
            stringify!(scan_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexRuntimeKeyInfo>())).key_expr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexRuntimeKeyInfo),
            "::",
            stringify!(key_expr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexRuntimeKeyInfo>())).key_toastable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexRuntimeKeyInfo),
            "::",
            stringify!(key_toastable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexArrayKeyInfo {
    pub scan_key: ScanKey,
    pub array_expr: *mut ExprState,
    pub next_elem: ::std::os::raw::c_int,
    pub num_elems: ::std::os::raw::c_int,
    pub elem_values: *mut Datum,
    pub elem_nulls: *mut bool,
}
#[test]
fn bindgen_test_layout_IndexArrayKeyInfo() {
    assert_eq!(
        ::std::mem::size_of::<IndexArrayKeyInfo>(),
        40usize,
        concat!("Size of: ", stringify!(IndexArrayKeyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexArrayKeyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexArrayKeyInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexArrayKeyInfo>())).scan_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexArrayKeyInfo),
            "::",
            stringify!(scan_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexArrayKeyInfo>())).array_expr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexArrayKeyInfo),
            "::",
            stringify!(array_expr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexArrayKeyInfo>())).next_elem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexArrayKeyInfo),
            "::",
            stringify!(next_elem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexArrayKeyInfo>())).num_elems as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexArrayKeyInfo),
            "::",
            stringify!(num_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexArrayKeyInfo>())).elem_values as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexArrayKeyInfo),
            "::",
            stringify!(elem_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexArrayKeyInfo>())).elem_nulls as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexArrayKeyInfo),
            "::",
            stringify!(elem_nulls)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScanState {
    pub ss: ScanState,
    pub indexqualorig: *mut ExprState,
    pub indexorderbyorig: *mut List,
    pub iss_ScanKeys: ScanKey,
    pub iss_NumScanKeys: ::std::os::raw::c_int,
    pub iss_OrderByKeys: ScanKey,
    pub iss_NumOrderByKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub iss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeysReady: bool,
    pub iss_RuntimeContext: *mut ExprContext,
    pub iss_RelationDesc: Relation,
    pub iss_ScanDesc: IndexScanDesc,
    pub iss_ReorderQueue: *mut pairingheap,
    pub iss_ReachedEnd: bool,
    pub iss_OrderByValues: *mut Datum,
    pub iss_OrderByNulls: *mut bool,
    pub iss_SortSupport: SortSupport,
    pub iss_OrderByTypByVals: *mut bool,
    pub iss_OrderByTypLens: *mut int16,
    pub iss_PscanLen: Size,
}
#[test]
fn bindgen_test_layout_IndexScanState() {
    assert_eq!(
        ::std::mem::size_of::<IndexScanState>(),
        320usize,
        concat!("Size of: ", stringify!(IndexScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).indexqualorig as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(indexqualorig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).indexorderbyorig as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(indexorderbyorig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).iss_ScanKeys as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_ScanKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).iss_NumScanKeys as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_NumScanKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).iss_OrderByKeys as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_OrderByKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexScanState>())).iss_NumOrderByKeys as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_NumOrderByKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).iss_RuntimeKeys as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_RuntimeKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexScanState>())).iss_NumRuntimeKeys as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_NumRuntimeKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexScanState>())).iss_RuntimeKeysReady as *const _ as usize
        },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_RuntimeKeysReady)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexScanState>())).iss_RuntimeContext as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_RuntimeContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).iss_RelationDesc as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_RelationDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).iss_ScanDesc as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_ScanDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).iss_ReorderQueue as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_ReorderQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).iss_ReachedEnd as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_ReachedEnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexScanState>())).iss_OrderByValues as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_OrderByValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).iss_OrderByNulls as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_OrderByNulls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).iss_SortSupport as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_SortSupport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexScanState>())).iss_OrderByTypByVals as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_OrderByTypByVals)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexScanState>())).iss_OrderByTypLens as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_OrderByTypLens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexScanState>())).iss_PscanLen as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexScanState),
            "::",
            stringify!(iss_PscanLen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexOnlyScanState {
    pub ss: ScanState,
    pub indexqual: *mut ExprState,
    pub ioss_ScanKeys: ScanKey,
    pub ioss_NumScanKeys: ::std::os::raw::c_int,
    pub ioss_OrderByKeys: ScanKey,
    pub ioss_NumOrderByKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub ioss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeysReady: bool,
    pub ioss_RuntimeContext: *mut ExprContext,
    pub ioss_RelationDesc: Relation,
    pub ioss_ScanDesc: IndexScanDesc,
    pub ioss_VMBuffer: Buffer,
    pub ioss_PscanLen: Size,
}
#[test]
fn bindgen_test_layout_IndexOnlyScanState() {
    assert_eq!(
        ::std::mem::size_of::<IndexOnlyScanState>(),
        264usize,
        concat!("Size of: ", stringify!(IndexOnlyScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexOnlyScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexOnlyScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexOnlyScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IndexOnlyScanState>())).indexqual as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(indexqual)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_ScanKeys as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_ScanKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_NumScanKeys as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_NumScanKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_OrderByKeys as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_OrderByKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_NumOrderByKeys as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_NumOrderByKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_RuntimeKeys as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_RuntimeKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_NumRuntimeKeys as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_NumRuntimeKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_RuntimeKeysReady as *const _
                as usize
        },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_RuntimeKeysReady)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_RuntimeContext as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_RuntimeContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_RelationDesc as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_RelationDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_ScanDesc as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_ScanDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_VMBuffer as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_VMBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexOnlyScanState>())).ioss_PscanLen as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexOnlyScanState),
            "::",
            stringify!(ioss_PscanLen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapIndexScanState {
    pub ss: ScanState,
    pub biss_result: *mut TIDBitmap,
    pub biss_ScanKeys: ScanKey,
    pub biss_NumScanKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub biss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub biss_ArrayKeys: *mut IndexArrayKeyInfo,
    pub biss_NumArrayKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeysReady: bool,
    pub biss_RuntimeContext: *mut ExprContext,
    pub biss_RelationDesc: Relation,
    pub biss_ScanDesc: IndexScanDesc,
}
#[test]
fn bindgen_test_layout_BitmapIndexScanState() {
    assert_eq!(
        ::std::mem::size_of::<BitmapIndexScanState>(),
        248usize,
        concat!("Size of: ", stringify!(BitmapIndexScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<BitmapIndexScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(BitmapIndexScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapIndexScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapIndexScanState>())).biss_result as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(biss_result)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapIndexScanState>())).biss_ScanKeys as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(biss_ScanKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapIndexScanState>())).biss_NumScanKeys as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(biss_NumScanKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapIndexScanState>())).biss_RuntimeKeys as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(biss_RuntimeKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapIndexScanState>())).biss_NumRuntimeKeys as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(biss_NumRuntimeKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapIndexScanState>())).biss_ArrayKeys as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(biss_ArrayKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapIndexScanState>())).biss_NumArrayKeys as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(biss_NumArrayKeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapIndexScanState>())).biss_RuntimeKeysReady as *const _
                as usize
        },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(biss_RuntimeKeysReady)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapIndexScanState>())).biss_RuntimeContext as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(biss_RuntimeContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapIndexScanState>())).biss_RelationDesc as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(biss_RelationDesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapIndexScanState>())).biss_ScanDesc as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapIndexScanState),
            "::",
            stringify!(biss_ScanDesc)
        )
    );
}
pub const SharedBitmapState_BM_INITIAL: SharedBitmapState = 0;
pub const SharedBitmapState_BM_INPROGRESS: SharedBitmapState = 1;
pub const SharedBitmapState_BM_FINISHED: SharedBitmapState = 2;
pub type SharedBitmapState = u32;
#[repr(C)]
#[derive(Debug)]
pub struct ParallelBitmapHeapState {
    pub tbmiterator: dsa_pointer,
    pub prefetch_iterator: dsa_pointer,
    pub mutex: slock_t,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
    pub state: SharedBitmapState,
    pub cv: ConditionVariable,
    pub phs_snapshot_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_ParallelBitmapHeapState() {
    assert_eq!(
        ::std::mem::size_of::<ParallelBitmapHeapState>(),
        48usize,
        concat!("Size of: ", stringify!(ParallelBitmapHeapState))
    );
    assert_eq!(
        ::std::mem::align_of::<ParallelBitmapHeapState>(),
        8usize,
        concat!("Alignment of ", stringify!(ParallelBitmapHeapState))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapHeapScanState {
    pub ss: ScanState,
    pub bitmapqualorig: *mut ExprState,
    pub tbm: *mut TIDBitmap,
    pub tbmiterator: *mut TBMIterator,
    pub tbmres: *mut TBMIterateResult,
    pub can_skip_fetch: bool,
    pub skip_fetch: bool,
    pub vmbuffer: Buffer,
    pub pvmbuffer: Buffer,
    pub exact_pages: ::std::os::raw::c_long,
    pub lossy_pages: ::std::os::raw::c_long,
    pub prefetch_iterator: *mut TBMIterator,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
    pub prefetch_maximum: ::std::os::raw::c_int,
    pub pscan_len: Size,
    pub initialized: bool,
    pub shared_tbmiterator: *mut TBMSharedIterator,
    pub shared_prefetch_iterator: *mut TBMSharedIterator,
    pub pstate: *mut ParallelBitmapHeapState,
}
#[test]
fn bindgen_test_layout_BitmapHeapScanState() {
    assert_eq!(
        ::std::mem::size_of::<BitmapHeapScanState>(),
        296usize,
        concat!("Size of: ", stringify!(BitmapHeapScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<BitmapHeapScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(BitmapHeapScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapHeapScanState>())).bitmapqualorig as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(bitmapqualorig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).tbm as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(tbm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).tbmiterator as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(tbmiterator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).tbmres as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(tbmres)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapHeapScanState>())).can_skip_fetch as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(can_skip_fetch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).skip_fetch as *const _ as usize },
        201usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(skip_fetch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).vmbuffer as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(vmbuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).pvmbuffer as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(pvmbuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).exact_pages as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(exact_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).lossy_pages as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(lossy_pages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapHeapScanState>())).prefetch_iterator as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(prefetch_iterator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapHeapScanState>())).prefetch_pages as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(prefetch_pages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapHeapScanState>())).prefetch_target as *const _ as usize
        },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(prefetch_target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapHeapScanState>())).prefetch_maximum as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(prefetch_maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).pscan_len as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(pscan_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).initialized as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapHeapScanState>())).shared_tbmiterator as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(shared_tbmiterator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BitmapHeapScanState>())).shared_prefetch_iterator as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(shared_prefetch_iterator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BitmapHeapScanState>())).pstate as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(BitmapHeapScanState),
            "::",
            stringify!(pstate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidScanState {
    pub ss: ScanState,
    pub tss_tidexprs: *mut List,
    pub tss_isCurrentOf: bool,
    pub tss_NumTids: ::std::os::raw::c_int,
    pub tss_TidPtr: ::std::os::raw::c_int,
    pub tss_TidList: *mut ItemPointerData,
    pub tss_htup: HeapTupleData,
}
#[test]
fn bindgen_test_layout_TidScanState() {
    assert_eq!(
        ::std::mem::size_of::<TidScanState>(),
        224usize,
        concat!("Size of: ", stringify!(TidScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<TidScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(TidScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TidScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TidScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TidScanState>())).tss_tidexprs as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(TidScanState),
            "::",
            stringify!(tss_tidexprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TidScanState>())).tss_isCurrentOf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(TidScanState),
            "::",
            stringify!(tss_isCurrentOf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TidScanState>())).tss_NumTids as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(TidScanState),
            "::",
            stringify!(tss_NumTids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TidScanState>())).tss_TidPtr as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(TidScanState),
            "::",
            stringify!(tss_TidPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TidScanState>())).tss_TidList as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(TidScanState),
            "::",
            stringify!(tss_TidList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TidScanState>())).tss_htup as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(TidScanState),
            "::",
            stringify!(tss_htup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubqueryScanState {
    pub ss: ScanState,
    pub subplan: *mut PlanState,
}
#[test]
fn bindgen_test_layout_SubqueryScanState() {
    assert_eq!(
        ::std::mem::size_of::<SubqueryScanState>(),
        176usize,
        concat!("Size of: ", stringify!(SubqueryScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<SubqueryScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(SubqueryScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubqueryScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubqueryScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SubqueryScanState>())).subplan as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SubqueryScanState),
            "::",
            stringify!(subplan)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScanPerFuncState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub ordinality: bool,
    pub simple: bool,
    pub ordinal: int64,
    pub nfuncs: ::std::os::raw::c_int,
    pub funcstates: *mut FunctionScanPerFuncState,
    pub argcontext: MemoryContext,
}
#[test]
fn bindgen_test_layout_FunctionScanState() {
    assert_eq!(
        ::std::mem::size_of::<FunctionScanState>(),
        208usize,
        concat!("Size of: ", stringify!(FunctionScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<FunctionScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(FunctionScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionScanState>())).eflags as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionScanState),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionScanState>())).ordinality as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionScanState),
            "::",
            stringify!(ordinality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionScanState>())).simple as *const _ as usize },
        173usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionScanState),
            "::",
            stringify!(simple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionScanState>())).ordinal as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionScanState),
            "::",
            stringify!(ordinal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionScanState>())).nfuncs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionScanState),
            "::",
            stringify!(nfuncs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionScanState>())).funcstates as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionScanState),
            "::",
            stringify!(funcstates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionScanState>())).argcontext as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionScanState),
            "::",
            stringify!(argcontext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValuesScanState {
    pub ss: ScanState,
    pub rowcontext: *mut ExprContext,
    pub exprlists: *mut *mut List,
    pub array_len: ::std::os::raw::c_int,
    pub curr_idx: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ValuesScanState() {
    assert_eq!(
        ::std::mem::size_of::<ValuesScanState>(),
        192usize,
        concat!("Size of: ", stringify!(ValuesScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<ValuesScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(ValuesScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValuesScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ValuesScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValuesScanState>())).rowcontext as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ValuesScanState),
            "::",
            stringify!(rowcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValuesScanState>())).exprlists as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ValuesScanState),
            "::",
            stringify!(exprlists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValuesScanState>())).array_len as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ValuesScanState),
            "::",
            stringify!(array_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ValuesScanState>())).curr_idx as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ValuesScanState),
            "::",
            stringify!(curr_idx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFuncScanState {
    pub ss: ScanState,
    pub docexpr: *mut ExprState,
    pub rowexpr: *mut ExprState,
    pub colexprs: *mut List,
    pub coldefexprs: *mut List,
    pub ns_names: *mut List,
    pub ns_uris: *mut List,
    pub notnulls: *mut Bitmapset,
    pub opaque: *mut ::std::os::raw::c_void,
    pub routine: *mut TableFuncRoutine,
    pub in_functions: *mut FmgrInfo,
    pub typioparams: *mut Oid,
    pub ordinal: int64,
    pub perTableCxt: MemoryContext,
    pub tupstore: *mut Tuplestorestate,
}
#[test]
fn bindgen_test_layout_TableFuncScanState() {
    assert_eq!(
        ::std::mem::size_of::<TableFuncScanState>(),
        280usize,
        concat!("Size of: ", stringify!(TableFuncScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<TableFuncScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(TableFuncScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).docexpr as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(docexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).rowexpr as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(rowexpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).colexprs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(colexprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).coldefexprs as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(coldefexprs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).ns_names as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(ns_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).ns_uris as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(ns_uris)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).notnulls as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(notnulls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).opaque as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).routine as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).in_functions as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(in_functions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).typioparams as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(typioparams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).ordinal as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(ordinal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).perTableCxt as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(perTableCxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TableFuncScanState>())).tupstore as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(TableFuncScanState),
            "::",
            stringify!(tupstore)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CteScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub readptr: ::std::os::raw::c_int,
    pub cteplanstate: *mut PlanState,
    pub leader: *mut CteScanState,
    pub cte_table: *mut Tuplestorestate,
    pub eof_cte: bool,
}
#[test]
fn bindgen_test_layout_CteScanState() {
    assert_eq!(
        ::std::mem::size_of::<CteScanState>(),
        208usize,
        concat!("Size of: ", stringify!(CteScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<CteScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(CteScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CteScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CteScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CteScanState>())).eflags as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CteScanState),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CteScanState>())).readptr as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(CteScanState),
            "::",
            stringify!(readptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CteScanState>())).cteplanstate as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CteScanState),
            "::",
            stringify!(cteplanstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CteScanState>())).leader as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CteScanState),
            "::",
            stringify!(leader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CteScanState>())).cte_table as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CteScanState),
            "::",
            stringify!(cte_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CteScanState>())).eof_cte as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(CteScanState),
            "::",
            stringify!(eof_cte)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedTuplestoreScanState {
    pub ss: ScanState,
    pub readptr: ::std::os::raw::c_int,
    pub tupdesc: TupleDesc,
    pub relation: *mut Tuplestorestate,
}
#[test]
fn bindgen_test_layout_NamedTuplestoreScanState() {
    assert_eq!(
        ::std::mem::size_of::<NamedTuplestoreScanState>(),
        192usize,
        concat!("Size of: ", stringify!(NamedTuplestoreScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<NamedTuplestoreScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedTuplestoreScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NamedTuplestoreScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedTuplestoreScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NamedTuplestoreScanState>())).readptr as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedTuplestoreScanState),
            "::",
            stringify!(readptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NamedTuplestoreScanState>())).tupdesc as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedTuplestoreScanState),
            "::",
            stringify!(tupdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NamedTuplestoreScanState>())).relation as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedTuplestoreScanState),
            "::",
            stringify!(relation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WorkTableScanState {
    pub ss: ScanState,
    pub rustate: *mut RecursiveUnionState,
}
#[test]
fn bindgen_test_layout_WorkTableScanState() {
    assert_eq!(
        ::std::mem::size_of::<WorkTableScanState>(),
        176usize,
        concat!("Size of: ", stringify!(WorkTableScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<WorkTableScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(WorkTableScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorkTableScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkTableScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorkTableScanState>())).rustate as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(WorkTableScanState),
            "::",
            stringify!(rustate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignScanState {
    pub ss: ScanState,
    pub fdw_recheck_quals: *mut ExprState,
    pub pscan_len: Size,
    pub fdwroutine: *mut FdwRoutine,
    pub fdw_state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ForeignScanState() {
    assert_eq!(
        ::std::mem::size_of::<ForeignScanState>(),
        200usize,
        concat!("Size of: ", stringify!(ForeignScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<ForeignScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(ForeignScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ForeignScanState>())).fdw_recheck_quals as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScanState),
            "::",
            stringify!(fdw_recheck_quals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScanState>())).pscan_len as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScanState),
            "::",
            stringify!(pscan_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScanState>())).fdwroutine as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScanState),
            "::",
            stringify!(fdwroutine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForeignScanState>())).fdw_state as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ForeignScanState),
            "::",
            stringify!(fdw_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomExecMethods {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScanState {
    pub ss: ScanState,
    pub flags: uint32,
    pub custom_ps: *mut List,
    pub pscan_len: Size,
    pub methods: *const CustomExecMethods,
}
#[test]
fn bindgen_test_layout_CustomScanState() {
    assert_eq!(
        ::std::mem::size_of::<CustomScanState>(),
        200usize,
        concat!("Size of: ", stringify!(CustomScanState))
    );
    assert_eq!(
        ::std::mem::align_of::<CustomScanState>(),
        8usize,
        concat!("Alignment of ", stringify!(CustomScanState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScanState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScanState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScanState>())).flags as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScanState),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScanState>())).custom_ps as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScanState),
            "::",
            stringify!(custom_ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScanState>())).pscan_len as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScanState),
            "::",
            stringify!(pscan_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CustomScanState>())).methods as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CustomScanState),
            "::",
            stringify!(methods)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinState {
    pub ps: PlanState,
    pub jointype: JoinType,
    pub single_match: bool,
    pub joinqual: *mut ExprState,
}
#[test]
fn bindgen_test_layout_JoinState() {
    assert_eq!(
        ::std::mem::size_of::<JoinState>(),
        160usize,
        concat!("Size of: ", stringify!(JoinState))
    );
    assert_eq!(
        ::std::mem::align_of::<JoinState>(),
        8usize,
        concat!("Alignment of ", stringify!(JoinState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinState>())).jointype as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinState),
            "::",
            stringify!(jointype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinState>())).single_match as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinState),
            "::",
            stringify!(single_match)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JoinState>())).joinqual as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(JoinState),
            "::",
            stringify!(joinqual)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoopState {
    pub js: JoinState,
    pub nl_NeedNewOuter: bool,
    pub nl_MatchedOuter: bool,
    pub nl_NullInnerTupleSlot: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_NestLoopState() {
    assert_eq!(
        ::std::mem::size_of::<NestLoopState>(),
        176usize,
        concat!("Size of: ", stringify!(NestLoopState))
    );
    assert_eq!(
        ::std::mem::align_of::<NestLoopState>(),
        8usize,
        concat!("Alignment of ", stringify!(NestLoopState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NestLoopState>())).js as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NestLoopState),
            "::",
            stringify!(js)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NestLoopState>())).nl_NeedNewOuter as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(NestLoopState),
            "::",
            stringify!(nl_NeedNewOuter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NestLoopState>())).nl_MatchedOuter as *const _ as usize },
        161usize,
        concat!(
            "Offset of field: ",
            stringify!(NestLoopState),
            "::",
            stringify!(nl_MatchedOuter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NestLoopState>())).nl_NullInnerTupleSlot as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(NestLoopState),
            "::",
            stringify!(nl_NullInnerTupleSlot)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoinClauseData {
    _unused: [u8; 0],
}
pub type MergeJoinClause = *mut MergeJoinClauseData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoinState {
    pub js: JoinState,
    pub mj_NumClauses: ::std::os::raw::c_int,
    pub mj_Clauses: MergeJoinClause,
    pub mj_JoinState: ::std::os::raw::c_int,
    pub mj_SkipMarkRestore: bool,
    pub mj_ExtraMarks: bool,
    pub mj_ConstFalseJoin: bool,
    pub mj_FillOuter: bool,
    pub mj_FillInner: bool,
    pub mj_MatchedOuter: bool,
    pub mj_MatchedInner: bool,
    pub mj_OuterTupleSlot: *mut TupleTableSlot,
    pub mj_InnerTupleSlot: *mut TupleTableSlot,
    pub mj_MarkedTupleSlot: *mut TupleTableSlot,
    pub mj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub mj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub mj_OuterEContext: *mut ExprContext,
    pub mj_InnerEContext: *mut ExprContext,
}
#[test]
fn bindgen_test_layout_MergeJoinState() {
    assert_eq!(
        ::std::mem::size_of::<MergeJoinState>(),
        248usize,
        concat!("Size of: ", stringify!(MergeJoinState))
    );
    assert_eq!(
        ::std::mem::align_of::<MergeJoinState>(),
        8usize,
        concat!("Alignment of ", stringify!(MergeJoinState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoinState>())).js as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(js)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoinState>())).mj_NumClauses as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_NumClauses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoinState>())).mj_Clauses as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_Clauses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoinState>())).mj_JoinState as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_JoinState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MergeJoinState>())).mj_SkipMarkRestore as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_SkipMarkRestore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoinState>())).mj_ExtraMarks as *const _ as usize },
        181usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_ExtraMarks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MergeJoinState>())).mj_ConstFalseJoin as *const _ as usize
        },
        182usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_ConstFalseJoin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoinState>())).mj_FillOuter as *const _ as usize },
        183usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_FillOuter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoinState>())).mj_FillInner as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_FillInner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoinState>())).mj_MatchedOuter as *const _ as usize },
        185usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_MatchedOuter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoinState>())).mj_MatchedInner as *const _ as usize },
        186usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_MatchedInner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MergeJoinState>())).mj_OuterTupleSlot as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_OuterTupleSlot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MergeJoinState>())).mj_InnerTupleSlot as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_InnerTupleSlot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MergeJoinState>())).mj_MarkedTupleSlot as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_MarkedTupleSlot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MergeJoinState>())).mj_NullOuterTupleSlot as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_NullOuterTupleSlot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MergeJoinState>())).mj_NullInnerTupleSlot as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_NullInnerTupleSlot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoinState>())).mj_OuterEContext as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_OuterEContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MergeJoinState>())).mj_InnerEContext as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(MergeJoinState),
            "::",
            stringify!(mj_InnerEContext)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTupleData {
    _unused: [u8; 0],
}
pub type HashJoinTuple = *mut HashJoinTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTableData {
    _unused: [u8; 0],
}
pub type HashJoinTable = *mut HashJoinTableData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinState {
    pub js: JoinState,
    pub hashclauses: *mut ExprState,
    pub hj_OuterHashKeys: *mut List,
    pub hj_InnerHashKeys: *mut List,
    pub hj_HashOperators: *mut List,
    pub hj_HashTable: HashJoinTable,
    pub hj_CurHashValue: uint32,
    pub hj_CurBucketNo: ::std::os::raw::c_int,
    pub hj_CurSkewBucketNo: ::std::os::raw::c_int,
    pub hj_CurTuple: HashJoinTuple,
    pub hj_OuterTupleSlot: *mut TupleTableSlot,
    pub hj_HashTupleSlot: *mut TupleTableSlot,
    pub hj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub hj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub hj_FirstOuterTupleSlot: *mut TupleTableSlot,
    pub hj_JoinState: ::std::os::raw::c_int,
    pub hj_MatchedOuter: bool,
    pub hj_OuterNotEmpty: bool,
}
#[test]
fn bindgen_test_layout_HashJoinState() {
    assert_eq!(
        ::std::mem::size_of::<HashJoinState>(),
        272usize,
        concat!("Size of: ", stringify!(HashJoinState))
    );
    assert_eq!(
        ::std::mem::align_of::<HashJoinState>(),
        8usize,
        concat!("Alignment of ", stringify!(HashJoinState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).js as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(js)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hashclauses as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hashclauses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_OuterHashKeys as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_OuterHashKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_InnerHashKeys as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_InnerHashKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_HashOperators as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_HashOperators)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_HashTable as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_HashTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_CurHashValue as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_CurHashValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_CurBucketNo as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_CurBucketNo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HashJoinState>())).hj_CurSkewBucketNo as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_CurSkewBucketNo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_CurTuple as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_CurTuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_OuterTupleSlot as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_OuterTupleSlot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_HashTupleSlot as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_HashTupleSlot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HashJoinState>())).hj_NullOuterTupleSlot as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_NullOuterTupleSlot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HashJoinState>())).hj_NullInnerTupleSlot as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_NullInnerTupleSlot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HashJoinState>())).hj_FirstOuterTupleSlot as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_FirstOuterTupleSlot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_JoinState as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_JoinState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_MatchedOuter as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_MatchedOuter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashJoinState>())).hj_OuterNotEmpty as *const _ as usize },
        269usize,
        concat!(
            "Offset of field: ",
            stringify!(HashJoinState),
            "::",
            stringify!(hj_OuterNotEmpty)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaterialState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub eof_underlying: bool,
    pub tuplestorestate: *mut Tuplestorestate,
}
#[test]
fn bindgen_test_layout_MaterialState() {
    assert_eq!(
        ::std::mem::size_of::<MaterialState>(),
        184usize,
        concat!("Size of: ", stringify!(MaterialState))
    );
    assert_eq!(
        ::std::mem::align_of::<MaterialState>(),
        8usize,
        concat!("Alignment of ", stringify!(MaterialState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MaterialState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MaterialState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MaterialState>())).eflags as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(MaterialState),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MaterialState>())).eof_underlying as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(MaterialState),
            "::",
            stringify!(eof_underlying)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MaterialState>())).tuplestorestate as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(MaterialState),
            "::",
            stringify!(tuplestorestate)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SharedSortInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub sinstrument: __IncompleteArrayField<TuplesortInstrumentation>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_SharedSortInfo() {
    assert_eq!(
        ::std::mem::size_of::<SharedSortInfo>(),
        8usize,
        concat!("Size of: ", stringify!(SharedSortInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SharedSortInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SharedSortInfo))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortState {
    pub ss: ScanState,
    pub randomAccess: bool,
    pub bounded: bool,
    pub bound: int64,
    pub sort_Done: bool,
    pub bounded_Done: bool,
    pub bound_Done: int64,
    pub tuplesortstate: *mut ::std::os::raw::c_void,
    pub am_worker: bool,
    pub shared_info: *mut SharedSortInfo,
}
#[test]
fn bindgen_test_layout_SortState() {
    assert_eq!(
        ::std::mem::size_of::<SortState>(),
        224usize,
        concat!("Size of: ", stringify!(SortState))
    );
    assert_eq!(
        ::std::mem::align_of::<SortState>(),
        8usize,
        concat!("Alignment of ", stringify!(SortState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SortState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortState>())).randomAccess as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SortState),
            "::",
            stringify!(randomAccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortState>())).bounded as *const _ as usize },
        169usize,
        concat!(
            "Offset of field: ",
            stringify!(SortState),
            "::",
            stringify!(bounded)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortState>())).bound as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SortState),
            "::",
            stringify!(bound)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortState>())).sort_Done as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SortState),
            "::",
            stringify!(sort_Done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortState>())).bounded_Done as *const _ as usize },
        185usize,
        concat!(
            "Offset of field: ",
            stringify!(SortState),
            "::",
            stringify!(bounded_Done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortState>())).bound_Done as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(SortState),
            "::",
            stringify!(bound_Done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortState>())).tuplesortstate as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(SortState),
            "::",
            stringify!(tuplesortstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortState>())).am_worker as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(SortState),
            "::",
            stringify!(am_worker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SortState>())).shared_info as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(SortState),
            "::",
            stringify!(shared_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupState {
    pub ss: ScanState,
    pub eqfunction: *mut ExprState,
    pub grp_done: bool,
}
#[test]
fn bindgen_test_layout_GroupState() {
    assert_eq!(
        ::std::mem::size_of::<GroupState>(),
        184usize,
        concat!("Size of: ", stringify!(GroupState))
    );
    assert_eq!(
        ::std::mem::align_of::<GroupState>(),
        8usize,
        concat!("Alignment of ", stringify!(GroupState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupState>())).eqfunction as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupState),
            "::",
            stringify!(eqfunction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GroupState>())).grp_done as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(GroupState),
            "::",
            stringify!(grp_done)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerAggData {
    _unused: [u8; 0],
}
pub type AggStatePerAgg = *mut AggStatePerAggData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerTransData {
    _unused: [u8; 0],
}
pub type AggStatePerTrans = *mut AggStatePerTransData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerGroupData {
    _unused: [u8; 0],
}
pub type AggStatePerGroup = *mut AggStatePerGroupData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerPhaseData {
    _unused: [u8; 0],
}
pub type AggStatePerPhase = *mut AggStatePerPhaseData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerHashData {
    _unused: [u8; 0],
}
pub type AggStatePerHash = *mut AggStatePerHashData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggState {
    pub ss: ScanState,
    pub aggs: *mut List,
    pub numaggs: ::std::os::raw::c_int,
    pub numtrans: ::std::os::raw::c_int,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub phase: AggStatePerPhase,
    pub numphases: ::std::os::raw::c_int,
    pub current_phase: ::std::os::raw::c_int,
    pub peragg: AggStatePerAgg,
    pub pertrans: AggStatePerTrans,
    pub hashcontext: *mut ExprContext,
    pub aggcontexts: *mut *mut ExprContext,
    pub tmpcontext: *mut ExprContext,
    pub curaggcontext: *mut ExprContext,
    pub curperagg: AggStatePerAgg,
    pub curpertrans: AggStatePerTrans,
    pub input_done: bool,
    pub agg_done: bool,
    pub projected_set: ::std::os::raw::c_int,
    pub current_set: ::std::os::raw::c_int,
    pub grouped_cols: *mut Bitmapset,
    pub all_grouped_cols: *mut List,
    pub maxsets: ::std::os::raw::c_int,
    pub phases: AggStatePerPhase,
    pub sort_in: *mut Tuplesortstate,
    pub sort_out: *mut Tuplesortstate,
    pub sort_slot: *mut TupleTableSlot,
    pub pergroups: *mut AggStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub table_filled: bool,
    pub num_hashes: ::std::os::raw::c_int,
    pub perhash: AggStatePerHash,
    pub hash_pergroup: *mut AggStatePerGroup,
    pub all_pergroups: *mut AggStatePerGroup,
    pub combinedproj: *mut ProjectionInfo,
}
#[test]
fn bindgen_test_layout_AggState() {
    assert_eq!(
        ::std::mem::size_of::<AggState>(),
        400usize,
        concat!("Size of: ", stringify!(AggState))
    );
    assert_eq!(
        ::std::mem::align_of::<AggState>(),
        8usize,
        concat!("Alignment of ", stringify!(AggState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).aggs as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(aggs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).numaggs as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(numaggs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).numtrans as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(numtrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).aggstrategy as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(aggstrategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).aggsplit as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(aggsplit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).phase as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).numphases as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(numphases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).current_phase as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(current_phase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).peragg as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(peragg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).pertrans as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(pertrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).hashcontext as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(hashcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).aggcontexts as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(aggcontexts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).tmpcontext as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(tmpcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).curaggcontext as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(curaggcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).curperagg as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(curperagg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).curpertrans as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(curpertrans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).input_done as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(input_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).agg_done as *const _ as usize },
        273usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(agg_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).projected_set as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(projected_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).current_set as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(current_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).grouped_cols as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(grouped_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).all_grouped_cols as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(all_grouped_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).maxsets as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(maxsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).phases as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(phases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).sort_in as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(sort_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).sort_out as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(sort_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).sort_slot as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(sort_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).pergroups as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(pergroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).grp_firstTuple as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(grp_firstTuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).table_filled as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(table_filled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).num_hashes as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(num_hashes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).perhash as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(perhash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).hash_pergroup as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(hash_pergroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).all_pergroups as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(all_pergroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AggState>())).combinedproj as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AggState),
            "::",
            stringify!(combinedproj)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerFuncData {
    _unused: [u8; 0],
}
pub type WindowStatePerFunc = *mut WindowStatePerFuncData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerAggData {
    _unused: [u8; 0],
}
pub type WindowStatePerAgg = *mut WindowStatePerAggData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAggState {
    pub ss: ScanState,
    pub funcs: *mut List,
    pub numfuncs: ::std::os::raw::c_int,
    pub numaggs: ::std::os::raw::c_int,
    pub perfunc: WindowStatePerFunc,
    pub peragg: WindowStatePerAgg,
    pub partEqfunction: *mut ExprState,
    pub ordEqfunction: *mut ExprState,
    pub buffer: *mut Tuplestorestate,
    pub current_ptr: ::std::os::raw::c_int,
    pub framehead_ptr: ::std::os::raw::c_int,
    pub frametail_ptr: ::std::os::raw::c_int,
    pub grouptail_ptr: ::std::os::raw::c_int,
    pub spooled_rows: int64,
    pub currentpos: int64,
    pub frameheadpos: int64,
    pub frametailpos: int64,
    pub agg_winobj: *mut WindowObjectData,
    pub aggregatedbase: int64,
    pub aggregatedupto: int64,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut ExprState,
    pub endOffset: *mut ExprState,
    pub startOffsetValue: Datum,
    pub endOffsetValue: Datum,
    pub startInRangeFunc: FmgrInfo,
    pub endInRangeFunc: FmgrInfo,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub currentgroup: int64,
    pub frameheadgroup: int64,
    pub frametailgroup: int64,
    pub groupheadpos: int64,
    pub grouptailpos: int64,
    pub partcontext: MemoryContext,
    pub aggcontext: MemoryContext,
    pub curaggcontext: MemoryContext,
    pub tmpcontext: *mut ExprContext,
    pub all_first: bool,
    pub all_done: bool,
    pub partition_spooled: bool,
    pub more_partitions: bool,
    pub framehead_valid: bool,
    pub frametail_valid: bool,
    pub grouptail_valid: bool,
    pub first_part_slot: *mut TupleTableSlot,
    pub framehead_slot: *mut TupleTableSlot,
    pub frametail_slot: *mut TupleTableSlot,
    pub agg_row_slot: *mut TupleTableSlot,
    pub temp_slot_1: *mut TupleTableSlot,
    pub temp_slot_2: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_WindowAggState() {
    assert_eq!(
        ::std::mem::size_of::<WindowAggState>(),
        568usize,
        concat!("Size of: ", stringify!(WindowAggState))
    );
    assert_eq!(
        ::std::mem::align_of::<WindowAggState>(),
        8usize,
        concat!("Alignment of ", stringify!(WindowAggState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).funcs as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).numfuncs as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(numfuncs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).numaggs as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(numaggs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).perfunc as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(perfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).peragg as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(peragg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).partEqfunction as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(partEqfunction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).ordEqfunction as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(ordEqfunction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).buffer as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).current_ptr as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(current_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).framehead_ptr as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(framehead_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).frametail_ptr as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(frametail_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).grouptail_ptr as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(grouptail_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).spooled_rows as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(spooled_rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).currentpos as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(currentpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).frameheadpos as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(frameheadpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).frametailpos as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(frametailpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).agg_winobj as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(agg_winobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).aggregatedbase as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(aggregatedbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).aggregatedupto as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(aggregatedupto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).frameOptions as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(frameOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).startOffset as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(startOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).endOffset as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(endOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).startOffsetValue as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(startOffsetValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).endOffsetValue as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(endOffsetValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).startInRangeFunc as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(startInRangeFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).endInRangeFunc as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(endInRangeFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).inRangeColl as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(inRangeColl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).inRangeAsc as *const _ as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(inRangeAsc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowAggState>())).inRangeNullsFirst as *const _ as usize
        },
        437usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(inRangeNullsFirst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).currentgroup as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(currentgroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).frameheadgroup as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(frameheadgroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).frametailgroup as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(frametailgroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).groupheadpos as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(groupheadpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).grouptailpos as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(grouptailpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).partcontext as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(partcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).aggcontext as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(aggcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).curaggcontext as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(curaggcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).tmpcontext as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(tmpcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).all_first as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(all_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).all_done as *const _ as usize },
        513usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(all_done)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WindowAggState>())).partition_spooled as *const _ as usize
        },
        514usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(partition_spooled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).more_partitions as *const _ as usize },
        515usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(more_partitions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).framehead_valid as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(framehead_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).frametail_valid as *const _ as usize },
        517usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(frametail_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).grouptail_valid as *const _ as usize },
        518usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(grouptail_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).first_part_slot as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(first_part_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).framehead_slot as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(framehead_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).frametail_slot as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(frametail_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).agg_row_slot as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(agg_row_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).temp_slot_1 as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(temp_slot_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WindowAggState>())).temp_slot_2 as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(WindowAggState),
            "::",
            stringify!(temp_slot_2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UniqueState {
    pub ps: PlanState,
    pub eqfunction: *mut ExprState,
}
#[test]
fn bindgen_test_layout_UniqueState() {
    assert_eq!(
        ::std::mem::size_of::<UniqueState>(),
        152usize,
        concat!("Size of: ", stringify!(UniqueState))
    );
    assert_eq!(
        ::std::mem::align_of::<UniqueState>(),
        8usize,
        concat!("Alignment of ", stringify!(UniqueState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UniqueState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UniqueState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UniqueState>())).eqfunction as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(UniqueState),
            "::",
            stringify!(eqfunction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherState {
    pub ps: PlanState,
    pub initialized: bool,
    pub need_to_scan_locally: bool,
    pub tuples_needed: int64,
    pub funnel_slot: *mut TupleTableSlot,
    pub pei: *mut ParallelExecutorInfo,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub nreaders: ::std::os::raw::c_int,
    pub nextreader: ::std::os::raw::c_int,
    pub reader: *mut *mut TupleQueueReader,
}
#[test]
fn bindgen_test_layout_GatherState() {
    assert_eq!(
        ::std::mem::size_of::<GatherState>(),
        200usize,
        concat!("Size of: ", stringify!(GatherState))
    );
    assert_eq!(
        ::std::mem::align_of::<GatherState>(),
        8usize,
        concat!("Alignment of ", stringify!(GatherState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherState>())).initialized as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherState),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GatherState>())).need_to_scan_locally as *const _ as usize
        },
        145usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherState),
            "::",
            stringify!(need_to_scan_locally)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherState>())).tuples_needed as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherState),
            "::",
            stringify!(tuples_needed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherState>())).funnel_slot as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherState),
            "::",
            stringify!(funnel_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherState>())).pei as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherState),
            "::",
            stringify!(pei)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherState>())).nworkers_launched as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherState),
            "::",
            stringify!(nworkers_launched)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherState>())).nreaders as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherState),
            "::",
            stringify!(nreaders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherState>())).nextreader as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherState),
            "::",
            stringify!(nextreader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherState>())).reader as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherState),
            "::",
            stringify!(reader)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GMReaderTupleBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherMergeState {
    pub ps: PlanState,
    pub initialized: bool,
    pub gm_initialized: bool,
    pub need_to_scan_locally: bool,
    pub tuples_needed: int64,
    pub tupDesc: TupleDesc,
    pub gm_nkeys: ::std::os::raw::c_int,
    pub gm_sortkeys: SortSupport,
    pub pei: *mut ParallelExecutorInfo,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub nreaders: ::std::os::raw::c_int,
    pub gm_slots: *mut *mut TupleTableSlot,
    pub reader: *mut *mut TupleQueueReader,
    pub gm_tuple_buffers: *mut GMReaderTupleBuffer,
    pub gm_heap: *mut binaryheap,
}
#[test]
fn bindgen_test_layout_GatherMergeState() {
    assert_eq!(
        ::std::mem::size_of::<GatherMergeState>(),
        232usize,
        concat!("Size of: ", stringify!(GatherMergeState))
    );
    assert_eq!(
        ::std::mem::align_of::<GatherMergeState>(),
        8usize,
        concat!("Alignment of ", stringify!(GatherMergeState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).initialized as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).gm_initialized as *const _ as usize },
        145usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(gm_initialized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GatherMergeState>())).need_to_scan_locally as *const _ as usize
        },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(need_to_scan_locally)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).tuples_needed as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(tuples_needed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).tupDesc as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(tupDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).gm_nkeys as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(gm_nkeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).gm_sortkeys as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(gm_sortkeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).pei as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(pei)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GatherMergeState>())).nworkers_launched as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(nworkers_launched)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).nreaders as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(nreaders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).gm_slots as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(gm_slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).reader as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(reader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GatherMergeState>())).gm_tuple_buffers as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(gm_tuple_buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GatherMergeState>())).gm_heap as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(GatherMergeState),
            "::",
            stringify!(gm_heap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashInstrumentation {
    pub nbuckets: ::std::os::raw::c_int,
    pub nbuckets_original: ::std::os::raw::c_int,
    pub nbatch: ::std::os::raw::c_int,
    pub nbatch_original: ::std::os::raw::c_int,
    pub space_peak: usize,
}
#[test]
fn bindgen_test_layout_HashInstrumentation() {
    assert_eq!(
        ::std::mem::size_of::<HashInstrumentation>(),
        24usize,
        concat!("Size of: ", stringify!(HashInstrumentation))
    );
    assert_eq!(
        ::std::mem::align_of::<HashInstrumentation>(),
        8usize,
        concat!("Alignment of ", stringify!(HashInstrumentation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashInstrumentation>())).nbuckets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HashInstrumentation),
            "::",
            stringify!(nbuckets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HashInstrumentation>())).nbuckets_original as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HashInstrumentation),
            "::",
            stringify!(nbuckets_original)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashInstrumentation>())).nbatch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HashInstrumentation),
            "::",
            stringify!(nbatch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HashInstrumentation>())).nbatch_original as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HashInstrumentation),
            "::",
            stringify!(nbatch_original)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashInstrumentation>())).space_peak as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HashInstrumentation),
            "::",
            stringify!(space_peak)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct SharedHashInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub hinstrument: __IncompleteArrayField<HashInstrumentation>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_SharedHashInfo() {
    assert_eq!(
        ::std::mem::size_of::<SharedHashInfo>(),
        8usize,
        concat!("Size of: ", stringify!(SharedHashInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SharedHashInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SharedHashInfo))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashState {
    pub ps: PlanState,
    pub hashtable: HashJoinTable,
    pub hashkeys: *mut List,
    pub shared_info: *mut SharedHashInfo,
    pub hinstrument: *mut HashInstrumentation,
    pub parallel_state: *mut ParallelHashJoinState,
}
#[test]
fn bindgen_test_layout_HashState() {
    assert_eq!(
        ::std::mem::size_of::<HashState>(),
        184usize,
        concat!("Size of: ", stringify!(HashState))
    );
    assert_eq!(
        ::std::mem::align_of::<HashState>(),
        8usize,
        concat!("Alignment of ", stringify!(HashState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HashState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashState>())).hashtable as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(HashState),
            "::",
            stringify!(hashtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashState>())).hashkeys as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(HashState),
            "::",
            stringify!(hashkeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashState>())).shared_info as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(HashState),
            "::",
            stringify!(shared_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashState>())).hinstrument as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(HashState),
            "::",
            stringify!(hinstrument)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HashState>())).parallel_state as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(HashState),
            "::",
            stringify!(parallel_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpStatePerGroupData {
    _unused: [u8; 0],
}
pub type SetOpStatePerGroup = *mut SetOpStatePerGroupData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpState {
    pub ps: PlanState,
    pub eqfunction: *mut ExprState,
    pub eqfuncoids: *mut Oid,
    pub hashfunctions: *mut FmgrInfo,
    pub setop_done: bool,
    pub numOutput: ::std::os::raw::c_long,
    pub pergroup: SetOpStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
    pub table_filled: bool,
    pub hashiter: TupleHashIterator,
}
#[test]
fn bindgen_test_layout_SetOpState() {
    assert_eq!(
        ::std::mem::size_of::<SetOpState>(),
        232usize,
        concat!("Size of: ", stringify!(SetOpState))
    );
    assert_eq!(
        ::std::mem::align_of::<SetOpState>(),
        8usize,
        concat!("Alignment of ", stringify!(SetOpState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).eqfunction as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(eqfunction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).eqfuncoids as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(eqfuncoids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).hashfunctions as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(hashfunctions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).setop_done as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(setop_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).numOutput as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(numOutput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).pergroup as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(pergroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).grp_firstTuple as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(grp_firstTuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).hashtable as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(hashtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).tableContext as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(tableContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).table_filled as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(table_filled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SetOpState>())).hashiter as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(SetOpState),
            "::",
            stringify!(hashiter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRowsState {
    pub ps: PlanState,
    pub lr_arowMarks: *mut List,
    pub lr_epqstate: EPQState,
    pub lr_curtuples: *mut HeapTuple,
    pub lr_ntables: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LockRowsState() {
    assert_eq!(
        ::std::mem::size_of::<LockRowsState>(),
        216usize,
        concat!("Size of: ", stringify!(LockRowsState))
    );
    assert_eq!(
        ::std::mem::align_of::<LockRowsState>(),
        8usize,
        concat!("Alignment of ", stringify!(LockRowsState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockRowsState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LockRowsState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockRowsState>())).lr_arowMarks as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(LockRowsState),
            "::",
            stringify!(lr_arowMarks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockRowsState>())).lr_epqstate as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(LockRowsState),
            "::",
            stringify!(lr_epqstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockRowsState>())).lr_curtuples as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(LockRowsState),
            "::",
            stringify!(lr_curtuples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LockRowsState>())).lr_ntables as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(LockRowsState),
            "::",
            stringify!(lr_ntables)
        )
    );
}
pub const LimitStateCond_LIMIT_INITIAL: LimitStateCond = 0;
pub const LimitStateCond_LIMIT_RESCAN: LimitStateCond = 1;
pub const LimitStateCond_LIMIT_EMPTY: LimitStateCond = 2;
pub const LimitStateCond_LIMIT_INWINDOW: LimitStateCond = 3;
pub const LimitStateCond_LIMIT_SUBPLANEOF: LimitStateCond = 4;
pub const LimitStateCond_LIMIT_WINDOWEND: LimitStateCond = 5;
pub const LimitStateCond_LIMIT_WINDOWSTART: LimitStateCond = 6;
pub type LimitStateCond = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LimitState {
    pub ps: PlanState,
    pub limitOffset: *mut ExprState,
    pub limitCount: *mut ExprState,
    pub offset: int64,
    pub count: int64,
    pub noCount: bool,
    pub lstate: LimitStateCond,
    pub position: int64,
    pub subSlot: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_LimitState() {
    assert_eq!(
        ::std::mem::size_of::<LimitState>(),
        200usize,
        concat!("Size of: ", stringify!(LimitState))
    );
    assert_eq!(
        ::std::mem::align_of::<LimitState>(),
        8usize,
        concat!("Alignment of ", stringify!(LimitState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LimitState>())).ps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LimitState),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LimitState>())).limitOffset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(LimitState),
            "::",
            stringify!(limitOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LimitState>())).limitCount as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(LimitState),
            "::",
            stringify!(limitCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LimitState>())).offset as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(LimitState),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LimitState>())).count as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(LimitState),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LimitState>())).noCount as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(LimitState),
            "::",
            stringify!(noCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LimitState>())).lstate as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(LimitState),
            "::",
            stringify!(lstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LimitState>())).position as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(LimitState),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LimitState>())).subSlot as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(LimitState),
            "::",
            stringify!(subSlot)
        )
    );
}
pub type TriggerEvent = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerData {
    pub type_: NodeTag,
    pub tg_event: TriggerEvent,
    pub tg_relation: Relation,
    pub tg_trigtuple: HeapTuple,
    pub tg_newtuple: HeapTuple,
    pub tg_trigger: *mut Trigger,
    pub tg_trigtuplebuf: Buffer,
    pub tg_newtuplebuf: Buffer,
    pub tg_oldtable: *mut Tuplestorestate,
    pub tg_newtable: *mut Tuplestorestate,
}
#[test]
fn bindgen_test_layout_TriggerData() {
    assert_eq!(
        ::std::mem::size_of::<TriggerData>(),
        64usize,
        concat!("Size of: ", stringify!(TriggerData))
    );
    assert_eq!(
        ::std::mem::align_of::<TriggerData>(),
        8usize,
        concat!("Alignment of ", stringify!(TriggerData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerData>())).tg_event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerData),
            "::",
            stringify!(tg_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerData>())).tg_relation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerData),
            "::",
            stringify!(tg_relation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerData>())).tg_trigtuple as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerData),
            "::",
            stringify!(tg_trigtuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerData>())).tg_newtuple as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerData),
            "::",
            stringify!(tg_newtuple)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerData>())).tg_trigger as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerData),
            "::",
            stringify!(tg_trigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerData>())).tg_trigtuplebuf as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerData),
            "::",
            stringify!(tg_trigtuplebuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerData>())).tg_newtuplebuf as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerData),
            "::",
            stringify!(tg_newtuplebuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerData>())).tg_oldtable as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerData),
            "::",
            stringify!(tg_oldtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TriggerData>())).tg_newtable as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TriggerData),
            "::",
            stringify!(tg_newtable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AfterTriggersTableData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TransitionCaptureState {
    pub tcs_delete_old_table: bool,
    pub tcs_update_old_table: bool,
    pub tcs_update_new_table: bool,
    pub tcs_insert_new_table: bool,
    pub tcs_map: *mut TupleConversionMap,
    pub tcs_original_insert_tuple: HeapTuple,
    pub tcs_private: *mut AfterTriggersTableData,
}
#[test]
fn bindgen_test_layout_TransitionCaptureState() {
    assert_eq!(
        ::std::mem::size_of::<TransitionCaptureState>(),
        32usize,
        concat!("Size of: ", stringify!(TransitionCaptureState))
    );
    assert_eq!(
        ::std::mem::align_of::<TransitionCaptureState>(),
        8usize,
        concat!("Alignment of ", stringify!(TransitionCaptureState))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TransitionCaptureState>())).tcs_delete_old_table as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TransitionCaptureState),
            "::",
            stringify!(tcs_delete_old_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TransitionCaptureState>())).tcs_update_old_table as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(TransitionCaptureState),
            "::",
            stringify!(tcs_update_old_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TransitionCaptureState>())).tcs_update_new_table as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TransitionCaptureState),
            "::",
            stringify!(tcs_update_new_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TransitionCaptureState>())).tcs_insert_new_table as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(TransitionCaptureState),
            "::",
            stringify!(tcs_insert_new_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TransitionCaptureState>())).tcs_map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TransitionCaptureState),
            "::",
            stringify!(tcs_map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TransitionCaptureState>())).tcs_original_insert_tuple as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TransitionCaptureState),
            "::",
            stringify!(tcs_original_insert_tuple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TransitionCaptureState>())).tcs_private as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TransitionCaptureState),
            "::",
            stringify!(tcs_private)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_SessionReplicationRole"]
    pub static mut SessionReplicationRole: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_CreateTrigger"]
    pub fn CreateTrigger(
        stmt: *mut CreateTrigStmt,
        queryString: *const ::std::os::raw::c_char,
        relOid: Oid,
        refRelOid: Oid,
        constraintOid: Oid,
        indexOid: Oid,
        funcoid: Oid,
        parentTriggerOid: Oid,
        whenClause: *mut Node,
        isInternal: bool,
        in_partition: bool,
    ) -> ObjectAddress;
}
extern "C" {
    #[link_name = "\u{1}_RemoveTriggerById"]
    pub fn RemoveTriggerById(trigOid: Oid);
}
extern "C" {
    #[link_name = "\u{1}_get_trigger_oid"]
    pub fn get_trigger_oid(
        relid: Oid,
        name: *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_renametrig"]
    pub fn renametrig(stmt: *mut RenameStmt) -> ObjectAddress;
}
extern "C" {
    #[link_name = "\u{1}_EnableDisableTrigger"]
    pub fn EnableDisableTrigger(
        rel: Relation,
        tgname: *const ::std::os::raw::c_char,
        fires_when: ::std::os::raw::c_char,
        skip_system: bool,
        lockmode: LOCKMODE,
    );
}
extern "C" {
    #[link_name = "\u{1}_RelationBuildTriggers"]
    pub fn RelationBuildTriggers(relation: Relation);
}
extern "C" {
    #[link_name = "\u{1}_CopyTriggerDesc"]
    pub fn CopyTriggerDesc(trigdesc: *mut TriggerDesc) -> *mut TriggerDesc;
}
extern "C" {
    #[link_name = "\u{1}_FindTriggerIncompatibleWithInheritance"]
    pub fn FindTriggerIncompatibleWithInheritance(
        trigdesc: *mut TriggerDesc,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_MakeTransitionCaptureState"]
    pub fn MakeTransitionCaptureState(
        trigdesc: *mut TriggerDesc,
        relid: Oid,
        cmdType: CmdType,
    ) -> *mut TransitionCaptureState;
}
extern "C" {
    #[link_name = "\u{1}_FreeTriggerDesc"]
    pub fn FreeTriggerDesc(trigdesc: *mut TriggerDesc);
}
extern "C" {
    #[link_name = "\u{1}_ExecBSInsertTriggers"]
    pub fn ExecBSInsertTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
}
extern "C" {
    #[link_name = "\u{1}_ExecASInsertTriggers"]
    pub fn ExecASInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        transition_capture: *mut TransitionCaptureState,
    );
}
extern "C" {
    #[link_name = "\u{1}_ExecBRInsertTriggers"]
    pub fn ExecBRInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecARInsertTriggers"]
    pub fn ExecARInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        trigtuple: HeapTuple,
        recheckIndexes: *mut List,
        transition_capture: *mut TransitionCaptureState,
    );
}
extern "C" {
    #[link_name = "\u{1}_ExecIRInsertTriggers"]
    pub fn ExecIRInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecBSDeleteTriggers"]
    pub fn ExecBSDeleteTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
}
extern "C" {
    #[link_name = "\u{1}_ExecASDeleteTriggers"]
    pub fn ExecASDeleteTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        transition_capture: *mut TransitionCaptureState,
    );
}
extern "C" {
    #[link_name = "\u{1}_ExecBRDeleteTriggers"]
    pub fn ExecBRDeleteTriggers(
        estate: *mut EState,
        epqstate: *mut EPQState,
        relinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        epqslot: *mut *mut TupleTableSlot,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ExecARDeleteTriggers"]
    pub fn ExecARDeleteTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        transition_capture: *mut TransitionCaptureState,
    );
}
extern "C" {
    #[link_name = "\u{1}_ExecIRDeleteTriggers"]
    pub fn ExecIRDeleteTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        trigtuple: HeapTuple,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ExecBSUpdateTriggers"]
    pub fn ExecBSUpdateTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
}
extern "C" {
    #[link_name = "\u{1}_ExecASUpdateTriggers"]
    pub fn ExecASUpdateTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        transition_capture: *mut TransitionCaptureState,
    );
}
extern "C" {
    #[link_name = "\u{1}_ExecBRUpdateTriggers"]
    pub fn ExecBRUpdateTriggers(
        estate: *mut EState,
        epqstate: *mut EPQState,
        relinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        slot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecARUpdateTriggers"]
    pub fn ExecARUpdateTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        newtuple: HeapTuple,
        recheckIndexes: *mut List,
        transition_capture: *mut TransitionCaptureState,
    );
}
extern "C" {
    #[link_name = "\u{1}_ExecIRUpdateTriggers"]
    pub fn ExecIRUpdateTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        trigtuple: HeapTuple,
        slot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
}
extern "C" {
    #[link_name = "\u{1}_ExecBSTruncateTriggers"]
    pub fn ExecBSTruncateTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
}
extern "C" {
    #[link_name = "\u{1}_ExecASTruncateTriggers"]
    pub fn ExecASTruncateTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
}
extern "C" {
    #[link_name = "\u{1}_AfterTriggerBeginXact"]
    pub fn AfterTriggerBeginXact();
}
extern "C" {
    #[link_name = "\u{1}_AfterTriggerBeginQuery"]
    pub fn AfterTriggerBeginQuery();
}
extern "C" {
    #[link_name = "\u{1}_AfterTriggerEndQuery"]
    pub fn AfterTriggerEndQuery(estate: *mut EState);
}
extern "C" {
    #[link_name = "\u{1}_AfterTriggerFireDeferred"]
    pub fn AfterTriggerFireDeferred();
}
extern "C" {
    #[link_name = "\u{1}_AfterTriggerEndXact"]
    pub fn AfterTriggerEndXact(isCommit: bool);
}
extern "C" {
    #[link_name = "\u{1}_AfterTriggerBeginSubXact"]
    pub fn AfterTriggerBeginSubXact();
}
extern "C" {
    #[link_name = "\u{1}_AfterTriggerEndSubXact"]
    pub fn AfterTriggerEndSubXact(isCommit: bool);
}
extern "C" {
    #[link_name = "\u{1}_AfterTriggerSetState"]
    pub fn AfterTriggerSetState(stmt: *mut ConstraintsSetStmt);
}
extern "C" {
    #[link_name = "\u{1}_AfterTriggerPendingOnRel"]
    pub fn AfterTriggerPendingOnRel(relid: Oid) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_pk_upd_check_required"]
    pub fn RI_FKey_pk_upd_check_required(
        trigger: *mut Trigger,
        pk_rel: Relation,
        old_row: HeapTuple,
        new_row: HeapTuple,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_fk_upd_check_required"]
    pub fn RI_FKey_fk_upd_check_required(
        trigger: *mut Trigger,
        fk_rel: Relation,
        old_row: HeapTuple,
        new_row: HeapTuple,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_RI_Initial_Check"]
    pub fn RI_Initial_Check(trigger: *mut Trigger, fk_rel: Relation, pk_rel: Relation) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_trigger_type"]
    pub fn RI_FKey_trigger_type(tgfoid: Oid) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_node {
    pub prev: *mut dlist_node,
    pub next: *mut dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_node() {
    assert_eq!(
        ::std::mem::size_of::<dlist_node>(),
        16usize,
        concat!("Size of: ", stringify!(dlist_node))
    );
    assert_eq!(
        ::std::mem::align_of::<dlist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(dlist_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlist_node>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dlist_node),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlist_node>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dlist_node),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_head {
    pub head: dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_head() {
    assert_eq!(
        ::std::mem::size_of::<dlist_head>(),
        16usize,
        concat!("Size of: ", stringify!(dlist_head))
    );
    assert_eq!(
        ::std::mem::align_of::<dlist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(dlist_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlist_head>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dlist_head),
            "::",
            stringify!(head)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_iter {
    pub cur: *mut dlist_node,
    pub end: *mut dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_iter() {
    assert_eq!(
        ::std::mem::size_of::<dlist_iter>(),
        16usize,
        concat!("Size of: ", stringify!(dlist_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<dlist_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(dlist_iter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlist_iter>())).cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dlist_iter),
            "::",
            stringify!(cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlist_iter>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dlist_iter),
            "::",
            stringify!(end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_mutable_iter {
    pub cur: *mut dlist_node,
    pub next: *mut dlist_node,
    pub end: *mut dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_mutable_iter() {
    assert_eq!(
        ::std::mem::size_of::<dlist_mutable_iter>(),
        24usize,
        concat!("Size of: ", stringify!(dlist_mutable_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<dlist_mutable_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(dlist_mutable_iter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlist_mutable_iter>())).cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dlist_mutable_iter),
            "::",
            stringify!(cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlist_mutable_iter>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dlist_mutable_iter),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dlist_mutable_iter>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dlist_mutable_iter),
            "::",
            stringify!(end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_node {
    pub next: *mut slist_node,
}
#[test]
fn bindgen_test_layout_slist_node() {
    assert_eq!(
        ::std::mem::size_of::<slist_node>(),
        8usize,
        concat!("Size of: ", stringify!(slist_node))
    );
    assert_eq!(
        ::std::mem::align_of::<slist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(slist_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slist_node),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_head {
    pub head: slist_node,
}
#[test]
fn bindgen_test_layout_slist_head() {
    assert_eq!(
        ::std::mem::size_of::<slist_head>(),
        8usize,
        concat!("Size of: ", stringify!(slist_head))
    );
    assert_eq!(
        ::std::mem::align_of::<slist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(slist_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slist_head>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slist_head),
            "::",
            stringify!(head)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_iter {
    pub cur: *mut slist_node,
}
#[test]
fn bindgen_test_layout_slist_iter() {
    assert_eq!(
        ::std::mem::size_of::<slist_iter>(),
        8usize,
        concat!("Size of: ", stringify!(slist_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<slist_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(slist_iter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slist_iter>())).cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slist_iter),
            "::",
            stringify!(cur)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_mutable_iter {
    pub cur: *mut slist_node,
    pub next: *mut slist_node,
    pub prev: *mut slist_node,
}
#[test]
fn bindgen_test_layout_slist_mutable_iter() {
    assert_eq!(
        ::std::mem::size_of::<slist_mutable_iter>(),
        24usize,
        concat!("Size of: ", stringify!(slist_mutable_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<slist_mutable_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(slist_mutable_iter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slist_mutable_iter>())).cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slist_mutable_iter),
            "::",
            stringify!(cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slist_mutable_iter>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slist_mutable_iter),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slist_mutable_iter>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(slist_mutable_iter),
            "::",
            stringify!(prev)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_slist_delete"]
    pub fn slist_delete(head: *mut slist_head, node: *mut slist_node);
}
pub const CommandDest_DestNone: CommandDest = 0;
pub const CommandDest_DestDebug: CommandDest = 1;
pub const CommandDest_DestRemote: CommandDest = 2;
pub const CommandDest_DestRemoteExecute: CommandDest = 3;
pub const CommandDest_DestRemoteSimple: CommandDest = 4;
pub const CommandDest_DestSPI: CommandDest = 5;
pub const CommandDest_DestTuplestore: CommandDest = 6;
pub const CommandDest_DestIntoRel: CommandDest = 7;
pub const CommandDest_DestCopyOut: CommandDest = 8;
pub const CommandDest_DestSQLFunction: CommandDest = 9;
pub const CommandDest_DestTransientRel: CommandDest = 10;
pub const CommandDest_DestTupleQueue: CommandDest = 11;
pub type CommandDest = u32;
pub type DestReceiver = _DestReceiver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DestReceiver {
    pub receiveSlot: ::std::option::Option<
        unsafe extern "C" fn(slot: *mut TupleTableSlot, self_: *mut DestReceiver) -> bool,
    >,
    pub rStartup: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut DestReceiver,
            operation: ::std::os::raw::c_int,
            typeinfo: TupleDesc,
        ),
    >,
    pub rShutdown: ::std::option::Option<unsafe extern "C" fn(self_: *mut DestReceiver)>,
    pub rDestroy: ::std::option::Option<unsafe extern "C" fn(self_: *mut DestReceiver)>,
    pub mydest: CommandDest,
}
#[test]
fn bindgen_test_layout__DestReceiver() {
    assert_eq!(
        ::std::mem::size_of::<_DestReceiver>(),
        40usize,
        concat!("Size of: ", stringify!(_DestReceiver))
    );
    assert_eq!(
        ::std::mem::align_of::<_DestReceiver>(),
        8usize,
        concat!("Alignment of ", stringify!(_DestReceiver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DestReceiver>())).receiveSlot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DestReceiver),
            "::",
            stringify!(receiveSlot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DestReceiver>())).rStartup as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DestReceiver),
            "::",
            stringify!(rStartup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DestReceiver>())).rShutdown as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DestReceiver),
            "::",
            stringify!(rShutdown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DestReceiver>())).rDestroy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DestReceiver),
            "::",
            stringify!(rDestroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DestReceiver>())).mydest as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DestReceiver),
            "::",
            stringify!(mydest)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_None_Receiver"]
    pub static mut None_Receiver: *mut DestReceiver;
}
extern "C" {
    #[link_name = "\u{1}_BeginCommand"]
    pub fn BeginCommand(commandTag: *const ::std::os::raw::c_char, dest: CommandDest);
}
extern "C" {
    #[link_name = "\u{1}_CreateDestReceiver"]
    pub fn CreateDestReceiver(dest: CommandDest) -> *mut DestReceiver;
}
extern "C" {
    #[link_name = "\u{1}_EndCommand"]
    pub fn EndCommand(commandTag: *const ::std::os::raw::c_char, dest: CommandDest);
}
extern "C" {
    #[link_name = "\u{1}_NullCommand"]
    pub fn NullCommand(dest: CommandDest);
}
extern "C" {
    #[link_name = "\u{1}_ReadyForQuery"]
    pub fn ReadyForQuery(dest: CommandDest);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryDesc {
    pub operation: CmdType,
    pub plannedstmt: *mut PlannedStmt,
    pub sourceText: *const ::std::os::raw::c_char,
    pub snapshot: Snapshot,
    pub crosscheck_snapshot: Snapshot,
    pub dest: *mut DestReceiver,
    pub params: ParamListInfo,
    pub queryEnv: *mut QueryEnvironment,
    pub instrument_options: ::std::os::raw::c_int,
    pub tupDesc: TupleDesc,
    pub estate: *mut EState,
    pub planstate: *mut PlanState,
    pub already_executed: bool,
    pub totaltime: *mut Instrumentation,
}
#[test]
fn bindgen_test_layout_QueryDesc() {
    assert_eq!(
        ::std::mem::size_of::<QueryDesc>(),
        112usize,
        concat!("Size of: ", stringify!(QueryDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<QueryDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(QueryDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).operation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).plannedstmt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(plannedstmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).sourceText as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(sourceText)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).snapshot as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(snapshot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).crosscheck_snapshot as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(crosscheck_snapshot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).dest as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).params as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).queryEnv as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(queryEnv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).instrument_options as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(instrument_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).tupDesc as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(tupDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).estate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(estate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).planstate as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(planstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).already_executed as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(already_executed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<QueryDesc>())).totaltime as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(QueryDesc),
            "::",
            stringify!(totaltime)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_CreateQueryDesc"]
    pub fn CreateQueryDesc(
        plannedstmt: *mut PlannedStmt,
        sourceText: *const ::std::os::raw::c_char,
        snapshot: Snapshot,
        crosscheck_snapshot: Snapshot,
        dest: *mut DestReceiver,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        instrument_options: ::std::os::raw::c_int,
    ) -> *mut QueryDesc;
}
extern "C" {
    #[link_name = "\u{1}_FreeQueryDesc"]
    pub fn FreeQueryDesc(qdesc: *mut QueryDesc);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CachedPlanSource {
    pub magic: ::std::os::raw::c_int,
    pub raw_parse_tree: *mut RawStmt,
    pub query_string: *const ::std::os::raw::c_char,
    pub commandTag: *const ::std::os::raw::c_char,
    pub param_types: *mut Oid,
    pub num_params: ::std::os::raw::c_int,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::std::os::raw::c_void,
    pub cursor_options: ::std::os::raw::c_int,
    pub fixed_result: bool,
    pub resultDesc: TupleDesc,
    pub context: MemoryContext,
    pub query_list: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub search_path: *mut OverrideSearchPath,
    pub query_context: MemoryContext,
    pub rewriteRoleId: Oid,
    pub rewriteRowSecurity: bool,
    pub dependsOnRLS: bool,
    pub gplan: *mut CachedPlan,
    pub is_oneshot: bool,
    pub is_complete: bool,
    pub is_saved: bool,
    pub is_valid: bool,
    pub generation: ::std::os::raw::c_int,
    pub next_saved: *mut CachedPlanSource,
    pub generic_cost: f64,
    pub total_custom_cost: f64,
    pub num_custom_plans: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CachedPlanSource() {
    assert_eq!(
        ::std::mem::size_of::<CachedPlanSource>(),
        184usize,
        concat!("Size of: ", stringify!(CachedPlanSource))
    );
    assert_eq!(
        ::std::mem::align_of::<CachedPlanSource>(),
        8usize,
        concat!("Alignment of ", stringify!(CachedPlanSource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).raw_parse_tree as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(raw_parse_tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).query_string as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(query_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).commandTag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(commandTag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).param_types as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(param_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).num_params as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(num_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).parserSetup as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(parserSetup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).parserSetupArg as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(parserSetupArg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).cursor_options as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(cursor_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).fixed_result as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(fixed_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).resultDesc as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(resultDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).context as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).query_list as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(query_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).relationOids as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(relationOids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).invalItems as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(invalItems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).search_path as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(search_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).query_context as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(query_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).rewriteRoleId as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(rewriteRoleId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CachedPlanSource>())).rewriteRowSecurity as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(rewriteRowSecurity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).dependsOnRLS as *const _ as usize },
        133usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(dependsOnRLS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).gplan as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(gplan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).is_oneshot as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(is_oneshot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).is_complete as *const _ as usize },
        145usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(is_complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).is_saved as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(is_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).is_valid as *const _ as usize },
        147usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).generation as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(generation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).next_saved as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(next_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlanSource>())).generic_cost as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(generic_cost)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CachedPlanSource>())).total_custom_cost as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(total_custom_cost)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CachedPlanSource>())).num_custom_plans as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlanSource),
            "::",
            stringify!(num_custom_plans)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CachedPlan {
    pub magic: ::std::os::raw::c_int,
    pub stmt_list: *mut List,
    pub is_oneshot: bool,
    pub is_saved: bool,
    pub is_valid: bool,
    pub planRoleId: Oid,
    pub dependsOnRole: bool,
    pub saved_xmin: TransactionId,
    pub generation: ::std::os::raw::c_int,
    pub refcount: ::std::os::raw::c_int,
    pub context: MemoryContext,
}
#[test]
fn bindgen_test_layout_CachedPlan() {
    assert_eq!(
        ::std::mem::size_of::<CachedPlan>(),
        48usize,
        concat!("Size of: ", stringify!(CachedPlan))
    );
    assert_eq!(
        ::std::mem::align_of::<CachedPlan>(),
        8usize,
        concat!("Alignment of ", stringify!(CachedPlan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlan>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlan),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlan>())).stmt_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlan),
            "::",
            stringify!(stmt_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlan>())).is_oneshot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlan),
            "::",
            stringify!(is_oneshot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlan>())).is_saved as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlan),
            "::",
            stringify!(is_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlan>())).is_valid as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlan),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlan>())).planRoleId as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlan),
            "::",
            stringify!(planRoleId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlan>())).dependsOnRole as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlan),
            "::",
            stringify!(dependsOnRole)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlan>())).saved_xmin as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlan),
            "::",
            stringify!(saved_xmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlan>())).generation as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlan),
            "::",
            stringify!(generation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlan>())).refcount as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlan),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CachedPlan>())).context as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CachedPlan),
            "::",
            stringify!(context)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_InitPlanCache"]
    pub fn InitPlanCache();
}
extern "C" {
    #[link_name = "\u{1}_ResetPlanCache"]
    pub fn ResetPlanCache();
}
extern "C" {
    #[link_name = "\u{1}_CreateCachedPlan"]
    pub fn CreateCachedPlan(
        raw_parse_tree: *mut RawStmt,
        query_string: *const ::std::os::raw::c_char,
        commandTag: *const ::std::os::raw::c_char,
    ) -> *mut CachedPlanSource;
}
extern "C" {
    #[link_name = "\u{1}_CreateOneShotCachedPlan"]
    pub fn CreateOneShotCachedPlan(
        raw_parse_tree: *mut RawStmt,
        query_string: *const ::std::os::raw::c_char,
        commandTag: *const ::std::os::raw::c_char,
    ) -> *mut CachedPlanSource;
}
extern "C" {
    #[link_name = "\u{1}_CompleteCachedPlan"]
    pub fn CompleteCachedPlan(
        plansource: *mut CachedPlanSource,
        querytree_list: *mut List,
        querytree_context: MemoryContext,
        param_types: *mut Oid,
        num_params: ::std::os::raw::c_int,
        parserSetup: ParserSetupHook,
        parserSetupArg: *mut ::std::os::raw::c_void,
        cursor_options: ::std::os::raw::c_int,
        fixed_result: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_SaveCachedPlan"]
    pub fn SaveCachedPlan(plansource: *mut CachedPlanSource);
}
extern "C" {
    #[link_name = "\u{1}_DropCachedPlan"]
    pub fn DropCachedPlan(plansource: *mut CachedPlanSource);
}
extern "C" {
    #[link_name = "\u{1}_CachedPlanSetParentContext"]
    pub fn CachedPlanSetParentContext(plansource: *mut CachedPlanSource, newcontext: MemoryContext);
}
extern "C" {
    #[link_name = "\u{1}_CopyCachedPlan"]
    pub fn CopyCachedPlan(plansource: *mut CachedPlanSource) -> *mut CachedPlanSource;
}
extern "C" {
    #[link_name = "\u{1}_CachedPlanIsValid"]
    pub fn CachedPlanIsValid(plansource: *mut CachedPlanSource) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_CachedPlanGetTargetList"]
    pub fn CachedPlanGetTargetList(
        plansource: *mut CachedPlanSource,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_GetCachedPlan"]
    pub fn GetCachedPlan(
        plansource: *mut CachedPlanSource,
        boundParams: ParamListInfo,
        useResOwner: bool,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut CachedPlan;
}
extern "C" {
    #[link_name = "\u{1}_ReleaseCachedPlan"]
    pub fn ReleaseCachedPlan(plan: *mut CachedPlan, useResOwner: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceOwnerData {
    _unused: [u8; 0],
}
pub type ResourceOwner = *mut ResourceOwnerData;
extern "C" {
    #[link_name = "\u{1}_CurrentResourceOwner"]
    pub static mut CurrentResourceOwner: ResourceOwner;
}
extern "C" {
    #[link_name = "\u{1}_CurTransactionResourceOwner"]
    pub static mut CurTransactionResourceOwner: ResourceOwner;
}
extern "C" {
    #[link_name = "\u{1}_TopTransactionResourceOwner"]
    pub static mut TopTransactionResourceOwner: ResourceOwner;
}
pub const ResourceReleasePhase_RESOURCE_RELEASE_BEFORE_LOCKS: ResourceReleasePhase = 0;
pub const ResourceReleasePhase_RESOURCE_RELEASE_LOCKS: ResourceReleasePhase = 1;
pub const ResourceReleasePhase_RESOURCE_RELEASE_AFTER_LOCKS: ResourceReleasePhase = 2;
pub type ResourceReleasePhase = u32;
pub type ResourceReleaseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        phase: ResourceReleasePhase,
        isCommit: bool,
        isTopLevel: bool,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[link_name = "\u{1}_ResourceOwnerCreate"]
    pub fn ResourceOwnerCreate(
        parent: ResourceOwner,
        name: *const ::std::os::raw::c_char,
    ) -> ResourceOwner;
}
extern "C" {
    #[link_name = "\u{1}_ResourceOwnerRelease"]
    pub fn ResourceOwnerRelease(
        owner: ResourceOwner,
        phase: ResourceReleasePhase,
        isCommit: bool,
        isTopLevel: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ResourceOwnerDelete"]
    pub fn ResourceOwnerDelete(owner: ResourceOwner);
}
extern "C" {
    #[link_name = "\u{1}_ResourceOwnerGetParent"]
    pub fn ResourceOwnerGetParent(owner: ResourceOwner) -> ResourceOwner;
}
extern "C" {
    #[link_name = "\u{1}_ResourceOwnerNewParent"]
    pub fn ResourceOwnerNewParent(owner: ResourceOwner, newparent: ResourceOwner);
}
extern "C" {
    #[link_name = "\u{1}_RegisterResourceReleaseCallback"]
    pub fn RegisterResourceReleaseCallback(
        callback: ResourceReleaseCallback,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_UnregisterResourceReleaseCallback"]
    pub fn UnregisterResourceReleaseCallback(
        callback: ResourceReleaseCallback,
        arg: *mut ::std::os::raw::c_void,
    );
}
pub const PortalStrategy_PORTAL_ONE_SELECT: PortalStrategy = 0;
pub const PortalStrategy_PORTAL_ONE_RETURNING: PortalStrategy = 1;
pub const PortalStrategy_PORTAL_ONE_MOD_WITH: PortalStrategy = 2;
pub const PortalStrategy_PORTAL_UTIL_SELECT: PortalStrategy = 3;
pub const PortalStrategy_PORTAL_MULTI_QUERY: PortalStrategy = 4;
pub type PortalStrategy = u32;
pub const PortalStatus_PORTAL_NEW: PortalStatus = 0;
pub const PortalStatus_PORTAL_DEFINED: PortalStatus = 1;
pub const PortalStatus_PORTAL_READY: PortalStatus = 2;
pub const PortalStatus_PORTAL_ACTIVE: PortalStatus = 3;
pub const PortalStatus_PORTAL_DONE: PortalStatus = 4;
pub const PortalStatus_PORTAL_FAILED: PortalStatus = 5;
pub type PortalStatus = u32;
pub type Portal = *mut PortalData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PortalData {
    pub name: *const ::std::os::raw::c_char,
    pub prepStmtName: *const ::std::os::raw::c_char,
    pub portalContext: MemoryContext,
    pub resowner: ResourceOwner,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(portal: Portal)>,
    pub createSubid: SubTransactionId,
    pub activeSubid: SubTransactionId,
    pub sourceText: *const ::std::os::raw::c_char,
    pub commandTag: *const ::std::os::raw::c_char,
    pub stmts: *mut List,
    pub cplan: *mut CachedPlan,
    pub portalParams: ParamListInfo,
    pub queryEnv: *mut QueryEnvironment,
    pub strategy: PortalStrategy,
    pub cursorOptions: ::std::os::raw::c_int,
    pub run_once: bool,
    pub status: PortalStatus,
    pub portalPinned: bool,
    pub autoHeld: bool,
    pub queryDesc: *mut QueryDesc,
    pub tupDesc: TupleDesc,
    pub formats: *mut int16,
    pub holdStore: *mut Tuplestorestate,
    pub holdContext: MemoryContext,
    pub holdSnapshot: Snapshot,
    pub atStart: bool,
    pub atEnd: bool,
    pub portalPos: uint64,
    pub creation_time: TimestampTz,
    pub visible: bool,
}
#[test]
fn bindgen_test_layout_PortalData() {
    assert_eq!(
        ::std::mem::size_of::<PortalData>(),
        200usize,
        concat!("Size of: ", stringify!(PortalData))
    );
    assert_eq!(
        ::std::mem::align_of::<PortalData>(),
        8usize,
        concat!("Alignment of ", stringify!(PortalData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).prepStmtName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(prepStmtName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).portalContext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(portalContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).resowner as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(resowner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).cleanup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).createSubid as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(createSubid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).activeSubid as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(activeSubid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).sourceText as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(sourceText)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).commandTag as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(commandTag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).stmts as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(stmts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).cplan as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(cplan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).portalParams as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(portalParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).queryEnv as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(queryEnv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).strategy as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).cursorOptions as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(cursorOptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).run_once as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(run_once)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).portalPinned as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(portalPinned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).autoHeld as *const _ as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(autoHeld)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).queryDesc as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(queryDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).tupDesc as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(tupDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).formats as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(formats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).holdStore as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(holdStore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).holdContext as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(holdContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).holdSnapshot as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(holdSnapshot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).atStart as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(atStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).atEnd as *const _ as usize },
        169usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(atEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).portalPos as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(portalPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).creation_time as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(creation_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PortalData>())).visible as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(PortalData),
            "::",
            stringify!(visible)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_EnablePortalManager"]
    pub fn EnablePortalManager();
}
extern "C" {
    #[link_name = "\u{1}_PreCommit_Portals"]
    pub fn PreCommit_Portals(isPrepare: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_AtAbort_Portals"]
    pub fn AtAbort_Portals();
}
extern "C" {
    #[link_name = "\u{1}_AtCleanup_Portals"]
    pub fn AtCleanup_Portals();
}
extern "C" {
    #[link_name = "\u{1}_PortalErrorCleanup"]
    pub fn PortalErrorCleanup();
}
extern "C" {
    #[link_name = "\u{1}_AtSubCommit_Portals"]
    pub fn AtSubCommit_Portals(
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        parentXactOwner: ResourceOwner,
    );
}
extern "C" {
    #[link_name = "\u{1}_AtSubAbort_Portals"]
    pub fn AtSubAbort_Portals(
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        myXactOwner: ResourceOwner,
        parentXactOwner: ResourceOwner,
    );
}
extern "C" {
    #[link_name = "\u{1}_AtSubCleanup_Portals"]
    pub fn AtSubCleanup_Portals(mySubid: SubTransactionId);
}
extern "C" {
    #[link_name = "\u{1}_CreatePortal"]
    pub fn CreatePortal(
        name: *const ::std::os::raw::c_char,
        allowDup: bool,
        dupSilent: bool,
    ) -> Portal;
}
extern "C" {
    #[link_name = "\u{1}_CreateNewPortal"]
    pub fn CreateNewPortal() -> Portal;
}
extern "C" {
    #[link_name = "\u{1}_PinPortal"]
    pub fn PinPortal(portal: Portal);
}
extern "C" {
    #[link_name = "\u{1}_UnpinPortal"]
    pub fn UnpinPortal(portal: Portal);
}
extern "C" {
    #[link_name = "\u{1}_MarkPortalActive"]
    pub fn MarkPortalActive(portal: Portal);
}
extern "C" {
    #[link_name = "\u{1}_MarkPortalDone"]
    pub fn MarkPortalDone(portal: Portal);
}
extern "C" {
    #[link_name = "\u{1}_MarkPortalFailed"]
    pub fn MarkPortalFailed(portal: Portal);
}
extern "C" {
    #[link_name = "\u{1}_PortalDrop"]
    pub fn PortalDrop(portal: Portal, isTopCommit: bool);
}
extern "C" {
    #[link_name = "\u{1}_GetPortalByName"]
    pub fn GetPortalByName(name: *const ::std::os::raw::c_char) -> Portal;
}
extern "C" {
    #[link_name = "\u{1}_PortalDefineQuery"]
    pub fn PortalDefineQuery(
        portal: Portal,
        prepStmtName: *const ::std::os::raw::c_char,
        sourceText: *const ::std::os::raw::c_char,
        commandTag: *const ::std::os::raw::c_char,
        stmts: *mut List,
        cplan: *mut CachedPlan,
    );
}
extern "C" {
    #[link_name = "\u{1}_PortalGetPrimaryStmt"]
    pub fn PortalGetPrimaryStmt(portal: Portal) -> *mut PlannedStmt;
}
extern "C" {
    #[link_name = "\u{1}_PortalCreateHoldStore"]
    pub fn PortalCreateHoldStore(portal: Portal);
}
extern "C" {
    #[link_name = "\u{1}_PortalHashTableDeleteAll"]
    pub fn PortalHashTableDeleteAll();
}
extern "C" {
    #[link_name = "\u{1}_ThereAreNoReadyPortals"]
    pub fn ThereAreNoReadyPortals() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_HoldPinnedPortals"]
    pub fn HoldPinnedPortals();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPITupleTable {
    pub tuptabcxt: MemoryContext,
    pub alloced: uint64,
    pub free: uint64,
    pub tupdesc: TupleDesc,
    pub vals: *mut HeapTuple,
    pub next: slist_node,
    pub subid: SubTransactionId,
}
#[test]
fn bindgen_test_layout_SPITupleTable() {
    assert_eq!(
        ::std::mem::size_of::<SPITupleTable>(),
        56usize,
        concat!("Size of: ", stringify!(SPITupleTable))
    );
    assert_eq!(
        ::std::mem::align_of::<SPITupleTable>(),
        8usize,
        concat!("Alignment of ", stringify!(SPITupleTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SPITupleTable>())).tuptabcxt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SPITupleTable),
            "::",
            stringify!(tuptabcxt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SPITupleTable>())).alloced as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SPITupleTable),
            "::",
            stringify!(alloced)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SPITupleTable>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SPITupleTable),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SPITupleTable>())).tupdesc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SPITupleTable),
            "::",
            stringify!(tupdesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SPITupleTable>())).vals as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SPITupleTable),
            "::",
            stringify!(vals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SPITupleTable>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SPITupleTable),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SPITupleTable>())).subid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SPITupleTable),
            "::",
            stringify!(subid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SPI_plan {
    _unused: [u8; 0],
}
pub type SPIPlanPtr = *mut _SPI_plan;
extern "C" {
    #[link_name = "\u{1}_SPI_processed"]
    pub static mut SPI_processed: uint64;
}
extern "C" {
    #[link_name = "\u{1}_SPI_lastoid"]
    pub static mut SPI_lastoid: Oid;
}
extern "C" {
    #[link_name = "\u{1}_SPI_tuptable"]
    pub static mut SPI_tuptable: *mut SPITupleTable;
}
extern "C" {
    #[link_name = "\u{1}_SPI_result"]
    pub static mut SPI_result: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_connect"]
    pub fn SPI_connect() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_connect_ext"]
    pub fn SPI_connect_ext(options: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_finish"]
    pub fn SPI_finish() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_execute"]
    pub fn SPI_execute(
        src: *const ::std::os::raw::c_char,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_execute_plan"]
    pub fn SPI_execute_plan(
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_execute_plan_with_paramlist"]
    pub fn SPI_execute_plan_with_paramlist(
        plan: SPIPlanPtr,
        params: ParamListInfo,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_exec"]
    pub fn SPI_exec(
        src: *const ::std::os::raw::c_char,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_execp"]
    pub fn SPI_execp(
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_execute_snapshot"]
    pub fn SPI_execute_snapshot(
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        snapshot: Snapshot,
        crosscheck_snapshot: Snapshot,
        read_only: bool,
        fire_triggers: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_execute_with_args"]
    pub fn SPI_execute_with_args(
        src: *const ::std::os::raw::c_char,
        nargs: ::std::os::raw::c_int,
        argtypes: *mut Oid,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_prepare"]
    pub fn SPI_prepare(
        src: *const ::std::os::raw::c_char,
        nargs: ::std::os::raw::c_int,
        argtypes: *mut Oid,
    ) -> SPIPlanPtr;
}
extern "C" {
    #[link_name = "\u{1}_SPI_prepare_cursor"]
    pub fn SPI_prepare_cursor(
        src: *const ::std::os::raw::c_char,
        nargs: ::std::os::raw::c_int,
        argtypes: *mut Oid,
        cursorOptions: ::std::os::raw::c_int,
    ) -> SPIPlanPtr;
}
extern "C" {
    #[link_name = "\u{1}_SPI_prepare_params"]
    pub fn SPI_prepare_params(
        src: *const ::std::os::raw::c_char,
        parserSetup: ParserSetupHook,
        parserSetupArg: *mut ::std::os::raw::c_void,
        cursorOptions: ::std::os::raw::c_int,
    ) -> SPIPlanPtr;
}
extern "C" {
    #[link_name = "\u{1}_SPI_keepplan"]
    pub fn SPI_keepplan(plan: SPIPlanPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_saveplan"]
    pub fn SPI_saveplan(plan: SPIPlanPtr) -> SPIPlanPtr;
}
extern "C" {
    #[link_name = "\u{1}_SPI_freeplan"]
    pub fn SPI_freeplan(plan: SPIPlanPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_getargtypeid"]
    pub fn SPI_getargtypeid(plan: SPIPlanPtr, argIndex: ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_SPI_getargcount"]
    pub fn SPI_getargcount(plan: SPIPlanPtr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_is_cursor_plan"]
    pub fn SPI_is_cursor_plan(plan: SPIPlanPtr) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_SPI_plan_is_valid"]
    pub fn SPI_plan_is_valid(plan: SPIPlanPtr) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_SPI_result_code_string"]
    pub fn SPI_result_code_string(code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_SPI_plan_get_plan_sources"]
    pub fn SPI_plan_get_plan_sources(plan: SPIPlanPtr) -> *mut List;
}
extern "C" {
    #[link_name = "\u{1}_SPI_plan_get_cached_plan"]
    pub fn SPI_plan_get_cached_plan(plan: SPIPlanPtr) -> *mut CachedPlan;
}
extern "C" {
    #[link_name = "\u{1}_SPI_copytuple"]
    pub fn SPI_copytuple(tuple: HeapTuple) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_SPI_returntuple"]
    pub fn SPI_returntuple(tuple: HeapTuple, tupdesc: TupleDesc) -> HeapTupleHeader;
}
extern "C" {
    #[link_name = "\u{1}_SPI_modifytuple"]
    pub fn SPI_modifytuple(
        rel: Relation,
        tuple: HeapTuple,
        natts: ::std::os::raw::c_int,
        attnum: *mut ::std::os::raw::c_int,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
    ) -> HeapTuple;
}
extern "C" {
    #[link_name = "\u{1}_SPI_fnumber"]
    pub fn SPI_fnumber(
        tupdesc: TupleDesc,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_fname"]
    pub fn SPI_fname(
        tupdesc: TupleDesc,
        fnumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_SPI_getvalue"]
    pub fn SPI_getvalue(
        tuple: HeapTuple,
        tupdesc: TupleDesc,
        fnumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_SPI_getbinval"]
    pub fn SPI_getbinval(
        tuple: HeapTuple,
        tupdesc: TupleDesc,
        fnumber: ::std::os::raw::c_int,
        isnull: *mut bool,
    ) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_SPI_gettype"]
    pub fn SPI_gettype(
        tupdesc: TupleDesc,
        fnumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_SPI_gettypeid"]
    pub fn SPI_gettypeid(tupdesc: TupleDesc, fnumber: ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_SPI_getrelname"]
    pub fn SPI_getrelname(rel: Relation) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_SPI_getnspname"]
    pub fn SPI_getnspname(rel: Relation) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_SPI_palloc"]
    pub fn SPI_palloc(size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_SPI_repalloc"]
    pub fn SPI_repalloc(
        pointer: *mut ::std::os::raw::c_void,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_SPI_pfree"]
    pub fn SPI_pfree(pointer: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_SPI_datumTransfer"]
    pub fn SPI_datumTransfer(value: Datum, typByVal: bool, typLen: ::std::os::raw::c_int) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_SPI_freetuple"]
    pub fn SPI_freetuple(pointer: HeapTuple);
}
extern "C" {
    #[link_name = "\u{1}_SPI_freetuptable"]
    pub fn SPI_freetuptable(tuptable: *mut SPITupleTable);
}
extern "C" {
    #[link_name = "\u{1}_SPI_cursor_open"]
    pub fn SPI_cursor_open(
        name: *const ::std::os::raw::c_char,
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        read_only: bool,
    ) -> Portal;
}
extern "C" {
    #[link_name = "\u{1}_SPI_cursor_open_with_args"]
    pub fn SPI_cursor_open_with_args(
        name: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        nargs: ::std::os::raw::c_int,
        argtypes: *mut Oid,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        read_only: bool,
        cursorOptions: ::std::os::raw::c_int,
    ) -> Portal;
}
extern "C" {
    #[link_name = "\u{1}_SPI_cursor_open_with_paramlist"]
    pub fn SPI_cursor_open_with_paramlist(
        name: *const ::std::os::raw::c_char,
        plan: SPIPlanPtr,
        params: ParamListInfo,
        read_only: bool,
    ) -> Portal;
}
extern "C" {
    #[link_name = "\u{1}_SPI_cursor_find"]
    pub fn SPI_cursor_find(name: *const ::std::os::raw::c_char) -> Portal;
}
extern "C" {
    #[link_name = "\u{1}_SPI_cursor_fetch"]
    pub fn SPI_cursor_fetch(portal: Portal, forward: bool, count: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_SPI_cursor_move"]
    pub fn SPI_cursor_move(portal: Portal, forward: bool, count: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_SPI_scroll_cursor_fetch"]
    pub fn SPI_scroll_cursor_fetch(
        arg1: Portal,
        direction: FetchDirection,
        count: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[link_name = "\u{1}_SPI_scroll_cursor_move"]
    pub fn SPI_scroll_cursor_move(
        arg1: Portal,
        direction: FetchDirection,
        count: ::std::os::raw::c_long,
    );
}
extern "C" {
    #[link_name = "\u{1}_SPI_cursor_close"]
    pub fn SPI_cursor_close(portal: Portal);
}
extern "C" {
    #[link_name = "\u{1}_SPI_register_relation"]
    pub fn SPI_register_relation(enr: EphemeralNamedRelation) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_unregister_relation"]
    pub fn SPI_unregister_relation(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_register_trigger_data"]
    pub fn SPI_register_trigger_data(tdata: *mut TriggerData) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_SPI_start_transaction"]
    pub fn SPI_start_transaction();
}
extern "C" {
    #[link_name = "\u{1}_SPI_commit"]
    pub fn SPI_commit();
}
extern "C" {
    #[link_name = "\u{1}_SPI_rollback"]
    pub fn SPI_rollback();
}
extern "C" {
    #[link_name = "\u{1}_SPICleanup"]
    pub fn SPICleanup();
}
extern "C" {
    #[link_name = "\u{1}_AtEOXact_SPI"]
    pub fn AtEOXact_SPI(isCommit: bool);
}
extern "C" {
    #[link_name = "\u{1}_AtEOSubXact_SPI"]
    pub fn AtEOSubXact_SPI(isCommit: bool, mySubid: SubTransactionId);
}
extern "C" {
    #[link_name = "\u{1}_SPI_inside_nonatomic_context"]
    pub fn SPI_inside_nonatomic_context() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_byteaout"]
    pub fn byteaout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_charout"]
    pub fn charout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_namein"]
    pub fn namein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_nameout"]
    pub fn nameout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2in"]
    pub fn int2in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2out"]
    pub fn int2out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2vectorin"]
    pub fn int2vectorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2vectorout"]
    pub fn int2vectorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4in"]
    pub fn int4in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4out"]
    pub fn int4out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regprocin"]
    pub fn regprocin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regprocout"]
    pub fn regprocout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textin"]
    pub fn textin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textout"]
    pub fn textout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tidin"]
    pub fn tidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tidout"]
    pub fn tidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xidin"]
    pub fn xidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xidout"]
    pub fn xidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cidin"]
    pub fn cidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cidout"]
    pub fn cidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidvectorin"]
    pub fn oidvectorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidvectorout"]
    pub fn oidvectorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_boollt"]
    pub fn boollt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_boolgt"]
    pub fn boolgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_booleq"]
    pub fn booleq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_chareq"]
    pub fn chareq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_nameeq"]
    pub fn nameeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2eq"]
    pub fn int2eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2lt"]
    pub fn int2lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4eq"]
    pub fn int4eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4lt"]
    pub fn int4lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_texteq"]
    pub fn texteq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xideq"]
    pub fn xideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cideq"]
    pub fn cideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_charne"]
    pub fn charne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_charle"]
    pub fn charle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_chargt"]
    pub fn chargt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_charge"]
    pub fn charge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_chartoi4"]
    pub fn chartoi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_i4tochar"]
    pub fn i4tochar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_nameregexeq"]
    pub fn nameregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_boolne"]
    pub fn boolne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ddl_command_in"]
    pub fn pg_ddl_command_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ddl_command_out"]
    pub fn pg_ddl_command_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ddl_command_recv"]
    pub fn pg_ddl_command_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pgsql_version"]
    pub fn pgsql_version(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ddl_command_send"]
    pub fn pg_ddl_command_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_eqsel"]
    pub fn eqsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_neqsel"]
    pub fn neqsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_scalarltsel"]
    pub fn scalarltsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_scalargtsel"]
    pub fn scalargtsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_eqjoinsel"]
    pub fn eqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_neqjoinsel"]
    pub fn neqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_scalarltjoinsel"]
    pub fn scalarltjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_scalargtjoinsel"]
    pub fn scalargtjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_unknownin"]
    pub fn unknownin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_unknownout"]
    pub fn unknownout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_fac"]
    pub fn numeric_fac(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_above_eq"]
    pub fn box_above_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_below_eq"]
    pub fn box_below_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_in"]
    pub fn point_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_out"]
    pub fn point_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_in"]
    pub fn lseg_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_out"]
    pub fn lseg_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_in"]
    pub fn path_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_out"]
    pub fn path_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_in"]
    pub fn box_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_out"]
    pub fn box_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_overlap"]
    pub fn box_overlap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_ge"]
    pub fn box_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_gt"]
    pub fn box_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_eq"]
    pub fn box_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_lt"]
    pub fn box_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_le"]
    pub fn box_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_above"]
    pub fn point_above(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_left"]
    pub fn point_left(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_right"]
    pub fn point_right(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_below"]
    pub fn point_below(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_eq"]
    pub fn point_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_on_pb"]
    pub fn on_pb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_on_ppath"]
    pub fn on_ppath(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_center"]
    pub fn box_center(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_areasel"]
    pub fn areasel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_areajoinsel"]
    pub fn areajoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4mul"]
    pub fn int4mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4ne"]
    pub fn int4ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2ne"]
    pub fn int2ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2gt"]
    pub fn int2gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4gt"]
    pub fn int4gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2le"]
    pub fn int2le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4le"]
    pub fn int4le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4ge"]
    pub fn int4ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2ge"]
    pub fn int2ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2mul"]
    pub fn int2mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2div"]
    pub fn int2div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4div"]
    pub fn int4div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2mod"]
    pub fn int2mod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4mod"]
    pub fn int4mod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textne"]
    pub fn textne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int24eq"]
    pub fn int24eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int42eq"]
    pub fn int42eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int24lt"]
    pub fn int24lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int42lt"]
    pub fn int42lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int24gt"]
    pub fn int24gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int42gt"]
    pub fn int42gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int24ne"]
    pub fn int24ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int42ne"]
    pub fn int42ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int24le"]
    pub fn int24le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int42le"]
    pub fn int42le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int24ge"]
    pub fn int24ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int42ge"]
    pub fn int42ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int24mul"]
    pub fn int24mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int42mul"]
    pub fn int42mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int24div"]
    pub fn int24div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int42div"]
    pub fn int42div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2pl"]
    pub fn int2pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4pl"]
    pub fn int4pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int24pl"]
    pub fn int24pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int42pl"]
    pub fn int42pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2mi"]
    pub fn int2mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4mi"]
    pub fn int4mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int24mi"]
    pub fn int24mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int42mi"]
    pub fn int42mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oideq"]
    pub fn oideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidne"]
    pub fn oidne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_same"]
    pub fn box_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_contain"]
    pub fn box_contain(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_left"]
    pub fn box_left(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_overleft"]
    pub fn box_overleft(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_overright"]
    pub fn box_overright(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_right"]
    pub fn box_right(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_contained"]
    pub fn box_contained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_contain_pt"]
    pub fn box_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_node_tree_in"]
    pub fn pg_node_tree_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_node_tree_out"]
    pub fn pg_node_tree_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_node_tree_recv"]
    pub fn pg_node_tree_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_node_tree_send"]
    pub fn pg_node_tree_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4in"]
    pub fn float4in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4out"]
    pub fn float4out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4mul"]
    pub fn float4mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4div"]
    pub fn float4div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4pl"]
    pub fn float4pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4mi"]
    pub fn float4mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4um"]
    pub fn float4um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4abs"]
    pub fn float4abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4_accum"]
    pub fn float4_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4larger"]
    pub fn float4larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4smaller"]
    pub fn float4smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4um"]
    pub fn int4um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2um"]
    pub fn int2um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8in"]
    pub fn float8in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8out"]
    pub fn float8out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8mul"]
    pub fn float8mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8div"]
    pub fn float8div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8pl"]
    pub fn float8pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8mi"]
    pub fn float8mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8um"]
    pub fn float8um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8abs"]
    pub fn float8abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_accum"]
    pub fn float8_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8larger"]
    pub fn float8larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8smaller"]
    pub fn float8smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_center"]
    pub fn lseg_center(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_center"]
    pub fn path_center(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_center"]
    pub fn poly_center(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dround"]
    pub fn dround(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dtrunc"]
    pub fn dtrunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dsqrt"]
    pub fn dsqrt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dcbrt"]
    pub fn dcbrt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dpow"]
    pub fn dpow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dexp"]
    pub fn dexp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dlog1"]
    pub fn dlog1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_i2tod"]
    pub fn i2tod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_i2tof"]
    pub fn i2tof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dtoi2"]
    pub fn dtoi2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ftoi2"]
    pub fn ftoi2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_distance"]
    pub fn line_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstimein"]
    pub fn abstimein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstimeout"]
    pub fn abstimeout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_reltimein"]
    pub fn reltimein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_reltimeout"]
    pub fn reltimeout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timepl"]
    pub fn timepl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timemi"]
    pub fn timemi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalin"]
    pub fn tintervalin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalout"]
    pub fn tintervalout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_intinterval"]
    pub fn intinterval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalrel"]
    pub fn tintervalrel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timenow"]
    pub fn timenow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstimeeq"]
    pub fn abstimeeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstimene"]
    pub fn abstimene(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstimelt"]
    pub fn abstimelt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstimegt"]
    pub fn abstimegt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstimele"]
    pub fn abstimele(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstimege"]
    pub fn abstimege(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_reltimeeq"]
    pub fn reltimeeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_reltimene"]
    pub fn reltimene(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_reltimelt"]
    pub fn reltimelt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_reltimegt"]
    pub fn reltimegt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_reltimele"]
    pub fn reltimele(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_reltimege"]
    pub fn reltimege(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalsame"]
    pub fn tintervalsame(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalct"]
    pub fn tintervalct(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalov"]
    pub fn tintervalov(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalleneq"]
    pub fn tintervalleneq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervallenne"]
    pub fn tintervallenne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervallenlt"]
    pub fn tintervallenlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervallengt"]
    pub fn tintervallengt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervallenle"]
    pub fn tintervallenle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervallenge"]
    pub fn tintervallenge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalstart"]
    pub fn tintervalstart(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalend"]
    pub fn tintervalend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timeofday"]
    pub fn timeofday(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstime_finite"]
    pub fn abstime_finite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_combine"]
    pub fn float8_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inter_sl"]
    pub fn inter_sl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inter_lb"]
    pub fn inter_lb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float48mul"]
    pub fn float48mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float48div"]
    pub fn float48div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float48pl"]
    pub fn float48pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float48mi"]
    pub fn float48mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float84mul"]
    pub fn float84mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float84div"]
    pub fn float84div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float84pl"]
    pub fn float84pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float84mi"]
    pub fn float84mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4eq"]
    pub fn float4eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4ne"]
    pub fn float4ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4lt"]
    pub fn float4lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4le"]
    pub fn float4le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4gt"]
    pub fn float4gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4ge"]
    pub fn float4ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8eq"]
    pub fn float8eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8ne"]
    pub fn float8ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8lt"]
    pub fn float8lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8le"]
    pub fn float8le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8gt"]
    pub fn float8gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8ge"]
    pub fn float8ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float48eq"]
    pub fn float48eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float48ne"]
    pub fn float48ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float48lt"]
    pub fn float48lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float48le"]
    pub fn float48le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float48gt"]
    pub fn float48gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float48ge"]
    pub fn float48ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float84eq"]
    pub fn float84eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float84ne"]
    pub fn float84ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float84lt"]
    pub fn float84lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float84le"]
    pub fn float84le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float84gt"]
    pub fn float84gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float84ge"]
    pub fn float84ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ftod"]
    pub fn ftod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dtof"]
    pub fn dtof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_i2toi4"]
    pub fn i2toi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_i4toi2"]
    pub fn i4toi2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_jit_available"]
    pub fn pg_jit_available(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_i4tod"]
    pub fn i4tod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dtoi4"]
    pub fn dtoi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_i4tof"]
    pub fn i4tof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ftoi4"]
    pub fn ftoi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_width_bucket_float8"]
    pub fn width_bucket_float8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_in"]
    pub fn json_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_out"]
    pub fn json_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_recv"]
    pub fn json_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_send"]
    pub fn json_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_index_am_handler_in"]
    pub fn index_am_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_index_am_handler_out"]
    pub fn index_am_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashmacaddr8"]
    pub fn hashmacaddr8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hash_aclitem"]
    pub fn hash_aclitem(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bthandler"]
    pub fn bthandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashhandler"]
    pub fn hashhandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gisthandler"]
    pub fn gisthandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ginhandler"]
    pub fn ginhandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spghandler"]
    pub fn spghandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brinhandler"]
    pub fn brinhandler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_scalarlesel"]
    pub fn scalarlesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_scalargesel"]
    pub fn scalargesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_amvalidate"]
    pub fn amvalidate(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_same"]
    pub fn poly_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_contain"]
    pub fn poly_contain(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_left"]
    pub fn poly_left(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_overleft"]
    pub fn poly_overleft(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_overright"]
    pub fn poly_overright(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_right"]
    pub fn poly_right(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_contained"]
    pub fn poly_contained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_overlap"]
    pub fn poly_overlap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_in"]
    pub fn poly_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_out"]
    pub fn poly_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint2cmp"]
    pub fn btint2cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint4cmp"]
    pub fn btint4cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btfloat4cmp"]
    pub fn btfloat4cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btfloat8cmp"]
    pub fn btfloat8cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btoidcmp"]
    pub fn btoidcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btabstimecmp"]
    pub fn btabstimecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btcharcmp"]
    pub fn btcharcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btnamecmp"]
    pub fn btnamecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bttextcmp"]
    pub fn bttextcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_distance"]
    pub fn lseg_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_interpt"]
    pub fn lseg_interpt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_ps"]
    pub fn dist_ps(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_pb"]
    pub fn dist_pb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_sb"]
    pub fn dist_sb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_close_ps"]
    pub fn close_ps(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_close_pb"]
    pub fn close_pb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_close_sb"]
    pub fn close_sb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_on_ps"]
    pub fn on_ps(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_distance"]
    pub fn path_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_ppath"]
    pub fn dist_ppath(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_on_sb"]
    pub fn on_sb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inter_sb"]
    pub fn inter_sb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_to_array_null"]
    pub fn text_to_array_null(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_cmp"]
    pub fn cash_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_append"]
    pub fn array_append(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_prepend"]
    pub fn array_prepend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btreltimecmp"]
    pub fn btreltimecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bttintervalcmp"]
    pub fn bttintervalcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btarraycmp"]
    pub fn btarraycmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_cat"]
    pub fn array_cat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_to_text_null"]
    pub fn array_to_text_null(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_scalarlejoinsel"]
    pub fn scalarlejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_ne"]
    pub fn array_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_lt"]
    pub fn array_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_gt"]
    pub fn array_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_le"]
    pub fn array_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_to_array"]
    pub fn text_to_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_to_text"]
    pub fn array_to_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_ge"]
    pub fn array_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_scalargejoinsel"]
    pub fn scalargejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashmacaddr"]
    pub fn hashmacaddr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashtext"]
    pub fn hashtext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_rtrim1"]
    pub fn rtrim1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btoidvectorcmp"]
    pub fn btoidvectorcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_name_text"]
    pub fn name_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_name"]
    pub fn text_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_name_bpchar"]
    pub fn name_bpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchar_name"]
    pub fn bpchar_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashinet"]
    pub fn hashinet(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashint4extended"]
    pub fn hashint4extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hash_numeric"]
    pub fn hash_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_in"]
    pub fn macaddr_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_out"]
    pub fn macaddr_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_num_nulls"]
    pub fn pg_num_nulls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_num_nonnulls"]
    pub fn pg_num_nonnulls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashint2extended"]
    pub fn hashint2extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashint8extended"]
    pub fn hashint8extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashfloat4extended"]
    pub fn hashfloat4extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashfloat8extended"]
    pub fn hashfloat8extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashoidextended"]
    pub fn hashoidextended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashcharextended"]
    pub fn hashcharextended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashnameextended"]
    pub fn hashnameextended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashtextextended"]
    pub fn hashtextextended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashint2"]
    pub fn hashint2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashint4"]
    pub fn hashint4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashfloat4"]
    pub fn hashfloat4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashfloat8"]
    pub fn hashfloat8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashoid"]
    pub fn hashoid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashchar"]
    pub fn hashchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashname"]
    pub fn hashname(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashvarlena"]
    pub fn hashvarlena(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashoidvector"]
    pub fn hashoidvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_larger"]
    pub fn text_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_smaller"]
    pub fn text_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8in"]
    pub fn int8in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8out"]
    pub fn int8out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8um"]
    pub fn int8um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8pl"]
    pub fn int8pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8mi"]
    pub fn int8mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8mul"]
    pub fn int8mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8div"]
    pub fn int8div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8eq"]
    pub fn int8eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8ne"]
    pub fn int8ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8lt"]
    pub fn int8lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8gt"]
    pub fn int8gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8le"]
    pub fn int8le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8ge"]
    pub fn int8ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int84eq"]
    pub fn int84eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int84ne"]
    pub fn int84ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int84lt"]
    pub fn int84lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int84gt"]
    pub fn int84gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int84le"]
    pub fn int84le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int84ge"]
    pub fn int84ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int84"]
    pub fn int84(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int48"]
    pub fn int48(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_i8tod"]
    pub fn i8tod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dtoi8"]
    pub fn dtoi8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_larger"]
    pub fn array_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_smaller"]
    pub fn array_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_abbrev"]
    pub fn inet_abbrev(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cidr_abbrev"]
    pub fn cidr_abbrev(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_set_masklen"]
    pub fn inet_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidvectorne"]
    pub fn oidvectorne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hash_array"]
    pub fn hash_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cidr_set_masklen"]
    pub fn cidr_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_indexam_has_property"]
    pub fn pg_indexam_has_property(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_index_has_property"]
    pub fn pg_index_has_property(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_index_column_has_property"]
    pub fn pg_index_column_has_property(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_i8tof"]
    pub fn i8tof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ftoi8"]
    pub fn ftoi8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_namelt"]
    pub fn namelt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_namele"]
    pub fn namele(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_namegt"]
    pub fn namegt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_namege"]
    pub fn namege(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_namene"]
    pub fn namene(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchar"]
    pub fn bpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varchar"]
    pub fn varchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_mktinterval"]
    pub fn mktinterval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidvectorlt"]
    pub fn oidvectorlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidvectorle"]
    pub fn oidvectorle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidvectoreq"]
    pub fn oidvectoreq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidvectorge"]
    pub fn oidvectorge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidvectorgt"]
    pub fn oidvectorgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_network"]
    pub fn network_network(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_netmask"]
    pub fn network_netmask(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_masklen"]
    pub fn network_masklen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_broadcast"]
    pub fn network_broadcast(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_host"]
    pub fn network_host(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_current_user"]
    pub fn current_user(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_family"]
    pub fn network_family(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int82"]
    pub fn int82(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_create"]
    pub fn be_lo_create(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidlt"]
    pub fn oidlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidle"]
    pub fn oidle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteaoctetlen"]
    pub fn byteaoctetlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteaGetByte"]
    pub fn byteaGetByte(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteaSetByte"]
    pub fn byteaSetByte(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteaGetBit"]
    pub fn byteaGetBit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteaSetBit"]
    pub fn byteaSetBit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_pl"]
    pub fn dist_pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_lb"]
    pub fn dist_lb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_sl"]
    pub fn dist_sl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_cpoly"]
    pub fn dist_cpoly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_distance"]
    pub fn poly_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_show"]
    pub fn network_show(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_lt"]
    pub fn text_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_le"]
    pub fn text_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_gt"]
    pub fn text_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_ge"]
    pub fn text_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_eq"]
    pub fn array_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_session_user"]
    pub fn session_user(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_dims"]
    pub fn array_dims(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_ndims"]
    pub fn array_ndims(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteaoverlay"]
    pub fn byteaoverlay(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_in"]
    pub fn array_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_out"]
    pub fn array_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteaoverlay_no_len"]
    pub fn byteaoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_trunc"]
    pub fn macaddr_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int28"]
    pub fn int28(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_smgrin"]
    pub fn smgrin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_smgrout"]
    pub fn smgrout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_smgreq"]
    pub fn smgreq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_smgrne"]
    pub fn smgrne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_import"]
    pub fn be_lo_import(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_export"]
    pub fn be_lo_export(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4inc"]
    pub fn int4inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_import_with_oid"]
    pub fn be_lo_import_with_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4larger"]
    pub fn int4larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4smaller"]
    pub fn int4smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2larger"]
    pub fn int2larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2smaller"]
    pub fn int2smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashvarlenaextended"]
    pub fn hashvarlenaextended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashoidvectorextended"]
    pub fn hashoidvectorextended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hash_aclitem_extended"]
    pub fn hash_aclitem_extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashmacaddrextended"]
    pub fn hashmacaddrextended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashinetextended"]
    pub fn hashinetextended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hash_numeric_extended"]
    pub fn hash_numeric_extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashmacaddr8extended"]
    pub fn hashmacaddr8extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hash_array_extended"]
    pub fn hash_array_extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervaleq"]
    pub fn tintervaleq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalne"]
    pub fn tintervalne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervallt"]
    pub fn tintervallt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalgt"]
    pub fn tintervalgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalle"]
    pub fn tintervalle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalge"]
    pub fn tintervalge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_client_encoding"]
    pub fn pg_client_encoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_current_query"]
    pub fn current_query(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_eq"]
    pub fn macaddr_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_lt"]
    pub fn macaddr_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_le"]
    pub fn macaddr_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_gt"]
    pub fn macaddr_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_ge"]
    pub fn macaddr_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_ne"]
    pub fn macaddr_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_cmp"]
    pub fn macaddr_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int82pl"]
    pub fn int82pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int82mi"]
    pub fn int82mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int82mul"]
    pub fn int82mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int82div"]
    pub fn int82div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int28pl"]
    pub fn int28pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint8cmp"]
    pub fn btint8cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_mul_flt4"]
    pub fn cash_mul_flt4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_div_flt4"]
    pub fn cash_div_flt4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_flt4_mul_cash"]
    pub fn flt4_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textpos"]
    pub fn textpos(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textlike"]
    pub fn textlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textnlike"]
    pub fn textnlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int48eq"]
    pub fn int48eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int48ne"]
    pub fn int48ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int48lt"]
    pub fn int48lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int48gt"]
    pub fn int48gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int48le"]
    pub fn int48le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int48ge"]
    pub fn int48ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_namelike"]
    pub fn namelike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_namenlike"]
    pub fn namenlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_char_bpchar"]
    pub fn char_bpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_current_database"]
    pub fn current_database(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4_mul_cash"]
    pub fn int4_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2_mul_cash"]
    pub fn int2_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_mul_int4"]
    pub fn cash_mul_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_div_int4"]
    pub fn cash_div_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_mul_int2"]
    pub fn cash_mul_int2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_div_int2"]
    pub fn cash_div_int2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lower"]
    pub fn lower(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_upper"]
    pub fn upper(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_initcap"]
    pub fn initcap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lpad"]
    pub fn lpad(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_rpad"]
    pub fn rpad(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ltrim"]
    pub fn ltrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_rtrim"]
    pub fn rtrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_substr"]
    pub fn text_substr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_translate"]
    pub fn translate(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ltrim1"]
    pub fn ltrim1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_substr_no_len"]
    pub fn text_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btrim"]
    pub fn btrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btrim1"]
    pub fn btrim1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_in"]
    pub fn cash_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_out"]
    pub fn cash_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_eq"]
    pub fn cash_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_ne"]
    pub fn cash_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_lt"]
    pub fn cash_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_le"]
    pub fn cash_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_gt"]
    pub fn cash_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_ge"]
    pub fn cash_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_pl"]
    pub fn cash_pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_mi"]
    pub fn cash_mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_mul_flt8"]
    pub fn cash_mul_flt8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_div_flt8"]
    pub fn cash_div_flt8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cashlarger"]
    pub fn cashlarger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cashsmaller"]
    pub fn cashsmaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_in"]
    pub fn inet_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_out"]
    pub fn inet_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_flt8_mul_cash"]
    pub fn flt8_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_eq"]
    pub fn network_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_lt"]
    pub fn network_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_le"]
    pub fn network_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_gt"]
    pub fn network_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_ge"]
    pub fn network_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_ne"]
    pub fn network_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_cmp"]
    pub fn network_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_sub"]
    pub fn network_sub(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_subeq"]
    pub fn network_subeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_sup"]
    pub fn network_sup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_supeq"]
    pub fn network_supeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_words"]
    pub fn cash_words(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_generate_series_timestamp"]
    pub fn generate_series_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_generate_series_timestamptz"]
    pub fn generate_series_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int28mi"]
    pub fn int28mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int28mul"]
    pub fn int28mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_char"]
    pub fn text_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8mod"]
    pub fn int8mod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_char_text"]
    pub fn char_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int28div"]
    pub fn int28div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashint8"]
    pub fn hashint8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_open"]
    pub fn be_lo_open(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_close"]
    pub fn be_lo_close(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_loread"]
    pub fn be_loread(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lowrite"]
    pub fn be_lowrite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_lseek"]
    pub fn be_lo_lseek(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_creat"]
    pub fn be_lo_creat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_tell"]
    pub fn be_lo_tell(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_on_pl"]
    pub fn on_pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_on_sl"]
    pub fn on_sl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_close_pl"]
    pub fn close_pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_close_sl"]
    pub fn close_sl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_close_lb"]
    pub fn close_lb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_unlink"]
    pub fn be_lo_unlink(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashbpcharextended"]
    pub fn hashbpcharextended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_inter"]
    pub fn path_inter(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_area"]
    pub fn box_area(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_width"]
    pub fn box_width(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_height"]
    pub fn box_height(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_distance"]
    pub fn box_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_area"]
    pub fn path_area(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_intersect"]
    pub fn box_intersect(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_diagonal"]
    pub fn box_diagonal(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_n_lt"]
    pub fn path_n_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_n_gt"]
    pub fn path_n_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_n_eq"]
    pub fn path_n_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_n_le"]
    pub fn path_n_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_n_ge"]
    pub fn path_n_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_length"]
    pub fn path_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_ne"]
    pub fn point_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_vert"]
    pub fn point_vert(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_horiz"]
    pub fn point_horiz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_distance"]
    pub fn point_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_slope"]
    pub fn point_slope(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_construct"]
    pub fn lseg_construct(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_intersect"]
    pub fn lseg_intersect(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_parallel"]
    pub fn lseg_parallel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_perp"]
    pub fn lseg_perp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_vertical"]
    pub fn lseg_vertical(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_horizontal"]
    pub fn lseg_horizontal(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_eq"]
    pub fn lseg_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_truncate"]
    pub fn be_lo_truncate(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_izone"]
    pub fn timestamptz_izone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_point_compress"]
    pub fn gist_point_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_aclitemin"]
    pub fn aclitemin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_aclitemout"]
    pub fn aclitemout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_aclinsert"]
    pub fn aclinsert(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_aclremove"]
    pub fn aclremove(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_aclcontains"]
    pub fn aclcontains(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_getdatabaseencoding"]
    pub fn getdatabaseencoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpcharin"]
    pub fn bpcharin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpcharout"]
    pub fn bpcharout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varcharin"]
    pub fn varcharin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varcharout"]
    pub fn varcharout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchareq"]
    pub fn bpchareq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpcharlt"]
    pub fn bpcharlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpcharle"]
    pub fn bpcharle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchargt"]
    pub fn bpchargt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpcharge"]
    pub fn bpcharge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpcharne"]
    pub fn bpcharne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_aclitem_eq"]
    pub fn aclitem_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchar_larger"]
    pub fn bpchar_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchar_smaller"]
    pub fn bpchar_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_prepared_xact"]
    pub fn pg_prepared_xact(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_generate_series_step_int4"]
    pub fn generate_series_step_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_generate_series_int4"]
    pub fn generate_series_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_generate_series_step_int8"]
    pub fn generate_series_step_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_generate_series_int8"]
    pub fn generate_series_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpcharcmp"]
    pub fn bpcharcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_regclass"]
    pub fn text_regclass(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashbpchar"]
    pub fn hashbpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_format_type"]
    pub fn format_type(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_in"]
    pub fn date_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_out"]
    pub fn date_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_eq"]
    pub fn date_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_lt"]
    pub fn date_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_le"]
    pub fn date_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_gt"]
    pub fn date_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_ge"]
    pub fn date_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_ne"]
    pub fn date_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_cmp"]
    pub fn date_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_lt"]
    pub fn time_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_le"]
    pub fn time_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_gt"]
    pub fn time_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_ge"]
    pub fn time_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_ne"]
    pub fn time_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_cmp"]
    pub fn time_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_larger"]
    pub fn date_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_smaller"]
    pub fn date_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_mi"]
    pub fn date_mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_pli"]
    pub fn date_pli(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_mii"]
    pub fn date_mii(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_in"]
    pub fn time_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_out"]
    pub fn time_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_eq"]
    pub fn time_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_add_pt"]
    pub fn circle_add_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_sub_pt"]
    pub fn circle_sub_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_mul_pt"]
    pub fn circle_mul_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_div_pt"]
    pub fn circle_div_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_in"]
    pub fn timestamptz_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_out"]
    pub fn timestamptz_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_eq"]
    pub fn timestamp_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_ne"]
    pub fn timestamp_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_lt"]
    pub fn timestamp_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_le"]
    pub fn timestamp_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_ge"]
    pub fn timestamp_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_gt"]
    pub fn timestamp_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_timestamptz"]
    pub fn float8_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_zone"]
    pub fn timestamptz_zone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_in"]
    pub fn interval_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_out"]
    pub fn interval_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_eq"]
    pub fn interval_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_ne"]
    pub fn interval_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_lt"]
    pub fn interval_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_le"]
    pub fn interval_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_ge"]
    pub fn interval_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_gt"]
    pub fn interval_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_um"]
    pub fn interval_um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_pl"]
    pub fn interval_pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_mi"]
    pub fn interval_mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_part"]
    pub fn timestamptz_part(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_part"]
    pub fn interval_part(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstime_timestamptz"]
    pub fn abstime_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_timestamptz"]
    pub fn date_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_justify_hours"]
    pub fn interval_justify_hours(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_reltime_interval"]
    pub fn reltime_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_date"]
    pub fn timestamptz_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstime_date"]
    pub fn abstime_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_abstime"]
    pub fn timestamptz_abstime(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xid_age"]
    pub fn xid_age(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_mi"]
    pub fn timestamp_mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_pl_interval"]
    pub fn timestamptz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_mi_interval"]
    pub fn timestamptz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_generate_subscripts"]
    pub fn generate_subscripts(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_generate_subscripts_nodir"]
    pub fn generate_subscripts_nodir(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_fill"]
    pub fn array_fill(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_reltime"]
    pub fn interval_reltime(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_smaller"]
    pub fn timestamp_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_larger"]
    pub fn timestamp_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_smaller"]
    pub fn interval_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_larger"]
    pub fn interval_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_age"]
    pub fn timestamptz_age(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_scale"]
    pub fn interval_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_trunc"]
    pub fn timestamptz_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_trunc"]
    pub fn interval_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8inc"]
    pub fn int8inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8abs"]
    pub fn int8abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8larger"]
    pub fn int8larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8smaller"]
    pub fn int8smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_texticregexeq"]
    pub fn texticregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_texticregexne"]
    pub fn texticregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_nameicregexeq"]
    pub fn nameicregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_nameicregexne"]
    pub fn nameicregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_boolin"]
    pub fn boolin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_boolout"]
    pub fn boolout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteain"]
    pub fn byteain(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_charin"]
    pub fn charin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_charlt"]
    pub fn charlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_unique_key_recheck"]
    pub fn unique_key_recheck(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4abs"]
    pub fn int4abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_nameregexne"]
    pub fn nameregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2abs"]
    pub fn int2abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textregexeq"]
    pub fn textregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textregexne"]
    pub fn textregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textlen"]
    pub fn textlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textcat"]
    pub fn textcat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_PG_char_to_encoding"]
    pub fn PG_char_to_encoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tidne"]
    pub fn tidne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cidr_in"]
    pub fn cidr_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_parse_ident"]
    pub fn parse_ident(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_column_size"]
    pub fn pg_column_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_overlaps_timetz"]
    pub fn overlaps_timetz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_datetime_timestamp"]
    pub fn datetime_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_part"]
    pub fn timetz_part(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int84pl"]
    pub fn int84pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int84mi"]
    pub fn int84mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int84mul"]
    pub fn int84mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int84div"]
    pub fn int84div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int48pl"]
    pub fn int48pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int48mi"]
    pub fn int48mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int48mul"]
    pub fn int48mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int48div"]
    pub fn int48div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_quote_ident"]
    pub fn quote_ident(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_quote_literal"]
    pub fn quote_literal(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_fill_with_lower_bounds"]
    pub fn array_fill_with_lower_bounds(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_i8tooid"]
    pub fn i8tooid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidtoi8"]
    pub fn oidtoi8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_quote_nullable"]
    pub fn quote_nullable(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_suppress_redundant_updates_trigger"]
    pub fn suppress_redundant_updates_trigger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tideq"]
    pub fn tideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_currtid_byreloid"]
    pub fn currtid_byreloid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_currtid_byrelname"]
    pub fn currtid_byrelname(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_justify_days"]
    pub fn interval_justify_days(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_datetimetz_timestamptz"]
    pub fn datetimetz_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_now"]
    pub fn now(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_positionsel"]
    pub fn positionsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_positionjoinsel"]
    pub fn positionjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_contsel"]
    pub fn contsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_contjoinsel"]
    pub fn contjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_overlaps_timestamp"]
    pub fn overlaps_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_overlaps_time"]
    pub fn overlaps_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_in"]
    pub fn timestamp_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_out"]
    pub fn timestamp_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_cmp"]
    pub fn timestamp_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_cmp"]
    pub fn interval_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_time"]
    pub fn timestamp_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpcharlen"]
    pub fn bpcharlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_div"]
    pub fn interval_div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dlog10"]
    pub fn dlog10(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidvectortypes"]
    pub fn oidvectortypes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_in"]
    pub fn timetz_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_out"]
    pub fn timetz_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_eq"]
    pub fn timetz_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_ne"]
    pub fn timetz_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_lt"]
    pub fn timetz_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_le"]
    pub fn timetz_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_ge"]
    pub fn timetz_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_gt"]
    pub fn timetz_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_cmp"]
    pub fn timetz_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_hostmask"]
    pub fn network_hostmask(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_makeaclitem"]
    pub fn makeaclitem(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_interval"]
    pub fn time_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lock_status"]
    pub fn pg_lock_status(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_finite"]
    pub fn date_finite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textoctetlen"]
    pub fn textoctetlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpcharoctetlen"]
    pub fn bpcharoctetlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_larger"]
    pub fn time_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_smaller"]
    pub fn time_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_larger"]
    pub fn timetz_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_smaller"]
    pub fn timetz_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_part"]
    pub fn time_part(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_constraintdef"]
    pub fn pg_get_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_timetz"]
    pub fn timestamptz_timetz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_finite"]
    pub fn timestamp_finite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_finite"]
    pub fn interval_finite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_start"]
    pub fn pg_stat_get_backend_start(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_client_addr"]
    pub fn pg_stat_get_backend_client_addr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_client_port"]
    pub fn pg_stat_get_backend_client_port(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_current_schema"]
    pub fn current_schema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_current_schemas"]
    pub fn current_schemas(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textoverlay"]
    pub fn textoverlay(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textoverlay_no_len"]
    pub fn textoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_parallel"]
    pub fn line_parallel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_perp"]
    pub fn line_perp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_vertical"]
    pub fn line_vertical(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_horizontal"]
    pub fn line_horizontal(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_center"]
    pub fn circle_center(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_time"]
    pub fn interval_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_points_box"]
    pub fn points_box(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_add"]
    pub fn box_add(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_sub"]
    pub fn box_sub(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_mul"]
    pub fn box_mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_div"]
    pub fn box_div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cidr_out"]
    pub fn cidr_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_contain_pt"]
    pub fn poly_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pt_contained_poly"]
    pub fn pt_contained_poly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_isclosed"]
    pub fn path_isclosed(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_isopen"]
    pub fn path_isopen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_npoints"]
    pub fn path_npoints(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_close"]
    pub fn path_close(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_open"]
    pub fn path_open(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_add"]
    pub fn path_add(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_add_pt"]
    pub fn path_add_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_sub_pt"]
    pub fn path_sub_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_mul_pt"]
    pub fn path_mul_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_div_pt"]
    pub fn path_div_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_construct_point"]
    pub fn construct_point(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_add"]
    pub fn point_add(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_sub"]
    pub fn point_sub(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_mul"]
    pub fn point_mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_div"]
    pub fn point_div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_npoints"]
    pub fn poly_npoints(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_box"]
    pub fn poly_box(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_path"]
    pub fn poly_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_poly"]
    pub fn box_poly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_poly"]
    pub fn path_poly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_in"]
    pub fn circle_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_out"]
    pub fn circle_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_same"]
    pub fn circle_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_contain"]
    pub fn circle_contain(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_left"]
    pub fn circle_left(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_overleft"]
    pub fn circle_overleft(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_overright"]
    pub fn circle_overright(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_right"]
    pub fn circle_right(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_contained"]
    pub fn circle_contained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_overlap"]
    pub fn circle_overlap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_below"]
    pub fn circle_below(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_above"]
    pub fn circle_above(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_eq"]
    pub fn circle_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_ne"]
    pub fn circle_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_lt"]
    pub fn circle_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_gt"]
    pub fn circle_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_le"]
    pub fn circle_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_ge"]
    pub fn circle_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_area"]
    pub fn circle_area(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_diameter"]
    pub fn circle_diameter(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_radius"]
    pub fn circle_radius(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_distance"]
    pub fn circle_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cr_circle"]
    pub fn cr_circle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_circle"]
    pub fn poly_circle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_poly"]
    pub fn circle_poly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_pc"]
    pub fn dist_pc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_contain_pt"]
    pub fn circle_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pt_contained_circle"]
    pub fn pt_contained_circle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_circle"]
    pub fn box_circle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_box"]
    pub fn circle_box(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_ne"]
    pub fn lseg_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_lt"]
    pub fn lseg_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_le"]
    pub fn lseg_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_gt"]
    pub fn lseg_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_ge"]
    pub fn lseg_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_length"]
    pub fn lseg_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_close_ls"]
    pub fn close_ls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_close_lseg"]
    pub fn close_lseg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_in"]
    pub fn line_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_out"]
    pub fn line_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_eq"]
    pub fn line_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_construct_pp"]
    pub fn line_construct_pp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_interpt"]
    pub fn line_interpt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_intersect"]
    pub fn line_intersect(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bit_in"]
    pub fn bit_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bit_out"]
    pub fn bit_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_ruledef"]
    pub fn pg_get_ruledef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_nextval_oid"]
    pub fn nextval_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_currval_oid"]
    pub fn currval_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_setval_oid"]
    pub fn setval_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varbit_in"]
    pub fn varbit_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varbit_out"]
    pub fn varbit_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_biteq"]
    pub fn biteq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitne"]
    pub fn bitne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitge"]
    pub fn bitge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitgt"]
    pub fn bitgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitle"]
    pub fn bitle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitlt"]
    pub fn bitlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitcmp"]
    pub fn bitcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_PG_encoding_to_char"]
    pub fn PG_encoding_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_drandom"]
    pub fn drandom(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_setseed"]
    pub fn setseed(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dasin"]
    pub fn dasin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dacos"]
    pub fn dacos(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_datan"]
    pub fn datan(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_datan2"]
    pub fn datan2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dsin"]
    pub fn dsin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dcos"]
    pub fn dcos(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dtan"]
    pub fn dtan(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dcot"]
    pub fn dcot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_degrees"]
    pub fn degrees(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_radians"]
    pub fn radians(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dpi"]
    pub fn dpi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_mul"]
    pub fn interval_mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_typeof"]
    pub fn pg_typeof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ascii"]
    pub fn ascii(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_chr"]
    pub fn chr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_repeat"]
    pub fn repeat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_similar_escape"]
    pub fn similar_escape(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_mul_d_interval"]
    pub fn mul_d_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_texticlike"]
    pub fn texticlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_texticnlike"]
    pub fn texticnlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_nameiclike"]
    pub fn nameiclike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_nameicnlike"]
    pub fn nameicnlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_like_escape"]
    pub fn like_escape(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidgt"]
    pub fn oidgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidge"]
    pub fn oidge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_viewdef_name"]
    pub fn pg_get_viewdef_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_viewdef"]
    pub fn pg_get_viewdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_userbyid"]
    pub fn pg_get_userbyid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_indexdef"]
    pub fn pg_get_indexdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_check_ins"]
    pub fn RI_FKey_check_ins(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_check_upd"]
    pub fn RI_FKey_check_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_cascade_del"]
    pub fn RI_FKey_cascade_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_cascade_upd"]
    pub fn RI_FKey_cascade_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_restrict_del"]
    pub fn RI_FKey_restrict_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_restrict_upd"]
    pub fn RI_FKey_restrict_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_setnull_del"]
    pub fn RI_FKey_setnull_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_setnull_upd"]
    pub fn RI_FKey_setnull_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_setdefault_del"]
    pub fn RI_FKey_setdefault_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_setdefault_upd"]
    pub fn RI_FKey_setdefault_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_noaction_del"]
    pub fn RI_FKey_noaction_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_RI_FKey_noaction_upd"]
    pub fn RI_FKey_noaction_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_triggerdef"]
    pub fn pg_get_triggerdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_serial_sequence"]
    pub fn pg_get_serial_sequence(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bit_and"]
    pub fn bit_and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bit_or"]
    pub fn bit_or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitxor"]
    pub fn bitxor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitnot"]
    pub fn bitnot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitshiftleft"]
    pub fn bitshiftleft(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitshiftright"]
    pub fn bitshiftright(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitcat"]
    pub fn bitcat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitsubstr"]
    pub fn bitsubstr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitlength"]
    pub fn bitlength(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitoctetlength"]
    pub fn bitoctetlength(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitfromint4"]
    pub fn bitfromint4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bittoint4"]
    pub fn bittoint4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bit"]
    pub fn bit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_keywords"]
    pub fn pg_get_keywords(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varbit"]
    pub fn varbit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_hash"]
    pub fn time_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_aclexplode"]
    pub fn aclexplode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_mi_time"]
    pub fn time_mi_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_boolle"]
    pub fn boolle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_boolge"]
    pub fn boolge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btboolcmp"]
    pub fn btboolcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_hash"]
    pub fn timetz_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_hash"]
    pub fn interval_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitposition"]
    pub fn bitposition(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitsubstr_no_len"]
    pub fn bitsubstr_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_in"]
    pub fn numeric_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_out"]
    pub fn numeric_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric"]
    pub fn numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_abs"]
    pub fn numeric_abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_sign"]
    pub fn numeric_sign(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_round"]
    pub fn numeric_round(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_trunc"]
    pub fn numeric_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_ceil"]
    pub fn numeric_ceil(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_floor"]
    pub fn numeric_floor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_length_in_encoding"]
    pub fn length_in_encoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_convert_from"]
    pub fn pg_convert_from(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_to_cidr"]
    pub fn inet_to_cidr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_expr"]
    pub fn pg_get_expr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_convert_to"]
    pub fn pg_convert_to(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_eq"]
    pub fn numeric_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_ne"]
    pub fn numeric_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_gt"]
    pub fn numeric_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_ge"]
    pub fn numeric_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_lt"]
    pub fn numeric_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_le"]
    pub fn numeric_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_add"]
    pub fn numeric_add(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_sub"]
    pub fn numeric_sub(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_mul"]
    pub fn numeric_mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_div"]
    pub fn numeric_div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_mod"]
    pub fn numeric_mod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_sqrt"]
    pub fn numeric_sqrt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_exp"]
    pub fn numeric_exp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_ln"]
    pub fn numeric_ln(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_log"]
    pub fn numeric_log(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_power"]
    pub fn numeric_power(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4_numeric"]
    pub fn int4_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4_numeric"]
    pub fn float4_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_numeric"]
    pub fn float8_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_int4"]
    pub fn numeric_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_float4"]
    pub fn numeric_float4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_float8"]
    pub fn numeric_float8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_pl_interval"]
    pub fn time_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_mi_interval"]
    pub fn time_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_pl_interval"]
    pub fn timetz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_mi_interval"]
    pub fn timetz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_inc"]
    pub fn numeric_inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_setval3_oid"]
    pub fn setval3_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_smaller"]
    pub fn numeric_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_larger"]
    pub fn numeric_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_to_char"]
    pub fn interval_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_cmp"]
    pub fn numeric_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_to_char"]
    pub fn timestamptz_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_uminus"]
    pub fn numeric_uminus(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_to_char"]
    pub fn numeric_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4_to_char"]
    pub fn int4_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_to_char"]
    pub fn int8_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4_to_char"]
    pub fn float4_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_to_char"]
    pub fn float8_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_to_number"]
    pub fn numeric_to_number(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_timestamp"]
    pub fn to_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_int8"]
    pub fn numeric_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_date"]
    pub fn to_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_numeric"]
    pub fn int8_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2_numeric"]
    pub fn int2_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_int2"]
    pub fn numeric_int2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidin"]
    pub fn oidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidout"]
    pub fn oidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_convert"]
    pub fn pg_convert(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_iclikesel"]
    pub fn iclikesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_icnlikesel"]
    pub fn icnlikesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_iclikejoinsel"]
    pub fn iclikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_icnlikejoinsel"]
    pub fn icnlikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexeqsel"]
    pub fn regexeqsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_likesel"]
    pub fn likesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_icregexeqsel"]
    pub fn icregexeqsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexnesel"]
    pub fn regexnesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_nlikesel"]
    pub fn nlikesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_icregexnesel"]
    pub fn icregexnesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexeqjoinsel"]
    pub fn regexeqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_likejoinsel"]
    pub fn likejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_icregexeqjoinsel"]
    pub fn icregexeqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexnejoinsel"]
    pub fn regexnejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_nlikejoinsel"]
    pub fn nlikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_icregexnejoinsel"]
    pub fn icregexnejoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_avg"]
    pub fn float8_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_var_samp"]
    pub fn float8_var_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_stddev_samp"]
    pub fn float8_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_accum"]
    pub fn numeric_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2_accum"]
    pub fn int2_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4_accum"]
    pub fn int4_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_accum"]
    pub fn int8_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_avg"]
    pub fn numeric_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_var_samp"]
    pub fn numeric_var_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_stddev_samp"]
    pub fn numeric_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2_sum"]
    pub fn int2_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4_sum"]
    pub fn int4_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_sum"]
    pub fn int8_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_accum"]
    pub fn interval_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_avg"]
    pub fn interval_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_ascii_default"]
    pub fn to_ascii_default(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_ascii_enc"]
    pub fn to_ascii_enc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_ascii_encname"]
    pub fn to_ascii_encname(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int28eq"]
    pub fn int28eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int28ne"]
    pub fn int28ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int28lt"]
    pub fn int28lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int28gt"]
    pub fn int28gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int28le"]
    pub fn int28le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int28ge"]
    pub fn int28ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int82eq"]
    pub fn int82eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int82ne"]
    pub fn int82ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int82lt"]
    pub fn int82lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int82gt"]
    pub fn int82gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int82le"]
    pub fn int82le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int82ge"]
    pub fn int82ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2and"]
    pub fn int2and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2or"]
    pub fn int2or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2xor"]
    pub fn int2xor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2not"]
    pub fn int2not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2shl"]
    pub fn int2shl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2shr"]
    pub fn int2shr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4and"]
    pub fn int4and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4or"]
    pub fn int4or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4xor"]
    pub fn int4xor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4not"]
    pub fn int4not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4shl"]
    pub fn int4shl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4shr"]
    pub fn int4shr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8and"]
    pub fn int8and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8or"]
    pub fn int8or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8xor"]
    pub fn int8xor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8not"]
    pub fn int8not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8shl"]
    pub fn int8shl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8shr"]
    pub fn int8shr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8up"]
    pub fn int8up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2up"]
    pub fn int2up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4up"]
    pub fn int4up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4up"]
    pub fn float4up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8up"]
    pub fn float8up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_uplus"]
    pub fn numeric_uplus(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_table_privilege_name_name"]
    pub fn has_table_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_table_privilege_name_id"]
    pub fn has_table_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_table_privilege_id_name"]
    pub fn has_table_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_table_privilege_id_id"]
    pub fn has_table_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_table_privilege_name"]
    pub fn has_table_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_table_privilege_id"]
    pub fn has_table_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_numscans"]
    pub fn pg_stat_get_numscans(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_tuples_returned"]
    pub fn pg_stat_get_tuples_returned(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_tuples_fetched"]
    pub fn pg_stat_get_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_tuples_inserted"]
    pub fn pg_stat_get_tuples_inserted(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_tuples_updated"]
    pub fn pg_stat_get_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_tuples_deleted"]
    pub fn pg_stat_get_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_blocks_fetched"]
    pub fn pg_stat_get_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_blocks_hit"]
    pub fn pg_stat_get_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_idset"]
    pub fn pg_stat_get_backend_idset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_pid"]
    pub fn pg_stat_get_backend_pid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_dbid"]
    pub fn pg_stat_get_backend_dbid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_userid"]
    pub fn pg_stat_get_backend_userid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_activity"]
    pub fn pg_stat_get_backend_activity(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_numbackends"]
    pub fn pg_stat_get_db_numbackends(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_xact_commit"]
    pub fn pg_stat_get_db_xact_commit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_xact_rollback"]
    pub fn pg_stat_get_db_xact_rollback(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_blocks_fetched"]
    pub fn pg_stat_get_db_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_blocks_hit"]
    pub fn pg_stat_get_db_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_encode"]
    pub fn binary_encode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_decode"]
    pub fn binary_decode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteaeq"]
    pub fn byteaeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bytealt"]
    pub fn bytealt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteale"]
    pub fn byteale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteagt"]
    pub fn byteagt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteage"]
    pub fn byteage(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteane"]
    pub fn byteane(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteacmp"]
    pub fn byteacmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_scale"]
    pub fn timestamp_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2_avg_accum"]
    pub fn int2_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4_avg_accum"]
    pub fn int4_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_avg"]
    pub fn int8_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidlarger"]
    pub fn oidlarger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidsmaller"]
    pub fn oidsmaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_scale"]
    pub fn timestamptz_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_scale"]
    pub fn time_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_scale"]
    pub fn timetz_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_tuples_hot_updated"]
    pub fn pg_stat_get_tuples_hot_updated(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_div_trunc"]
    pub fn numeric_div_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bytealike"]
    pub fn bytealike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteanlike"]
    pub fn byteanlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_like_escape_bytea"]
    pub fn like_escape_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteacat"]
    pub fn byteacat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bytea_substr"]
    pub fn bytea_substr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bytea_substr_no_len"]
    pub fn bytea_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteapos"]
    pub fn byteapos(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteatrim"]
    pub fn byteatrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_time"]
    pub fn timestamptz_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_trunc"]
    pub fn timestamp_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_part"]
    pub fn timestamp_part(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_activity"]
    pub fn pg_stat_get_activity(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstime_timestamp"]
    pub fn abstime_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_timestamp"]
    pub fn date_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_backend_pid"]
    pub fn pg_backend_pid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_timestamp"]
    pub fn timestamptz_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_timestamptz"]
    pub fn timestamp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_date"]
    pub fn timestamp_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_abstime"]
    pub fn timestamp_abstime(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_pl_interval"]
    pub fn timestamp_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_mi_interval"]
    pub fn timestamp_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_conf_load_time"]
    pub fn pg_conf_load_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_zone"]
    pub fn timetz_zone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_izone"]
    pub fn timetz_izone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_hash"]
    pub fn timestamp_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_time"]
    pub fn timetz_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_timetz"]
    pub fn time_timetz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_to_char"]
    pub fn timestamp_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_aggregate_dummy"]
    pub fn aggregate_dummy(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_age"]
    pub fn timestamp_age(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_zone"]
    pub fn timestamp_zone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_izone"]
    pub fn timestamp_izone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_pl_interval"]
    pub fn date_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_mi_interval"]
    pub fn date_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textregexsubstr"]
    pub fn textregexsubstr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitfromint8"]
    pub fn bitfromint8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bittoint8"]
    pub fn bittoint8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_show_config_by_name"]
    pub fn show_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_set_config_by_name"]
    pub fn set_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_table_is_visible"]
    pub fn pg_table_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_type_is_visible"]
    pub fn pg_type_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_function_is_visible"]
    pub fn pg_function_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_operator_is_visible"]
    pub fn pg_operator_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_opclass_is_visible"]
    pub fn pg_opclass_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_show_all_settings"]
    pub fn show_all_settings(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_replace_text"]
    pub fn replace_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_split_text"]
    pub fn split_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_hex32"]
    pub fn to_hex32(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_hex64"]
    pub fn to_hex64(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_lower"]
    pub fn array_lower(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_upper"]
    pub fn array_upper(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_conversion_is_visible"]
    pub fn pg_conversion_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_activity_start"]
    pub fn pg_stat_get_backend_activity_start(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_terminate_backend"]
    pub fn pg_terminate_backend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_functiondef"]
    pub fn pg_get_functiondef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_pattern_lt"]
    pub fn text_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_pattern_le"]
    pub fn text_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_function_arguments"]
    pub fn pg_get_function_arguments(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_pattern_ge"]
    pub fn text_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_pattern_gt"]
    pub fn text_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_function_result"]
    pub fn pg_get_function_result(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bttext_pattern_cmp"]
    pub fn bttext_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_database_size_name"]
    pub fn pg_database_size_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_width_bucket_numeric"]
    pub fn width_bucket_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_cancel_backend"]
    pub fn pg_cancel_backend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_start_backup"]
    pub fn pg_start_backup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stop_backup"]
    pub fn pg_stop_backup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchar_pattern_lt"]
    pub fn bpchar_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchar_pattern_le"]
    pub fn bpchar_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_length"]
    pub fn array_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchar_pattern_ge"]
    pub fn bpchar_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchar_pattern_gt"]
    pub fn bpchar_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_point_consistent"]
    pub fn gist_point_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btbpchar_pattern_cmp"]
    pub fn btbpchar_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_sequence_privilege_name_name"]
    pub fn has_sequence_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_sequence_privilege_name_id"]
    pub fn has_sequence_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_sequence_privilege_id_name"]
    pub fn has_sequence_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_sequence_privilege_id_id"]
    pub fn has_sequence_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_sequence_privilege_name"]
    pub fn has_sequence_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_sequence_privilege_id"]
    pub fn has_sequence_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint48cmp"]
    pub fn btint48cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint84cmp"]
    pub fn btint84cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint24cmp"]
    pub fn btint24cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint42cmp"]
    pub fn btint42cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint28cmp"]
    pub fn btint28cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint82cmp"]
    pub fn btint82cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btfloat48cmp"]
    pub fn btfloat48cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btfloat84cmp"]
    pub fn btfloat84cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_client_addr"]
    pub fn inet_client_addr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_client_port"]
    pub fn inet_client_port(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_server_addr"]
    pub fn inet_server_addr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_server_port"]
    pub fn inet_server_port(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regprocedurein"]
    pub fn regprocedurein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regprocedureout"]
    pub fn regprocedureout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regoperin"]
    pub fn regoperin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regoperout"]
    pub fn regoperout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regoperatorin"]
    pub fn regoperatorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regoperatorout"]
    pub fn regoperatorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regclassin"]
    pub fn regclassin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regclassout"]
    pub fn regclassout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regtypein"]
    pub fn regtypein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regtypeout"]
    pub fn regtypeout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_clear_snapshot"]
    pub fn pg_stat_clear_snapshot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_function_identity_arguments"]
    pub fn pg_get_function_identity_arguments(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_fmgr_internal_validator"]
    pub fn fmgr_internal_validator(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_fmgr_c_validator"]
    pub fn fmgr_c_validator(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_fmgr_sql_validator"]
    pub fn fmgr_sql_validator(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_database_privilege_name_name"]
    pub fn has_database_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_database_privilege_name_id"]
    pub fn has_database_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_database_privilege_id_name"]
    pub fn has_database_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_database_privilege_id_id"]
    pub fn has_database_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_database_privilege_name"]
    pub fn has_database_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_database_privilege_id"]
    pub fn has_database_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_function_privilege_name_name"]
    pub fn has_function_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_function_privilege_name_id"]
    pub fn has_function_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_function_privilege_id_name"]
    pub fn has_function_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_function_privilege_id_id"]
    pub fn has_function_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_function_privilege_name"]
    pub fn has_function_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_function_privilege_id"]
    pub fn has_function_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_language_privilege_name_name"]
    pub fn has_language_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_language_privilege_name_id"]
    pub fn has_language_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_language_privilege_id_name"]
    pub fn has_language_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_language_privilege_id_id"]
    pub fn has_language_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_language_privilege_name"]
    pub fn has_language_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_language_privilege_id"]
    pub fn has_language_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_schema_privilege_name_name"]
    pub fn has_schema_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_schema_privilege_name_id"]
    pub fn has_schema_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_schema_privilege_id_name"]
    pub fn has_schema_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_schema_privilege_id_id"]
    pub fn has_schema_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_schema_privilege_name"]
    pub fn has_schema_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_schema_privilege_id"]
    pub fn has_schema_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_reset"]
    pub fn pg_stat_reset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textregexreplace_noopt"]
    pub fn textregexreplace_noopt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textregexreplace"]
    pub fn textregexreplace(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_total_relation_size"]
    pub fn pg_total_relation_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_size_pretty"]
    pub fn pg_size_pretty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_options_to_table"]
    pub fn pg_options_to_table(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_in"]
    pub fn record_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_out"]
    pub fn record_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cstring_in"]
    pub fn cstring_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cstring_out"]
    pub fn cstring_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_any_in"]
    pub fn any_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_any_out"]
    pub fn any_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anyarray_in"]
    pub fn anyarray_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anyarray_out"]
    pub fn anyarray_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_void_in"]
    pub fn void_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_void_out"]
    pub fn void_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_trigger_in"]
    pub fn trigger_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_trigger_out"]
    pub fn trigger_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_language_handler_in"]
    pub fn language_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_language_handler_out"]
    pub fn language_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_internal_in"]
    pub fn internal_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_internal_out"]
    pub fn internal_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_opaque_in"]
    pub fn opaque_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_opaque_out"]
    pub fn opaque_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dceil"]
    pub fn dceil(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dfloor"]
    pub fn dfloor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dsign"]
    pub fn dsign(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_md5_text"]
    pub fn md5_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anyelement_in"]
    pub fn anyelement_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anyelement_out"]
    pub fn anyelement_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_postgresql_fdw_validator"]
    pub fn postgresql_fdw_validator(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_encoding_max_length_sql"]
    pub fn pg_encoding_max_length_sql(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_md5_bytea"]
    pub fn md5_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_tablespace_size_oid"]
    pub fn pg_tablespace_size_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_tablespace_size_name"]
    pub fn pg_tablespace_size_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_database_size_oid"]
    pub fn pg_database_size_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_unnest"]
    pub fn array_unnest(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_relation_size"]
    pub fn pg_relation_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_agg_transfn"]
    pub fn array_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_agg_finalfn"]
    pub fn array_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_lt_timestamp"]
    pub fn date_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_le_timestamp"]
    pub fn date_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_eq_timestamp"]
    pub fn date_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_gt_timestamp"]
    pub fn date_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_ge_timestamp"]
    pub fn date_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_ne_timestamp"]
    pub fn date_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_cmp_timestamp"]
    pub fn date_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_lt_timestamptz"]
    pub fn date_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_le_timestamptz"]
    pub fn date_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_eq_timestamptz"]
    pub fn date_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_gt_timestamptz"]
    pub fn date_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_ge_timestamptz"]
    pub fn date_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_ne_timestamptz"]
    pub fn date_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_cmp_timestamptz"]
    pub fn date_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_lt_date"]
    pub fn timestamp_lt_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_le_date"]
    pub fn timestamp_le_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_eq_date"]
    pub fn timestamp_eq_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_gt_date"]
    pub fn timestamp_gt_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_ge_date"]
    pub fn timestamp_ge_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_ne_date"]
    pub fn timestamp_ne_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_cmp_date"]
    pub fn timestamp_cmp_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_lt_date"]
    pub fn timestamptz_lt_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_le_date"]
    pub fn timestamptz_le_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_eq_date"]
    pub fn timestamptz_eq_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_gt_date"]
    pub fn timestamptz_gt_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_ge_date"]
    pub fn timestamptz_ge_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_ne_date"]
    pub fn timestamptz_ne_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_cmp_date"]
    pub fn timestamptz_cmp_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_tablespace_privilege_name_name"]
    pub fn has_tablespace_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_tablespace_privilege_name_id"]
    pub fn has_tablespace_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_tablespace_privilege_id_name"]
    pub fn has_tablespace_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_tablespace_privilege_id_id"]
    pub fn has_tablespace_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_tablespace_privilege_name"]
    pub fn has_tablespace_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_tablespace_privilege_id"]
    pub fn has_tablespace_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_shell_in"]
    pub fn shell_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_shell_out"]
    pub fn shell_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_recv"]
    pub fn array_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_send"]
    pub fn array_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_recv"]
    pub fn record_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_send"]
    pub fn record_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2recv"]
    pub fn int2recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2send"]
    pub fn int2send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4recv"]
    pub fn int4recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4send"]
    pub fn int4send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8recv"]
    pub fn int8recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8send"]
    pub fn int8send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2vectorrecv"]
    pub fn int2vectorrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2vectorsend"]
    pub fn int2vectorsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bytearecv"]
    pub fn bytearecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_byteasend"]
    pub fn byteasend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textrecv"]
    pub fn textrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_textsend"]
    pub fn textsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_unknownrecv"]
    pub fn unknownrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_unknownsend"]
    pub fn unknownsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidrecv"]
    pub fn oidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidsend"]
    pub fn oidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidvectorrecv"]
    pub fn oidvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_oidvectorsend"]
    pub fn oidvectorsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_namerecv"]
    pub fn namerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_namesend"]
    pub fn namesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4recv"]
    pub fn float4recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float4send"]
    pub fn float4send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8recv"]
    pub fn float8recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8send"]
    pub fn float8send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_recv"]
    pub fn point_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_send"]
    pub fn point_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpcharrecv"]
    pub fn bpcharrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpcharsend"]
    pub fn bpcharsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varcharrecv"]
    pub fn varcharrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varcharsend"]
    pub fn varcharsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_charrecv"]
    pub fn charrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_charsend"]
    pub fn charsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_boolrecv"]
    pub fn boolrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_boolsend"]
    pub fn boolsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tidrecv"]
    pub fn tidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tidsend"]
    pub fn tidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xidrecv"]
    pub fn xidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xidsend"]
    pub fn xidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cidrecv"]
    pub fn cidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cidsend"]
    pub fn cidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regprocrecv"]
    pub fn regprocrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regprocsend"]
    pub fn regprocsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regprocedurerecv"]
    pub fn regprocedurerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regproceduresend"]
    pub fn regproceduresend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regoperrecv"]
    pub fn regoperrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regopersend"]
    pub fn regopersend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regoperatorrecv"]
    pub fn regoperatorrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regoperatorsend"]
    pub fn regoperatorsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regclassrecv"]
    pub fn regclassrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regclasssend"]
    pub fn regclasssend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regtyperecv"]
    pub fn regtyperecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regtypesend"]
    pub fn regtypesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bit_recv"]
    pub fn bit_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bit_send"]
    pub fn bit_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varbit_recv"]
    pub fn varbit_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varbit_send"]
    pub fn varbit_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_recv"]
    pub fn numeric_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_send"]
    pub fn numeric_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstimerecv"]
    pub fn abstimerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_abstimesend"]
    pub fn abstimesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_reltimerecv"]
    pub fn reltimerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_reltimesend"]
    pub fn reltimesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalrecv"]
    pub fn tintervalrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tintervalsend"]
    pub fn tintervalsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_recv"]
    pub fn date_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_send"]
    pub fn date_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_recv"]
    pub fn time_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_send"]
    pub fn time_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_recv"]
    pub fn timetz_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_send"]
    pub fn timetz_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_recv"]
    pub fn timestamp_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_send"]
    pub fn timestamp_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_recv"]
    pub fn timestamptz_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_send"]
    pub fn timestamptz_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_recv"]
    pub fn interval_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_send"]
    pub fn interval_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_recv"]
    pub fn lseg_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lseg_send"]
    pub fn lseg_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_recv"]
    pub fn path_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_path_send"]
    pub fn path_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_recv"]
    pub fn box_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_send"]
    pub fn box_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_recv"]
    pub fn poly_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_send"]
    pub fn poly_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_recv"]
    pub fn line_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_line_send"]
    pub fn line_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_recv"]
    pub fn circle_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_send"]
    pub fn circle_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_recv"]
    pub fn cash_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_send"]
    pub fn cash_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_recv"]
    pub fn macaddr_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_send"]
    pub fn macaddr_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_recv"]
    pub fn inet_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_send"]
    pub fn inet_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cidr_recv"]
    pub fn cidr_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cidr_send"]
    pub fn cidr_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cstring_recv"]
    pub fn cstring_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cstring_send"]
    pub fn cstring_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anyarray_recv"]
    pub fn anyarray_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anyarray_send"]
    pub fn anyarray_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_ruledef_ext"]
    pub fn pg_get_ruledef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_viewdef_name_ext"]
    pub fn pg_get_viewdef_name_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_viewdef_ext"]
    pub fn pg_get_viewdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_indexdef_ext"]
    pub fn pg_get_indexdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_constraintdef_ext"]
    pub fn pg_get_constraintdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_expr_ext"]
    pub fn pg_get_expr_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_prepared_statement"]
    pub fn pg_prepared_statement(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_cursor"]
    pub fn pg_cursor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_var_pop"]
    pub fn float8_var_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_stddev_pop"]
    pub fn float8_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_var_pop"]
    pub fn numeric_var_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_booland_statefunc"]
    pub fn booland_statefunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_boolor_statefunc"]
    pub fn boolor_statefunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_lt_timestamptz"]
    pub fn timestamp_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_le_timestamptz"]
    pub fn timestamp_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_eq_timestamptz"]
    pub fn timestamp_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_gt_timestamptz"]
    pub fn timestamp_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_ge_timestamptz"]
    pub fn timestamp_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_ne_timestamptz"]
    pub fn timestamp_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_cmp_timestamptz"]
    pub fn timestamp_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_lt_timestamp"]
    pub fn timestamptz_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_le_timestamp"]
    pub fn timestamptz_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_eq_timestamp"]
    pub fn timestamptz_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_gt_timestamp"]
    pub fn timestamptz_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_ge_timestamp"]
    pub fn timestamptz_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_ne_timestamp"]
    pub fn timestamptz_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptz_cmp_timestamp"]
    pub fn timestamptz_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_tablespace_databases"]
    pub fn pg_tablespace_databases(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4_bool"]
    pub fn int4_bool(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bool_int4"]
    pub fn bool_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_lastval"]
    pub fn lastval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_postmaster_start_time"]
    pub fn pg_postmaster_start_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_blocking_pids"]
    pub fn pg_blocking_pids(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_below"]
    pub fn box_below(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_overbelow"]
    pub fn box_overbelow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_overabove"]
    pub fn box_overabove(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_box_above"]
    pub fn box_above(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_below"]
    pub fn poly_below(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_overbelow"]
    pub fn poly_overbelow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_overabove"]
    pub fn poly_overabove(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_poly_above"]
    pub fn poly_above(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_box_consistent"]
    pub fn gist_box_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_float8"]
    pub fn jsonb_float8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_box_penalty"]
    pub fn gist_box_penalty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_box_picksplit"]
    pub fn gist_box_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_box_union"]
    pub fn gist_box_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_box_same"]
    pub fn gist_box_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_poly_consistent"]
    pub fn gist_poly_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_poly_compress"]
    pub fn gist_poly_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_overbelow"]
    pub fn circle_overbelow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_circle_overabove"]
    pub fn circle_overabove(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_circle_consistent"]
    pub fn gist_circle_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_circle_compress"]
    pub fn gist_circle_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_stddev_pop"]
    pub fn numeric_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_domain_in"]
    pub fn domain_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_domain_recv"]
    pub fn domain_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_timezone_abbrevs"]
    pub fn pg_timezone_abbrevs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xmlexists"]
    pub fn xmlexists(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_reload_conf"]
    pub fn pg_reload_conf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_rotate_logfile_v2"]
    pub fn pg_rotate_logfile_v2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_file_1arg"]
    pub fn pg_stat_file_1arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_read_file_off_len"]
    pub fn pg_read_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ls_dir_1arg"]
    pub fn pg_ls_dir_1arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_sleep"]
    pub fn pg_sleep(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inetnot"]
    pub fn inetnot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inetand"]
    pub fn inetand(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inetor"]
    pub fn inetor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inetpl"]
    pub fn inetpl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inetmi_int8"]
    pub fn inetmi_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inetmi"]
    pub fn inetmi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_statement_timestamp"]
    pub fn statement_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_clock_timestamp"]
    pub fn clock_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_cmp_prefix"]
    pub fn gin_cmp_prefix(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_has_role_name_name"]
    pub fn pg_has_role_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_has_role_name_id"]
    pub fn pg_has_role_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_has_role_id_name"]
    pub fn pg_has_role_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_has_role_id_id"]
    pub fn pg_has_role_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_has_role_name"]
    pub fn pg_has_role_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_has_role_id"]
    pub fn pg_has_role_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_justify_interval"]
    pub fn interval_justify_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_triggerdef_ext"]
    pub fn pg_get_triggerdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dasind"]
    pub fn dasind(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dacosd"]
    pub fn dacosd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_datand"]
    pub fn datand(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_datan2d"]
    pub fn datan2d(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dsind"]
    pub fn dsind(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dcosd"]
    pub fn dcosd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dtand"]
    pub fn dtand(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dcotd"]
    pub fn dcotd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stop_backup_v2"]
    pub fn pg_stop_backup_v2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_avg_serialize"]
    pub fn numeric_avg_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_avg_deserialize"]
    pub fn numeric_avg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ginarrayextract"]
    pub fn ginarrayextract(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ginarrayconsistent"]
    pub fn ginarrayconsistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_avg_accum"]
    pub fn int8_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_arrayoverlap"]
    pub fn arrayoverlap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_arraycontains"]
    pub fn arraycontains(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_arraycontained"]
    pub fn arraycontained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_tuples_returned"]
    pub fn pg_stat_get_db_tuples_returned(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_tuples_fetched"]
    pub fn pg_stat_get_db_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_tuples_inserted"]
    pub fn pg_stat_get_db_tuples_inserted(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_tuples_updated"]
    pub fn pg_stat_get_db_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_tuples_deleted"]
    pub fn pg_stat_get_db_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexp_matches_no_flags"]
    pub fn regexp_matches_no_flags(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexp_matches"]
    pub fn regexp_matches(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexp_split_to_table_no_flags"]
    pub fn regexp_split_to_table_no_flags(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexp_split_to_table"]
    pub fn regexp_split_to_table(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexp_split_to_array_no_flags"]
    pub fn regexp_split_to_array_no_flags(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexp_split_to_array"]
    pub fn regexp_split_to_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_bgwriter_timed_checkpoints"]
    pub fn pg_stat_get_bgwriter_timed_checkpoints(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_bgwriter_requested_checkpoints"]
    pub fn pg_stat_get_bgwriter_requested_checkpoints(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_bgwriter_buf_written_checkpoints"]
    pub fn pg_stat_get_bgwriter_buf_written_checkpoints(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_bgwriter_buf_written_clean"]
    pub fn pg_stat_get_bgwriter_buf_written_clean(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_bgwriter_maxwritten_clean"]
    pub fn pg_stat_get_bgwriter_maxwritten_clean(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ginqueryarrayextract"]
    pub fn ginqueryarrayextract(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_buf_written_backend"]
    pub fn pg_stat_get_buf_written_backend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anynonarray_in"]
    pub fn anynonarray_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anynonarray_out"]
    pub fn anynonarray_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_last_vacuum_time"]
    pub fn pg_stat_get_last_vacuum_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_last_autovacuum_time"]
    pub fn pg_stat_get_last_autovacuum_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_last_analyze_time"]
    pub fn pg_stat_get_last_analyze_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_last_autoanalyze_time"]
    pub fn pg_stat_get_last_autoanalyze_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_avg_combine"]
    pub fn int8_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_avg_serialize"]
    pub fn int8_avg_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_avg_deserialize"]
    pub fn int8_avg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_wait_event_type"]
    pub fn pg_stat_get_backend_wait_event_type(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tidgt"]
    pub fn tidgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tidlt"]
    pub fn tidlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tidge"]
    pub fn tidge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tidle"]
    pub fn tidle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bttidcmp"]
    pub fn bttidcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tidlarger"]
    pub fn tidlarger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tidsmaller"]
    pub fn tidsmaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8inc_any"]
    pub fn int8inc_any(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8inc_float8_float8"]
    pub fn int8inc_float8_float8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_regr_accum"]
    pub fn float8_regr_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_regr_sxx"]
    pub fn float8_regr_sxx(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_regr_syy"]
    pub fn float8_regr_syy(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_regr_sxy"]
    pub fn float8_regr_sxy(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_regr_avgx"]
    pub fn float8_regr_avgx(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_regr_avgy"]
    pub fn float8_regr_avgy(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_regr_r2"]
    pub fn float8_regr_r2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_regr_slope"]
    pub fn float8_regr_slope(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_regr_intercept"]
    pub fn float8_regr_intercept(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_covar_pop"]
    pub fn float8_covar_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_covar_samp"]
    pub fn float8_covar_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_corr"]
    pub fn float8_corr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_blk_read_time"]
    pub fn pg_stat_get_db_blk_read_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_blk_write_time"]
    pub fn pg_stat_get_db_blk_write_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_switch_wal"]
    pub fn pg_switch_wal(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_current_wal_lsn"]
    pub fn pg_current_wal_lsn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_walfile_name_offset"]
    pub fn pg_walfile_name_offset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_walfile_name"]
    pub fn pg_walfile_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_current_wal_insert_lsn"]
    pub fn pg_current_wal_insert_lsn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_wait_event"]
    pub fn pg_stat_get_backend_wait_event(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_my_temp_schema"]
    pub fn pg_my_temp_schema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_is_other_temp_schema"]
    pub fn pg_is_other_temp_schema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_timezone_names"]
    pub fn pg_timezone_names(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_backend_xact_start"]
    pub fn pg_stat_get_backend_xact_start(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_avg_accum"]
    pub fn numeric_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_buf_alloc"]
    pub fn pg_stat_get_buf_alloc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_live_tuples"]
    pub fn pg_stat_get_live_tuples(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_dead_tuples"]
    pub fn pg_stat_get_dead_tuples(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_lock_int8"]
    pub fn pg_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_lock_shared_int8"]
    pub fn pg_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_try_advisory_lock_int8"]
    pub fn pg_try_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_try_advisory_lock_shared_int8"]
    pub fn pg_try_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_unlock_int8"]
    pub fn pg_advisory_unlock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_unlock_shared_int8"]
    pub fn pg_advisory_unlock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_lock_int4"]
    pub fn pg_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_lock_shared_int4"]
    pub fn pg_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_try_advisory_lock_int4"]
    pub fn pg_try_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_try_advisory_lock_shared_int4"]
    pub fn pg_try_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_unlock_int4"]
    pub fn pg_advisory_unlock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_unlock_shared_int4"]
    pub fn pg_advisory_unlock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_unlock_all"]
    pub fn pg_advisory_unlock_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xml_in"]
    pub fn xml_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xml_out"]
    pub fn xml_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xmlcomment"]
    pub fn xmlcomment(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_texttoxml"]
    pub fn texttoxml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xmlvalidate"]
    pub fn xmlvalidate(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xml_recv"]
    pub fn xml_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xml_send"]
    pub fn xml_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xmlconcat2"]
    pub fn xmlconcat2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varbittypmodin"]
    pub fn varbittypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_intervaltypmodin"]
    pub fn intervaltypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_intervaltypmodout"]
    pub fn intervaltypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptypmodin"]
    pub fn timestamptypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptypmodout"]
    pub fn timestamptypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptztypmodin"]
    pub fn timestamptztypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamptztypmodout"]
    pub fn timestamptztypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetypmodin"]
    pub fn timetypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetypmodout"]
    pub fn timetypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetztypmodin"]
    pub fn timetztypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetztypmodout"]
    pub fn timetztypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchartypmodin"]
    pub fn bpchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchartypmodout"]
    pub fn bpchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varchartypmodin"]
    pub fn varchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varchartypmodout"]
    pub fn varchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numerictypmodin"]
    pub fn numerictypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numerictypmodout"]
    pub fn numerictypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bittypmodin"]
    pub fn bittypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bittypmodout"]
    pub fn bittypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varbittypmodout"]
    pub fn varbittypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xmltotext"]
    pub fn xmltotext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_table_to_xml"]
    pub fn table_to_xml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_query_to_xml"]
    pub fn query_to_xml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cursor_to_xml"]
    pub fn cursor_to_xml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_table_to_xmlschema"]
    pub fn table_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_query_to_xmlschema"]
    pub fn query_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cursor_to_xmlschema"]
    pub fn cursor_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_table_to_xml_and_xmlschema"]
    pub fn table_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_query_to_xml_and_xmlschema"]
    pub fn query_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xpath"]
    pub fn xpath(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_schema_to_xml"]
    pub fn schema_to_xml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_schema_to_xmlschema"]
    pub fn schema_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_schema_to_xml_and_xmlschema"]
    pub fn schema_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_database_to_xml"]
    pub fn database_to_xml(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_database_to_xmlschema"]
    pub fn database_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_database_to_xml_and_xmlschema"]
    pub fn database_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_snapshot_in"]
    pub fn txid_snapshot_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_snapshot_out"]
    pub fn txid_snapshot_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_snapshot_recv"]
    pub fn txid_snapshot_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_snapshot_send"]
    pub fn txid_snapshot_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_current"]
    pub fn txid_current(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_current_snapshot"]
    pub fn txid_current_snapshot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_snapshot_xmin"]
    pub fn txid_snapshot_xmin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_snapshot_xmax"]
    pub fn txid_snapshot_xmax(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_snapshot_xip"]
    pub fn txid_snapshot_xip(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_visible_in_snapshot"]
    pub fn txid_visible_in_snapshot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_in"]
    pub fn uuid_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_out"]
    pub fn uuid_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_lt"]
    pub fn uuid_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_le"]
    pub fn uuid_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_eq"]
    pub fn uuid_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_ge"]
    pub fn uuid_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_gt"]
    pub fn uuid_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_ne"]
    pub fn uuid_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_cmp"]
    pub fn uuid_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_recv"]
    pub fn uuid_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_send"]
    pub fn uuid_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_hash"]
    pub fn uuid_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_booltext"]
    pub fn booltext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_function_calls"]
    pub fn pg_stat_get_function_calls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_function_total_time"]
    pub fn pg_stat_get_function_total_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_function_self_time"]
    pub fn pg_stat_get_function_self_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_eq"]
    pub fn record_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_ne"]
    pub fn record_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_lt"]
    pub fn record_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_gt"]
    pub fn record_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_le"]
    pub fn record_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_ge"]
    pub fn record_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btrecordcmp"]
    pub fn btrecordcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_table_size"]
    pub fn pg_table_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_indexes_size"]
    pub fn pg_indexes_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_relation_filenode"]
    pub fn pg_relation_filenode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_foreign_data_wrapper_privilege_name_name"]
    pub fn has_foreign_data_wrapper_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_foreign_data_wrapper_privilege_name_id"]
    pub fn has_foreign_data_wrapper_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_foreign_data_wrapper_privilege_id_name"]
    pub fn has_foreign_data_wrapper_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_foreign_data_wrapper_privilege_id_id"]
    pub fn has_foreign_data_wrapper_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_foreign_data_wrapper_privilege_name"]
    pub fn has_foreign_data_wrapper_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_foreign_data_wrapper_privilege_id"]
    pub fn has_foreign_data_wrapper_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_server_privilege_name_name"]
    pub fn has_server_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_server_privilege_name_id"]
    pub fn has_server_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_server_privilege_id_name"]
    pub fn has_server_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_server_privilege_id_id"]
    pub fn has_server_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_server_privilege_name"]
    pub fn has_server_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_server_privilege_id"]
    pub fn has_server_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_name_name_name"]
    pub fn has_column_privilege_name_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_name_name_attnum"]
    pub fn has_column_privilege_name_name_attnum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_name_id_name"]
    pub fn has_column_privilege_name_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_name_id_attnum"]
    pub fn has_column_privilege_name_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_id_name_name"]
    pub fn has_column_privilege_id_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_id_name_attnum"]
    pub fn has_column_privilege_id_name_attnum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_id_id_name"]
    pub fn has_column_privilege_id_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_id_id_attnum"]
    pub fn has_column_privilege_id_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_name_name"]
    pub fn has_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_name_attnum"]
    pub fn has_column_privilege_name_attnum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_id_name"]
    pub fn has_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_column_privilege_id_attnum"]
    pub fn has_column_privilege_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_any_column_privilege_name_name"]
    pub fn has_any_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_any_column_privilege_name_id"]
    pub fn has_any_column_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_any_column_privilege_id_name"]
    pub fn has_any_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_any_column_privilege_id_id"]
    pub fn has_any_column_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_any_column_privilege_name"]
    pub fn has_any_column_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_any_column_privilege_id"]
    pub fn has_any_column_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitoverlay"]
    pub fn bitoverlay(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitoverlay_no_len"]
    pub fn bitoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitgetbit"]
    pub fn bitgetbit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bitsetbit"]
    pub fn bitsetbit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_relation_filepath"]
    pub fn pg_relation_filepath(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_listening_channels"]
    pub fn pg_listening_channels(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_notify"]
    pub fn pg_notify(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_numscans"]
    pub fn pg_stat_get_xact_numscans(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_tuples_returned"]
    pub fn pg_stat_get_xact_tuples_returned(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_tuples_fetched"]
    pub fn pg_stat_get_xact_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_tuples_inserted"]
    pub fn pg_stat_get_xact_tuples_inserted(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_tuples_updated"]
    pub fn pg_stat_get_xact_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_tuples_deleted"]
    pub fn pg_stat_get_xact_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_tuples_hot_updated"]
    pub fn pg_stat_get_xact_tuples_hot_updated(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_blocks_fetched"]
    pub fn pg_stat_get_xact_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_blocks_hit"]
    pub fn pg_stat_get_xact_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_function_calls"]
    pub fn pg_stat_get_xact_function_calls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_function_total_time"]
    pub fn pg_stat_get_xact_function_total_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_xact_function_self_time"]
    pub fn pg_stat_get_xact_function_self_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xpath_exists"]
    pub fn xpath_exists(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xml_is_well_formed"]
    pub fn xml_is_well_formed(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xml_is_well_formed_document"]
    pub fn xml_is_well_formed_document(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xml_is_well_formed_content"]
    pub fn xml_is_well_formed_content(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_vacuum_count"]
    pub fn pg_stat_get_vacuum_count(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_autovacuum_count"]
    pub fn pg_stat_get_autovacuum_count(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_analyze_count"]
    pub fn pg_stat_get_analyze_count(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_autoanalyze_count"]
    pub fn pg_stat_get_autoanalyze_count(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_concat"]
    pub fn text_concat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_concat_ws"]
    pub fn text_concat_ws(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_left"]
    pub fn text_left(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_right"]
    pub fn text_right(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_reverse"]
    pub fn text_reverse(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_buf_fsync_backend"]
    pub fn pg_stat_get_buf_fsync_backend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_point_distance"]
    pub fn gist_point_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_conflict_tablespace"]
    pub fn pg_stat_get_db_conflict_tablespace(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_conflict_lock"]
    pub fn pg_stat_get_db_conflict_lock(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_conflict_snapshot"]
    pub fn pg_stat_get_db_conflict_snapshot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_conflict_bufferpin"]
    pub fn pg_stat_get_db_conflict_bufferpin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_conflict_startup_deadlock"]
    pub fn pg_stat_get_db_conflict_startup_deadlock(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_conflict_all"]
    pub fn pg_stat_get_db_conflict_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_wal_replay_pause"]
    pub fn pg_wal_replay_pause(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_wal_replay_resume"]
    pub fn pg_wal_replay_resume(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_is_wal_replay_paused"]
    pub fn pg_is_wal_replay_paused(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_stat_reset_time"]
    pub fn pg_stat_get_db_stat_reset_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_bgwriter_stat_reset_time"]
    pub fn pg_stat_get_bgwriter_stat_reset_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ginarrayextract_2args"]
    pub fn ginarrayextract_2args(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_extract_tsvector_2args"]
    pub fn gin_extract_tsvector_2args(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_sequence_parameters"]
    pub fn pg_sequence_parameters(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_available_extensions"]
    pub fn pg_available_extensions(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_available_extension_versions"]
    pub fn pg_available_extension_versions(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_extension_update_paths"]
    pub fn pg_extension_update_paths(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_extension_config_dump"]
    pub fn pg_extension_config_dump(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_extract_tsquery_5args"]
    pub fn gin_extract_tsquery_5args(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_tsquery_consistent_6args"]
    pub fn gin_tsquery_consistent_6args(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_xact_lock_int8"]
    pub fn pg_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_xact_lock_shared_int8"]
    pub fn pg_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_try_advisory_xact_lock_int8"]
    pub fn pg_try_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_try_advisory_xact_lock_shared_int8"]
    pub fn pg_try_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_xact_lock_int4"]
    pub fn pg_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_advisory_xact_lock_shared_int4"]
    pub fn pg_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_try_advisory_xact_lock_int4"]
    pub fn pg_try_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_try_advisory_xact_lock_shared_int4"]
    pub fn pg_try_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varchar_transform"]
    pub fn varchar_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_create_restore_point"]
    pub fn pg_create_restore_point(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_wal_senders"]
    pub fn pg_stat_get_wal_senders(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_row_number"]
    pub fn window_row_number(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_rank"]
    pub fn window_rank(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_dense_rank"]
    pub fn window_dense_rank(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_percent_rank"]
    pub fn window_percent_rank(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_cume_dist"]
    pub fn window_cume_dist(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_ntile"]
    pub fn window_ntile(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_lag"]
    pub fn window_lag(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_lag_with_offset"]
    pub fn window_lag_with_offset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_lag_with_offset_and_default"]
    pub fn window_lag_with_offset_and_default(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_lead"]
    pub fn window_lead(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_lead_with_offset"]
    pub fn window_lead_with_offset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_lead_with_offset_and_default"]
    pub fn window_lead_with_offset_and_default(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_first_value"]
    pub fn window_first_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_last_value"]
    pub fn window_last_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_window_nth_value"]
    pub fn window_nth_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_fdw_handler_in"]
    pub fn fdw_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_fdw_handler_out"]
    pub fn fdw_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_void_recv"]
    pub fn void_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_void_send"]
    pub fn void_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint2sortsupport"]
    pub fn btint2sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint4sortsupport"]
    pub fn btint4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btint8sortsupport"]
    pub fn btint8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btfloat4sortsupport"]
    pub fn btfloat4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btfloat8sortsupport"]
    pub fn btfloat8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btoidsortsupport"]
    pub fn btoidsortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btnamesortsupport"]
    pub fn btnamesortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_date_sortsupport"]
    pub fn date_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_sortsupport"]
    pub fn timestamp_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_type_privilege_name_name"]
    pub fn has_type_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_type_privilege_name_id"]
    pub fn has_type_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_type_privilege_id_name"]
    pub fn has_type_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_type_privilege_id_id"]
    pub fn has_type_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_type_privilege_name"]
    pub fn has_type_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_has_type_privilege_id"]
    pub fn has_type_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_not"]
    pub fn macaddr_not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_and"]
    pub fn macaddr_and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_or"]
    pub fn macaddr_or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_temp_files"]
    pub fn pg_stat_get_db_temp_files(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_temp_bytes"]
    pub fn pg_stat_get_db_temp_bytes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_db_deadlocks"]
    pub fn pg_stat_get_db_deadlocks(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_to_json"]
    pub fn array_to_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_to_json_pretty"]
    pub fn array_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_row_to_json"]
    pub fn row_to_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_row_to_json_pretty"]
    pub fn row_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_transform"]
    pub fn numeric_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_varbit_transform"]
    pub fn varbit_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_viewdef_wrap"]
    pub fn pg_get_viewdef_wrap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_checkpoint_write_time"]
    pub fn pg_stat_get_checkpoint_write_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_checkpoint_sync_time"]
    pub fn pg_stat_get_checkpoint_sync_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_collation_for"]
    pub fn pg_collation_for(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_trigger_depth"]
    pub fn pg_trigger_depth(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_wal_lsn_diff"]
    pub fn pg_wal_lsn_diff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_size_pretty_numeric"]
    pub fn pg_size_pretty_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_remove"]
    pub fn array_remove(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_replace"]
    pub fn array_replace(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_rangesel"]
    pub fn rangesel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_lseek64"]
    pub fn be_lo_lseek64(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_tell64"]
    pub fn be_lo_tell64(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_truncate64"]
    pub fn be_lo_truncate64(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_agg_transfn"]
    pub fn json_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_agg_finalfn"]
    pub fn json_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_json"]
    pub fn to_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_mod_since_analyze"]
    pub fn pg_stat_get_mod_since_analyze(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_sum"]
    pub fn numeric_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_cardinality"]
    pub fn array_cardinality(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_object_agg_transfn"]
    pub fn json_object_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_image_eq"]
    pub fn record_image_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_image_ne"]
    pub fn record_image_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_image_lt"]
    pub fn record_image_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_image_gt"]
    pub fn record_image_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_image_le"]
    pub fn record_image_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_record_image_ge"]
    pub fn record_image_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btrecordimagecmp"]
    pub fn btrecordimagecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_archiver"]
    pub fn pg_stat_get_archiver(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_object_agg_finalfn"]
    pub fn json_object_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_build_array"]
    pub fn json_build_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_build_array_noargs"]
    pub fn json_build_array_noargs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_build_object"]
    pub fn json_build_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_build_object_noargs"]
    pub fn json_build_object_noargs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_object"]
    pub fn json_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_object_two_arg"]
    pub fn json_object_two_arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_to_record"]
    pub fn json_to_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_to_recordset"]
    pub fn json_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_array_length"]
    pub fn jsonb_array_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_each"]
    pub fn jsonb_each(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_populate_record"]
    pub fn jsonb_populate_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_typeof"]
    pub fn jsonb_typeof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_object_field_text"]
    pub fn jsonb_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_array_element"]
    pub fn jsonb_array_element(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_array_element_text"]
    pub fn jsonb_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_extract_path"]
    pub fn jsonb_extract_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_width_bucket_array"]
    pub fn width_bucket_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_array_elements"]
    pub fn jsonb_array_elements(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_in"]
    pub fn pg_lsn_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_out"]
    pub fn pg_lsn_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_lt"]
    pub fn pg_lsn_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_le"]
    pub fn pg_lsn_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_eq"]
    pub fn pg_lsn_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_ge"]
    pub fn pg_lsn_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_gt"]
    pub fn pg_lsn_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_ne"]
    pub fn pg_lsn_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_mi"]
    pub fn pg_lsn_mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_recv"]
    pub fn pg_lsn_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_send"]
    pub fn pg_lsn_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_cmp"]
    pub fn pg_lsn_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_hash"]
    pub fn pg_lsn_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bttextsortsupport"]
    pub fn bttextsortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_generate_series_step_numeric"]
    pub fn generate_series_step_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_generate_series_numeric"]
    pub fn generate_series_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_strip_nulls"]
    pub fn json_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_strip_nulls"]
    pub fn jsonb_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_object"]
    pub fn jsonb_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_object_two_arg"]
    pub fn jsonb_object_two_arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_agg_transfn"]
    pub fn jsonb_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_agg_finalfn"]
    pub fn jsonb_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_object_agg_transfn"]
    pub fn jsonb_object_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_object_agg_finalfn"]
    pub fn jsonb_object_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_build_array"]
    pub fn jsonb_build_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_build_array_noargs"]
    pub fn jsonb_build_array_noargs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_build_object"]
    pub fn jsonb_build_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_build_object_noargs"]
    pub fn jsonb_build_object_noargs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_ppoly"]
    pub fn dist_ppoly(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_position"]
    pub fn array_position(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_position_start"]
    pub fn array_position_start(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_positions"]
    pub fn array_positions(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_circle_distance"]
    pub fn gist_circle_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_scale"]
    pub fn numeric_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_point_fetch"]
    pub fn gist_point_fetch(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_sortsupport"]
    pub fn numeric_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gist_poly_distance"]
    pub fn gist_poly_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_cpoint"]
    pub fn dist_cpoint(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dist_polyp"]
    pub fn dist_polyp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_read_file_v2"]
    pub fn pg_read_file_v2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_show_config_by_name_missing_ok"]
    pub fn show_config_by_name_missing_ok(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_read_binary_file"]
    pub fn pg_read_binary_file(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_notification_queue_usage"]
    pub fn pg_notification_queue_usage(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ls_dir"]
    pub fn pg_ls_dir(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_row_security_active"]
    pub fn row_security_active(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_row_security_active_name"]
    pub fn row_security_active_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_sortsupport"]
    pub fn uuid_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_concat"]
    pub fn jsonb_concat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_delete"]
    pub fn jsonb_delete(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_delete_idx"]
    pub fn jsonb_delete_idx(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_delete_path"]
    pub fn jsonb_delete_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_set"]
    pub fn jsonb_set(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_pretty"]
    pub fn jsonb_pretty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_file"]
    pub fn pg_stat_file(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_xidneq"]
    pub fn xidneq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsm_handler_in"]
    pub fn tsm_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsm_handler_out"]
    pub fn tsm_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsm_bernoulli_handler"]
    pub fn tsm_bernoulli_handler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsm_system_handler"]
    pub fn tsm_system_handler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_wal_receiver"]
    pub fn pg_stat_get_wal_receiver(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_progress_info"]
    pub fn pg_stat_get_progress_info(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_filter"]
    pub fn tsvector_filter(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_setweight_by_filter"]
    pub fn tsvector_setweight_by_filter(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_delete_str"]
    pub fn tsvector_delete_str(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_unnest"]
    pub fn tsvector_unnest(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_delete_arr"]
    pub fn tsvector_delete_arr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4_avg_combine"]
    pub fn int4_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_combine"]
    pub fn interval_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_to_array"]
    pub fn tsvector_to_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_to_tsvector"]
    pub fn array_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bpchar_sortsupport"]
    pub fn bpchar_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_show_all_file_settings"]
    pub fn show_all_file_settings(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_current_wal_flush_lsn"]
    pub fn pg_current_wal_flush_lsn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bytea_sortsupport"]
    pub fn bytea_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bttext_pattern_sortsupport"]
    pub fn bttext_pattern_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_btbpchar_pattern_sortsupport"]
    pub fn btbpchar_pattern_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_size_bytes"]
    pub fn pg_size_bytes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_serialize"]
    pub fn numeric_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_deserialize"]
    pub fn numeric_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_avg_combine"]
    pub fn numeric_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_poly_combine"]
    pub fn numeric_poly_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_poly_serialize"]
    pub fn numeric_poly_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_poly_deserialize"]
    pub fn numeric_poly_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_combine"]
    pub fn numeric_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_float8_regr_combine"]
    pub fn float8_regr_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_delete_array"]
    pub fn jsonb_delete_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_mul_int8"]
    pub fn cash_mul_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_div_int8"]
    pub fn cash_div_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_current_if_assigned"]
    pub fn txid_current_if_assigned(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_partkeydef"]
    pub fn pg_get_partkeydef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ls_logdir"]
    pub fn pg_ls_logdir(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ls_waldir"]
    pub fn pg_ls_waldir(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ndistinct_in"]
    pub fn pg_ndistinct_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ndistinct_out"]
    pub fn pg_ndistinct_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ndistinct_recv"]
    pub fn pg_ndistinct_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ndistinct_send"]
    pub fn pg_ndistinct_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr_sortsupport"]
    pub fn macaddr_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_txid_status"]
    pub fn txid_status(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_safe_snapshot_blocking_pids"]
    pub fn pg_safe_snapshot_blocking_pids(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_isolation_test_session_is_blocked"]
    pub fn pg_isolation_test_session_is_blocked(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_identify_object_as_address"]
    pub fn pg_identify_object_as_address(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brin_minmax_opcinfo"]
    pub fn brin_minmax_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brin_minmax_add_value"]
    pub fn brin_minmax_add_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brin_minmax_consistent"]
    pub fn brin_minmax_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brin_minmax_union"]
    pub fn brin_minmax_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_avg_accum_inv"]
    pub fn int8_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_poly_sum"]
    pub fn numeric_poly_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_poly_avg"]
    pub fn numeric_poly_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_poly_var_pop"]
    pub fn numeric_poly_var_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_poly_var_samp"]
    pub fn numeric_poly_var_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_poly_stddev_pop"]
    pub fn numeric_poly_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_poly_stddev_samp"]
    pub fn numeric_poly_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexp_match_no_flags"]
    pub fn regexp_match_no_flags(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regexp_match"]
    pub fn regexp_match(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_mul_cash"]
    pub fn int8_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_config"]
    pub fn pg_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_hba_file_rules"]
    pub fn pg_hba_file_rules(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_statistics_obj_is_visible"]
    pub fn pg_statistics_obj_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_dependencies_in"]
    pub fn pg_dependencies_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_dependencies_out"]
    pub fn pg_dependencies_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_dependencies_recv"]
    pub fn pg_dependencies_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_dependencies_send"]
    pub fn pg_dependencies_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_partition_constraintdef"]
    pub fn pg_get_partition_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_hash_extended"]
    pub fn time_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timetz_hash_extended"]
    pub fn timetz_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_hash_extended"]
    pub fn timestamp_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_uuid_hash_extended"]
    pub fn uuid_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_lsn_hash_extended"]
    pub fn pg_lsn_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashenumextended"]
    pub fn hashenumextended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_statisticsobjdef"]
    pub fn pg_get_statisticsobjdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_hash_extended"]
    pub fn jsonb_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hash_range_extended"]
    pub fn hash_range_extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_hash_extended"]
    pub fn interval_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_sha224_bytea"]
    pub fn sha224_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_sha256_bytea"]
    pub fn sha256_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_sha384_bytea"]
    pub fn sha384_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_sha512_bytea"]
    pub fn sha512_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_prefixsel"]
    pub fn prefixsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_prefixjoinsel"]
    pub fn prefixjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_control_system"]
    pub fn pg_control_system(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_control_checkpoint"]
    pub fn pg_control_checkpoint(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_control_recovery"]
    pub fn pg_control_recovery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_control_init"]
    pub fn pg_control_init(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_import_system_collations"]
    pub fn pg_import_system_collations(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_recv"]
    pub fn macaddr8_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_send"]
    pub fn macaddr8_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_collation_actual_version"]
    pub fn pg_collation_actual_version(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_numeric"]
    pub fn jsonb_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_int2"]
    pub fn jsonb_int2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_int4"]
    pub fn jsonb_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_int8"]
    pub fn jsonb_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_float4"]
    pub fn jsonb_float4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_filenode_relation"]
    pub fn pg_filenode_relation(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_from_bytea"]
    pub fn be_lo_from_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_get"]
    pub fn be_lo_get(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_get_fragment"]
    pub fn be_lo_get_fragment(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_be_lo_put"]
    pub fn be_lo_put(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_make_timestamp"]
    pub fn make_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_make_timestamptz"]
    pub fn make_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_make_timestamptz_at_timezone"]
    pub fn make_timestamptz_at_timezone(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_make_interval"]
    pub fn make_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_array_elements_text"]
    pub fn jsonb_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_range_quad_config"]
    pub fn spg_range_quad_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_range_quad_choose"]
    pub fn spg_range_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_range_quad_picksplit"]
    pub fn spg_range_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_range_quad_inner_consistent"]
    pub fn spg_range_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_range_quad_leaf_consistent"]
    pub fn spg_range_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_populate_recordset"]
    pub fn jsonb_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_regoperator"]
    pub fn to_regoperator(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_object_field"]
    pub fn jsonb_object_field(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_regprocedure"]
    pub fn to_regprocedure(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_compare_jsonb"]
    pub fn gin_compare_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_extract_jsonb"]
    pub fn gin_extract_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_extract_jsonb_query"]
    pub fn gin_extract_jsonb_query(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_consistent_jsonb"]
    pub fn gin_consistent_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_extract_jsonb_path"]
    pub fn gin_extract_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_extract_jsonb_query_path"]
    pub fn gin_extract_jsonb_query_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_consistent_jsonb_path"]
    pub fn gin_consistent_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_triconsistent_jsonb"]
    pub fn gin_triconsistent_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_triconsistent_jsonb_path"]
    pub fn gin_triconsistent_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_to_record"]
    pub fn jsonb_to_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_to_recordset"]
    pub fn jsonb_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_regoper"]
    pub fn to_regoper(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_regtype"]
    pub fn to_regtype(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_regproc"]
    pub fn to_regproc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_regclass"]
    pub fn to_regclass(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bool_accum"]
    pub fn bool_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bool_accum_inv"]
    pub fn bool_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bool_alltrue"]
    pub fn bool_alltrue(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bool_anytrue"]
    pub fn bool_anytrue(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anyenum_in"]
    pub fn anyenum_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anyenum_out"]
    pub fn anyenum_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_in"]
    pub fn enum_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_out"]
    pub fn enum_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_eq"]
    pub fn enum_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_ne"]
    pub fn enum_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_lt"]
    pub fn enum_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_gt"]
    pub fn enum_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_le"]
    pub fn enum_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_ge"]
    pub fn enum_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_cmp"]
    pub fn enum_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hashenum"]
    pub fn hashenum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_smaller"]
    pub fn enum_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_larger"]
    pub fn enum_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_first"]
    pub fn enum_first(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_last"]
    pub fn enum_last(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_range_bounds"]
    pub fn enum_range_bounds(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_range_all"]
    pub fn enum_range_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_recv"]
    pub fn enum_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_enum_send"]
    pub fn enum_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_string_agg_transfn"]
    pub fn string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_string_agg_finalfn"]
    pub fn string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_describe_object"]
    pub fn pg_describe_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_format"]
    pub fn text_format(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_format_nv"]
    pub fn text_format_nv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bytea_string_agg_transfn"]
    pub fn bytea_string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_bytea_string_agg_finalfn"]
    pub fn bytea_string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8dec"]
    pub fn int8dec(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8dec_any"]
    pub fn int8dec_any(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_accum_inv"]
    pub fn numeric_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_accum_inv"]
    pub fn interval_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_overlap"]
    pub fn network_overlap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_gist_consistent"]
    pub fn inet_gist_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_gist_union"]
    pub fn inet_gist_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_gist_compress"]
    pub fn inet_gist_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_bool"]
    pub fn jsonb_bool(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_gist_penalty"]
    pub fn inet_gist_penalty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_gist_picksplit"]
    pub fn inet_gist_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_gist_same"]
    pub fn inet_gist_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_networksel"]
    pub fn networksel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_networkjoinsel"]
    pub fn networkjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_larger"]
    pub fn network_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_smaller"]
    pub fn network_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_event_trigger_dropped_objects"]
    pub fn pg_event_trigger_dropped_objects(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2_accum_inv"]
    pub fn int2_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4_accum_inv"]
    pub fn int4_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_accum_inv"]
    pub fn int8_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2_avg_accum_inv"]
    pub fn int2_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4_avg_accum_inv"]
    pub fn int4_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int2int4_sum"]
    pub fn int2int4_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_gist_fetch"]
    pub fn inet_gist_fetch(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_logical_emit_message_text"]
    pub fn pg_logical_emit_message_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_logical_emit_message_bytea"]
    pub fn pg_logical_emit_message_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_insert"]
    pub fn jsonb_insert(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_xact_commit_timestamp"]
    pub fn pg_xact_commit_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_upgrade_set_next_pg_type_oid"]
    pub fn binary_upgrade_set_next_pg_type_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_last_committed_xact"]
    pub fn pg_last_committed_xact(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_upgrade_set_next_array_pg_type_oid"]
    pub fn binary_upgrade_set_next_array_pg_type_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_upgrade_set_next_toast_pg_type_oid"]
    pub fn binary_upgrade_set_next_toast_pg_type_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_upgrade_set_next_heap_pg_class_oid"]
    pub fn binary_upgrade_set_next_heap_pg_class_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_upgrade_set_next_index_pg_class_oid"]
    pub fn binary_upgrade_set_next_index_pg_class_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_upgrade_set_next_toast_pg_class_oid"]
    pub fn binary_upgrade_set_next_toast_pg_class_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_upgrade_set_next_pg_enum_oid"]
    pub fn binary_upgrade_set_next_pg_enum_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_upgrade_set_next_pg_authid_oid"]
    pub fn binary_upgrade_set_next_pg_authid_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_upgrade_create_empty_extension"]
    pub fn binary_upgrade_create_empty_extension(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_event_trigger_in"]
    pub fn event_trigger_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_event_trigger_out"]
    pub fn event_trigger_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvectorin"]
    pub fn tsvectorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvectorout"]
    pub fn tsvectorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsqueryin"]
    pub fn tsqueryin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsqueryout"]
    pub fn tsqueryout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_lt"]
    pub fn tsvector_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_le"]
    pub fn tsvector_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_eq"]
    pub fn tsvector_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_ne"]
    pub fn tsvector_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_ge"]
    pub fn tsvector_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_gt"]
    pub fn tsvector_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_cmp"]
    pub fn tsvector_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_strip"]
    pub fn tsvector_strip(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_setweight"]
    pub fn tsvector_setweight(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_concat"]
    pub fn tsvector_concat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_match_vq"]
    pub fn ts_match_vq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_match_qv"]
    pub fn ts_match_qv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvectorsend"]
    pub fn tsvectorsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvectorrecv"]
    pub fn tsvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquerysend"]
    pub fn tsquerysend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsqueryrecv"]
    pub fn tsqueryrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsvectorin"]
    pub fn gtsvectorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsvectorout"]
    pub fn gtsvectorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsvector_compress"]
    pub fn gtsvector_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsvector_decompress"]
    pub fn gtsvector_decompress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsvector_picksplit"]
    pub fn gtsvector_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsvector_union"]
    pub fn gtsvector_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsvector_same"]
    pub fn gtsvector_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsvector_penalty"]
    pub fn gtsvector_penalty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsvector_consistent"]
    pub fn gtsvector_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_extract_tsvector"]
    pub fn gin_extract_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_extract_tsquery"]
    pub fn gin_extract_tsquery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_tsquery_consistent"]
    pub fn gin_tsquery_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_lt"]
    pub fn tsquery_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_le"]
    pub fn tsquery_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_eq"]
    pub fn tsquery_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_ne"]
    pub fn tsquery_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_ge"]
    pub fn tsquery_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_gt"]
    pub fn tsquery_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_cmp"]
    pub fn tsquery_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_and"]
    pub fn tsquery_and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_or"]
    pub fn tsquery_or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_not"]
    pub fn tsquery_not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_numnode"]
    pub fn tsquery_numnode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquerytree"]
    pub fn tsquerytree(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_rewrite"]
    pub fn tsquery_rewrite(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_rewrite_query"]
    pub fn tsquery_rewrite_query(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsmatchsel"]
    pub fn tsmatchsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsmatchjoinsel"]
    pub fn tsmatchjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_typanalyze"]
    pub fn ts_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_stat1"]
    pub fn ts_stat1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_stat2"]
    pub fn ts_stat2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsq_mcontains"]
    pub fn tsq_mcontains(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsq_mcontained"]
    pub fn tsq_mcontained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsquery_compress"]
    pub fn gtsquery_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_text_starts_with"]
    pub fn text_starts_with(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsquery_picksplit"]
    pub fn gtsquery_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsquery_union"]
    pub fn gtsquery_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsquery_same"]
    pub fn gtsquery_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsquery_penalty"]
    pub fn gtsquery_penalty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsquery_consistent"]
    pub fn gtsquery_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_rank_wttf"]
    pub fn ts_rank_wttf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_rank_wtt"]
    pub fn ts_rank_wtt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_rank_ttf"]
    pub fn ts_rank_ttf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_rank_tt"]
    pub fn ts_rank_tt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_rankcd_wttf"]
    pub fn ts_rankcd_wttf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_rankcd_wtt"]
    pub fn ts_rankcd_wtt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_rankcd_ttf"]
    pub fn ts_rankcd_ttf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_rankcd_tt"]
    pub fn ts_rankcd_tt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_length"]
    pub fn tsvector_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_token_type_byid"]
    pub fn ts_token_type_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_token_type_byname"]
    pub fn ts_token_type_byname(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_parse_byid"]
    pub fn ts_parse_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_parse_byname"]
    pub fn ts_parse_byname(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_prsd_start"]
    pub fn prsd_start(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_prsd_nexttoken"]
    pub fn prsd_nexttoken(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_prsd_end"]
    pub fn prsd_end(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_prsd_headline"]
    pub fn prsd_headline(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_prsd_lextype"]
    pub fn prsd_lextype(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_lexize"]
    pub fn ts_lexize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_cmp_tslexeme"]
    pub fn gin_cmp_tslexeme(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dsimple_init"]
    pub fn dsimple_init(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dsimple_lexize"]
    pub fn dsimple_lexize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dsynonym_init"]
    pub fn dsynonym_init(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dsynonym_lexize"]
    pub fn dsynonym_lexize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dispell_init"]
    pub fn dispell_init(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_dispell_lexize"]
    pub fn dispell_lexize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regconfigin"]
    pub fn regconfigin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regconfigout"]
    pub fn regconfigout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regconfigrecv"]
    pub fn regconfigrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regconfigsend"]
    pub fn regconfigsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_thesaurus_init"]
    pub fn thesaurus_init(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_thesaurus_lexize"]
    pub fn thesaurus_lexize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline_byid_opt"]
    pub fn ts_headline_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline_byid"]
    pub fn ts_headline_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_tsvector_byid"]
    pub fn to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_tsquery_byid"]
    pub fn to_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_plainto_tsquery_byid"]
    pub fn plainto_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_tsvector"]
    pub fn to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_tsquery"]
    pub fn to_tsquery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_plainto_tsquery"]
    pub fn plainto_tsquery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_update_trigger_byid"]
    pub fn tsvector_update_trigger_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsvector_update_trigger_bycolumn"]
    pub fn tsvector_update_trigger_bycolumn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline_opt"]
    pub fn ts_headline_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline"]
    pub fn ts_headline(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ts_parser_is_visible"]
    pub fn pg_ts_parser_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ts_dict_is_visible"]
    pub fn pg_ts_dict_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ts_config_is_visible"]
    pub fn pg_ts_config_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_get_current_ts_config"]
    pub fn get_current_ts_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_match_tt"]
    pub fn ts_match_tt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_match_tq"]
    pub fn ts_match_tq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_ts_template_is_visible"]
    pub fn pg_ts_template_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regdictionaryin"]
    pub fn regdictionaryin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regdictionaryout"]
    pub fn regdictionaryout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regdictionaryrecv"]
    pub fn regdictionaryrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regdictionarysend"]
    pub fn regdictionarysend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_reset_shared"]
    pub fn pg_stat_reset_shared(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_reset_single_table_counters"]
    pub fn pg_stat_reset_single_table_counters(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_reset_single_function_counters"]
    pub fn pg_stat_reset_single_function_counters(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_tablespace_location"]
    pub fn pg_tablespace_location(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_create_physical_replication_slot"]
    pub fn pg_create_physical_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_drop_replication_slot"]
    pub fn pg_drop_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_replication_slots"]
    pub fn pg_get_replication_slots(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_logical_slot_get_changes"]
    pub fn pg_logical_slot_get_changes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_logical_slot_get_binary_changes"]
    pub fn pg_logical_slot_get_binary_changes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_logical_slot_peek_changes"]
    pub fn pg_logical_slot_peek_changes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_logical_slot_peek_binary_changes"]
    pub fn pg_logical_slot_peek_binary_changes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_create_logical_replication_slot"]
    pub fn pg_create_logical_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_jsonb"]
    pub fn to_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_snapshot_timestamp"]
    pub fn pg_stat_get_snapshot_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_clean_pending_list"]
    pub fn gin_clean_pending_list(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsvector_consistent_oldsig"]
    pub fn gtsvector_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_extract_tsquery_oldsig"]
    pub fn gin_extract_tsquery_oldsig(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_tsquery_consistent_oldsig"]
    pub fn gin_tsquery_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gtsquery_consistent_oldsig"]
    pub fn gtsquery_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_spg_config"]
    pub fn inet_spg_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_spg_choose"]
    pub fn inet_spg_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_spg_picksplit"]
    pub fn inet_spg_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_spg_inner_consistent"]
    pub fn inet_spg_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_spg_leaf_consistent"]
    pub fn inet_spg_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_current_logfile"]
    pub fn pg_current_logfile(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_current_logfile_1arg"]
    pub fn pg_current_logfile_1arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_send"]
    pub fn jsonb_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_out"]
    pub fn jsonb_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_recv"]
    pub fn jsonb_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_in"]
    pub fn jsonb_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_function_arg_default"]
    pub fn pg_get_function_arg_default(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_export_snapshot"]
    pub fn pg_export_snapshot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_is_in_recovery"]
    pub fn pg_is_in_recovery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4_cash"]
    pub fn int4_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8_cash"]
    pub fn int8_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_is_in_backup"]
    pub fn pg_is_in_backup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_backup_start_time"]
    pub fn pg_backup_start_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_collation_is_visible"]
    pub fn pg_collation_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_typanalyze"]
    pub fn array_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_arraycontsel"]
    pub fn arraycontsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_arraycontjoinsel"]
    pub fn arraycontjoinsel(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_multixact_members"]
    pub fn pg_get_multixact_members(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_last_wal_receive_lsn"]
    pub fn pg_last_wal_receive_lsn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_last_wal_replay_lsn"]
    pub fn pg_last_wal_replay_lsn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_div_cash"]
    pub fn cash_div_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_cash_numeric"]
    pub fn cash_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numeric_cash"]
    pub fn numeric_cash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_read_file_all"]
    pub fn pg_read_file_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_read_binary_file_off_len"]
    pub fn pg_read_binary_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_read_binary_file_all"]
    pub fn pg_read_binary_file_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_opfamily_is_visible"]
    pub fn pg_opfamily_is_visible(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_last_xact_replay_timestamp"]
    pub fn pg_last_xact_replay_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anyrange_in"]
    pub fn anyrange_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_anyrange_out"]
    pub fn anyrange_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_in"]
    pub fn range_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_out"]
    pub fn range_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_recv"]
    pub fn range_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_send"]
    pub fn range_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_identify_object"]
    pub fn pg_identify_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_constructor2"]
    pub fn range_constructor2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_constructor3"]
    pub fn range_constructor3(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_relation_is_updatable"]
    pub fn pg_relation_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_column_is_updatable"]
    pub fn pg_column_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_make_date"]
    pub fn make_date(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_make_time"]
    pub fn make_time(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_lower"]
    pub fn range_lower(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_upper"]
    pub fn range_upper(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_empty"]
    pub fn range_empty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_lower_inc"]
    pub fn range_lower_inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_upper_inc"]
    pub fn range_upper_inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_lower_inf"]
    pub fn range_lower_inf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_upper_inf"]
    pub fn range_upper_inf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_eq"]
    pub fn range_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_ne"]
    pub fn range_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_overlaps"]
    pub fn range_overlaps(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_contains_elem"]
    pub fn range_contains_elem(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_contains"]
    pub fn range_contains(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_elem_contained_by_range"]
    pub fn elem_contained_by_range(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_contained_by"]
    pub fn range_contained_by(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_adjacent"]
    pub fn range_adjacent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_before"]
    pub fn range_before(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_after"]
    pub fn range_after(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_overleft"]
    pub fn range_overleft(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_overright"]
    pub fn range_overright(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_union"]
    pub fn range_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_intersect"]
    pub fn range_intersect(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_minus"]
    pub fn range_minus(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_cmp"]
    pub fn range_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_lt"]
    pub fn range_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_le"]
    pub fn range_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_ge"]
    pub fn range_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_gt"]
    pub fn range_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_gist_consistent"]
    pub fn range_gist_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_gist_union"]
    pub fn range_gist_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_slot_advance"]
    pub fn pg_replication_slot_advance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_gist_penalty"]
    pub fn range_gist_penalty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_gist_picksplit"]
    pub fn range_gist_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_gist_same"]
    pub fn range_gist_same(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hash_range"]
    pub fn hash_range(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4range_canonical"]
    pub fn int4range_canonical(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_daterange_canonical"]
    pub fn daterange_canonical(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_typanalyze"]
    pub fn range_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_transform"]
    pub fn timestamp_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_interval_transform"]
    pub fn interval_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ginarraytriconsistent"]
    pub fn ginarraytriconsistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_gin_tsquery_triconsistent"]
    pub fn gin_tsquery_triconsistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int4range_subdiff"]
    pub fn int4range_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8range_subdiff"]
    pub fn int8range_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_numrange_subdiff"]
    pub fn numrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_daterange_subdiff"]
    pub fn daterange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_int8range_canonical"]
    pub fn int8range_canonical(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsrange_subdiff"]
    pub fn tsrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tstzrange_subdiff"]
    pub fn tstzrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_object_keys"]
    pub fn jsonb_object_keys(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_each_text"]
    pub fn jsonb_each_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_mxid_age"]
    pub fn mxid_age(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_extract_path_text"]
    pub fn jsonb_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_acldefault_sql"]
    pub fn acldefault_sql(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_time_transform"]
    pub fn time_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_object_field"]
    pub fn json_object_field(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_object_field_text"]
    pub fn json_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_array_element"]
    pub fn json_array_element(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_array_element_text"]
    pub fn json_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_extract_path"]
    pub fn json_extract_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brin_summarize_new_values"]
    pub fn brin_summarize_new_values(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_extract_path_text"]
    pub fn json_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_object_address"]
    pub fn pg_get_object_address(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_array_elements"]
    pub fn json_array_elements(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_array_length"]
    pub fn json_array_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_object_keys"]
    pub fn json_object_keys(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_each"]
    pub fn json_each(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_each_text"]
    pub fn json_each_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_populate_record"]
    pub fn json_populate_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_populate_recordset"]
    pub fn json_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_typeof"]
    pub fn json_typeof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_array_elements_text"]
    pub fn json_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ordered_set_transition"]
    pub fn ordered_set_transition(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ordered_set_transition_multi"]
    pub fn ordered_set_transition_multi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_percentile_disc_final"]
    pub fn percentile_disc_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_percentile_cont_float8_final"]
    pub fn percentile_cont_float8_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_percentile_cont_interval_final"]
    pub fn percentile_cont_interval_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_percentile_disc_multi_final"]
    pub fn percentile_disc_multi_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_percentile_cont_float8_multi_final"]
    pub fn percentile_cont_float8_multi_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_percentile_cont_interval_multi_final"]
    pub fn percentile_cont_interval_multi_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_mode_final"]
    pub fn mode_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hypothetical_rank_final"]
    pub fn hypothetical_rank_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hypothetical_percent_rank_final"]
    pub fn hypothetical_percent_rank_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hypothetical_cume_dist_final"]
    pub fn hypothetical_cume_dist_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_hypothetical_dense_rank_final"]
    pub fn hypothetical_dense_rank_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_izone_transform"]
    pub fn timestamp_izone_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_timestamp_zone_transform"]
    pub fn timestamp_zone_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brin_summarize_range"]
    pub fn brin_summarize_range(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brin_desummarize_range"]
    pub fn brin_desummarize_range(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_quad_config"]
    pub fn spg_quad_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_quad_choose"]
    pub fn spg_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_quad_picksplit"]
    pub fn spg_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_quad_inner_consistent"]
    pub fn spg_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_quad_leaf_consistent"]
    pub fn spg_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_kd_config"]
    pub fn spg_kd_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_kd_choose"]
    pub fn spg_kd_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_kd_picksplit"]
    pub fn spg_kd_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_kd_inner_consistent"]
    pub fn spg_kd_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_text_config"]
    pub fn spg_text_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_text_choose"]
    pub fn spg_text_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_text_picksplit"]
    pub fn spg_text_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_text_inner_consistent"]
    pub fn spg_text_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_text_leaf_consistent"]
    pub fn spg_text_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_sequence_last_value"]
    pub fn pg_sequence_last_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_ne"]
    pub fn jsonb_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_lt"]
    pub fn jsonb_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_gt"]
    pub fn jsonb_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_le"]
    pub fn jsonb_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_ge"]
    pub fn jsonb_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_eq"]
    pub fn jsonb_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_cmp"]
    pub fn jsonb_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_hash"]
    pub fn jsonb_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_contains"]
    pub fn jsonb_contains(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_exists"]
    pub fn jsonb_exists(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_exists_any"]
    pub fn jsonb_exists_any(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_exists_all"]
    pub fn jsonb_exists_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_contained"]
    pub fn jsonb_contained(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_agg_array_transfn"]
    pub fn array_agg_array_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_array_agg_array_finalfn"]
    pub fn array_agg_array_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_range_merge"]
    pub fn range_merge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_merge"]
    pub fn inet_merge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_boxes_bound_box"]
    pub fn boxes_bound_box(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_inet_same_family"]
    pub fn inet_same_family(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_upgrade_set_record_init_privs"]
    pub fn binary_upgrade_set_record_init_privs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regnamespacein"]
    pub fn regnamespacein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regnamespaceout"]
    pub fn regnamespaceout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_regnamespace"]
    pub fn to_regnamespace(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regnamespacerecv"]
    pub fn regnamespacerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regnamespacesend"]
    pub fn regnamespacesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_point_box"]
    pub fn point_box(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regroleout"]
    pub fn regroleout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_to_regrole"]
    pub fn to_regrole(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regrolerecv"]
    pub fn regrolerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regrolesend"]
    pub fn regrolesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_regrolein"]
    pub fn regrolein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_rotate_logfile"]
    pub fn pg_rotate_logfile(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_read_file"]
    pub fn pg_read_file(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_binary_upgrade_set_missing_value"]
    pub fn binary_upgrade_set_missing_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brin_inclusion_opcinfo"]
    pub fn brin_inclusion_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brin_inclusion_add_value"]
    pub fn brin_inclusion_add_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brin_inclusion_consistent"]
    pub fn brin_inclusion_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_brin_inclusion_union"]
    pub fn brin_inclusion_union(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_in"]
    pub fn macaddr8_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_out"]
    pub fn macaddr8_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_trunc"]
    pub fn macaddr8_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_eq"]
    pub fn macaddr8_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_lt"]
    pub fn macaddr8_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_le"]
    pub fn macaddr8_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_gt"]
    pub fn macaddr8_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_ge"]
    pub fn macaddr8_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_ne"]
    pub fn macaddr8_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_cmp"]
    pub fn macaddr8_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_not"]
    pub fn macaddr8_not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_and"]
    pub fn macaddr8_and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_or"]
    pub fn macaddr8_or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddrtomacaddr8"]
    pub fn macaddrtomacaddr8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8tomacaddr"]
    pub fn macaddr8tomacaddr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_macaddr8_set7bit"]
    pub fn macaddr8_set7bit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_int8_int8"]
    pub fn in_range_int8_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_int4_int8"]
    pub fn in_range_int4_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_int4_int4"]
    pub fn in_range_int4_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_int4_int2"]
    pub fn in_range_int4_int2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_int2_int8"]
    pub fn in_range_int2_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_int2_int4"]
    pub fn in_range_int2_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_int2_int2"]
    pub fn in_range_int2_int2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_date_interval"]
    pub fn in_range_date_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_timestamp_interval"]
    pub fn in_range_timestamp_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_timestamptz_interval"]
    pub fn in_range_timestamptz_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_interval_interval"]
    pub fn in_range_interval_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_time_interval"]
    pub fn in_range_time_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_timetz_interval"]
    pub fn in_range_timetz_interval(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_float8_float8"]
    pub fn in_range_float8_float8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_float4_float8"]
    pub fn in_range_float4_float8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_in_range_numeric_numeric"]
    pub fn in_range_numeric_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline_jsonb_byid_opt"]
    pub fn ts_headline_jsonb_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline_jsonb_byid"]
    pub fn ts_headline_jsonb_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline_jsonb_opt"]
    pub fn ts_headline_jsonb_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline_jsonb"]
    pub fn ts_headline_jsonb(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline_json_byid_opt"]
    pub fn ts_headline_json_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline_json_byid"]
    pub fn ts_headline_json_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline_json_opt"]
    pub fn ts_headline_json_opt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_ts_headline_json"]
    pub fn ts_headline_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_string_to_tsvector"]
    pub fn jsonb_string_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_string_to_tsvector"]
    pub fn json_string_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_string_to_tsvector_byid"]
    pub fn jsonb_string_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_string_to_tsvector_byid"]
    pub fn json_string_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_to_tsvector"]
    pub fn jsonb_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_jsonb_to_tsvector_byid"]
    pub fn jsonb_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_to_tsvector"]
    pub fn json_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_json_to_tsvector_byid"]
    pub fn json_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_event_trigger_table_rewrite_oid"]
    pub fn pg_event_trigger_table_rewrite_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_event_trigger_table_rewrite_reason"]
    pub fn pg_event_trigger_table_rewrite_reason(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_event_trigger_ddl_commands"]
    pub fn pg_event_trigger_ddl_commands(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_phraseto_tsquery"]
    pub fn phraseto_tsquery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_phrase"]
    pub fn tsquery_phrase(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_tsquery_phrase_distance"]
    pub fn tsquery_phrase_distance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_phraseto_tsquery_byid"]
    pub fn phraseto_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_websearch_to_tsquery_byid"]
    pub fn websearch_to_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_websearch_to_tsquery"]
    pub fn websearch_to_tsquery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_bbox_quad_config"]
    pub fn spg_bbox_quad_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_poly_quad_compress"]
    pub fn spg_poly_quad_compress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_box_quad_config"]
    pub fn spg_box_quad_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_box_quad_choose"]
    pub fn spg_box_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_box_quad_picksplit"]
    pub fn spg_box_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_box_quad_inner_consistent"]
    pub fn spg_box_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_spg_box_quad_leaf_consistent"]
    pub fn spg_box_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_satisfies_hash_partition"]
    pub fn satisfies_hash_partition(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_origin_create"]
    pub fn pg_replication_origin_create(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_origin_drop"]
    pub fn pg_replication_origin_drop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_origin_oid"]
    pub fn pg_replication_origin_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_origin_session_setup"]
    pub fn pg_replication_origin_session_setup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_origin_session_reset"]
    pub fn pg_replication_origin_session_reset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_origin_session_is_setup"]
    pub fn pg_replication_origin_session_is_setup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_origin_session_progress"]
    pub fn pg_replication_origin_session_progress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_origin_xact_setup"]
    pub fn pg_replication_origin_xact_setup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_origin_xact_reset"]
    pub fn pg_replication_origin_xact_reset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_origin_advance"]
    pub fn pg_replication_origin_advance(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_replication_origin_progress"]
    pub fn pg_replication_origin_progress(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_show_replication_origin_status"]
    pub fn pg_show_replication_origin_status(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_stat_get_subscription"]
    pub fn pg_stat_get_subscription(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_publication_tables"]
    pub fn pg_get_publication_tables(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_get_replica_identity_index"]
    pub fn pg_get_replica_identity_index(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_pg_relation_is_publishable"]
    pub fn pg_relation_is_publishable(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_parse_bool"]
    pub fn parse_bool(value: *const ::std::os::raw::c_char, result: *mut bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_parse_bool_with_len"]
    pub fn parse_bool_with_len(
        value: *const ::std::os::raw::c_char,
        len: usize,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_domain_check"]
    pub fn domain_check(
        value: Datum,
        isnull: bool,
        domainType: Oid,
        extra: *mut *mut ::std::os::raw::c_void,
        mcxt: MemoryContext,
    );
}
extern "C" {
    #[link_name = "\u{1}_errdatatype"]
    pub fn errdatatype(datatypeOid: Oid) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_errdomainconstraint"]
    pub fn errdomainconstraint(
        datatypeOid: Oid,
        conname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_hex_encode"]
    pub fn hex_encode(
        src: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_hex_decode"]
    pub fn hex_decode(
        src: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_buildint2vector"]
    pub fn buildint2vector(int2s: *const int16, n: ::std::os::raw::c_int) -> *mut int2vector;
}
extern "C" {
    #[link_name = "\u{1}_namecpy"]
    pub fn namecpy(n1: Name, n2: Name) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_namestrcpy"]
    pub fn namestrcpy(name: Name, str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_namestrcmp"]
    pub fn namestrcmp(name: Name, str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pg_atoi"]
    pub fn pg_atoi(
        s: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
    ) -> int32;
}
extern "C" {
    #[link_name = "\u{1}_pg_itoa"]
    pub fn pg_itoa(i: int16, a: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_pg_ltoa"]
    pub fn pg_ltoa(l: int32, a: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_pg_lltoa"]
    pub fn pg_lltoa(ll: int64, a: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_pg_ltostr_zeropad"]
    pub fn pg_ltostr_zeropad(
        str: *mut ::std::os::raw::c_char,
        value: int32,
        minwidth: int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_pg_ltostr"]
    pub fn pg_ltostr(str: *mut ::std::os::raw::c_char, value: int32)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_pg_strtouint64"]
    pub fn pg_strtouint64(
        str: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> uint64;
}
extern "C" {
    #[link_name = "\u{1}_extra_float_digits"]
    pub static mut extra_float_digits: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_get_float8_infinity"]
    pub fn get_float8_infinity() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_get_float4_infinity"]
    pub fn get_float4_infinity() -> f32;
}
extern "C" {
    #[link_name = "\u{1}_get_float8_nan"]
    pub fn get_float8_nan() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_get_float4_nan"]
    pub fn get_float4_nan() -> f32;
}
extern "C" {
    #[link_name = "\u{1}_is_infinite"]
    pub fn is_infinite(val: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_float8in_internal"]
    pub fn float8in_internal(
        num: *mut ::std::os::raw::c_char,
        endptr_p: *mut *mut ::std::os::raw::c_char,
        type_name: *const ::std::os::raw::c_char,
        orig_string: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_float8out_internal"]
    pub fn float8out_internal(num: f64) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_float4_cmp_internal"]
    pub fn float4_cmp_internal(a: float4, b: float4) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_float8_cmp_internal"]
    pub fn float8_cmp_internal(a: float8, b: float8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_buildoidvector"]
    pub fn buildoidvector(oids: *const Oid, n: ::std::os::raw::c_int) -> *mut oidvector;
}
extern "C" {
    #[link_name = "\u{1}_oidparse"]
    pub fn oidparse(node: *mut Node) -> Oid;
}
extern "C" {
    #[link_name = "\u{1}_oid_cmp"]
    pub fn oid_cmp(
        p1: *const ::std::os::raw::c_void,
        p2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_regexp_fixed_prefix"]
    pub fn regexp_fixed_prefix(
        text_re: *mut text,
        case_insensitive: bool,
        collation: Oid,
        exact: *mut bool,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_quote_all_identifiers"]
    pub static mut quote_all_identifiers: bool;
}
extern "C" {
    #[link_name = "\u{1}_quote_identifier"]
    pub fn quote_identifier(ident: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_quote_qualified_identifier"]
    pub fn quote_qualified_identifier(
        qualifier: *const ::std::os::raw::c_char,
        ident: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_generate_operator_clause"]
    pub fn generate_operator_clause(
        buf: fmStringInfo,
        leftop: *const ::std::os::raw::c_char,
        leftoptype: Oid,
        opoid: Oid,
        rightop: *const ::std::os::raw::c_char,
        rightoptype: Oid,
    );
}
extern "C" {
    #[link_name = "\u{1}_bpchartruelen"]
    pub fn bpchartruelen(
        s: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cstring_to_text"]
    pub fn cstring_to_text(s: *const ::std::os::raw::c_char) -> *mut text;
}
extern "C" {
    #[link_name = "\u{1}_cstring_to_text_with_len"]
    pub fn cstring_to_text_with_len(
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut text;
}
extern "C" {
    #[link_name = "\u{1}_text_to_cstring"]
    pub fn text_to_cstring(t: *const text) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_text_to_cstring_buffer"]
    pub fn text_to_cstring_buffer(
        src: *const text,
        dst: *mut ::std::os::raw::c_char,
        dst_len: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_xidComparator"]
    pub fn xidComparator(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet_cidr_ntop"]
    pub fn inet_cidr_ntop(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        bits: ::std::os::raw::c_int,
        dst: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_inet_net_pton"]
    pub fn inet_net_pton(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_convert_network_to_scalar"]
    pub fn convert_network_to_scalar(value: Datum, typid: Oid, failure: *mut bool) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_network_scan_first"]
    pub fn network_scan_first(in_: Datum) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_network_scan_last"]
    pub fn network_scan_last(in_: Datum) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_clean_ipv6_addr"]
    pub fn clean_ipv6_addr(addr_family: ::std::os::raw::c_int, addr: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_numeric_float8_no_overflow"]
    pub fn numeric_float8_no_overflow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "\u{1}_format_type_extended"]
    pub fn format_type_extended(
        type_oid: Oid,
        typemod: int32,
        flags: bits16,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_format_type_be"]
    pub fn format_type_be(type_oid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_format_type_be_qualified"]
    pub fn format_type_be_qualified(type_oid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_format_type_with_typemod"]
    pub fn format_type_with_typemod(type_oid: Oid, typemod: int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_type_maximum_size"]
    pub fn type_maximum_size(type_oid: Oid, typemod: int32) -> int32;
}
extern "C" {
    #[link_name = "\u{1}_quote_literal_cstr"]
    pub fn quote_literal_cstr(rawstr: *const ::std::os::raw::c_char)
        -> *mut ::std::os::raw::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryContextData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FdwRoutine {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JitContext {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JitInstrumentation {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedJitInstrumentation {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionTupleRouting {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct binaryheap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TsmRoutine {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFuncRoutine {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowObjectData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelExecutorInfo {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleQueueReader {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OverrideSearchPath {
    pub _address: u8,
}
